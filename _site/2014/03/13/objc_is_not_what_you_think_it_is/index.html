<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="morisunshine" />
    <title>Objective-C 不是你想的那样 | morisunshine</title>
    <link rel="shortcut icon" href="/favicon.ico">
    <link href="/feed/" rel="alternate" title="morisunshine" type="application/atom+xml" />
    <link rel="stylesheet" href="/media/css/style.css">
    <link rel="stylesheet" href="/media/css/highlight.css">
    <script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
  </head>
  <script type="text/javascript">
    function setTimeSpan(){
    	var date = new Date();
    	timeSpan.innerText=date.format('yyyy-MM-dd hh:mm:ss');
    }
    
    Date.prototype.format = function(format)
		{
    var o =
    	{
    	    "M+" : this.getMonth()+1, //month
    	    "d+" : this.getDate(),    //day
    	    "h+" : this.getHours(),   //hour
    	    "m+" : this.getMinutes(), //minute
    	    "s+" : this.getSeconds(), //second
    	    "q+" : Math.floor((this.getMonth()+3)/3),  //quarter
    	    "S" : this.getMilliseconds() //millisecond
    	}
    	if(/(y+)/.test(format))
    	format=format.replace(RegExp.$1,(this.getFullYear()+"").substr(4 - RegExp.$1.length));
    	for(var k in o)
    	if(new RegExp("("+ k +")").test(format))
    	format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] : ("00"+ o[k]).substr((""+ o[k]).length));
    	return format;
		}
  </script>
  <body onLoad="setInterval(setTimeSpan,1000);">
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>Objective-C 不是你想的那样</h1>
        </header>
        <nav>
        <span><a title="home page" class="" href="/">Home</a></span>
        <span><a title="about" class="" href="/about/">About</a></span>
        <span><a title="guestbook" class="" href="/guestbook/">Guestbook</a></span>
        <span><a title="categories" class="" href="/categories/">Categories</a></span>
        <span><a title="tags" class="" href="/tags/">Tags</a></span>
        <span><a title="links" class="" href="/links/">Links</a></span>
        <span><a title="subscribe by RSS" class="" href="/feed/">Subscribe</a></span>
        </nav>
        <article class="content">
        <section class="post">
<p>本文由<a href="http://morisunshine.com/">morisunshine</a>译自<a href="http://news.rapgenius.com/Soroush-khanlou-objective-c-isnt-what-you-think-it-is-if-you-think-like-a-rubyist-annotated">&quot;Objective-C isn&#39;t what you think it is&quot;</a>。转载请注明出处！</p>

<hr>

<p>&nbsp;<a href="#message_in_a_bottle"><strong>消息的传递</strong></a><br>
&nbsp;<a href="#getting_metaer_and_metaer"><strong>变得越来越动态</strong></a><br>
&nbsp;<a href="#introspection"><strong>内省</strong></a><br>
&nbsp;<a href="#cashing_in"><strong>现学现用</strong></a><br>
&nbsp;<a href="#what_is_comepielur"><strong>什么是编译器？</strong></a>  </p>

<p>Ruby 和 Objective-C 这两种语言看上去好像天南地北：一种是动态语言，另一种则是静态语言；一种是解释型语言，另一种是编译型语言；一种有简洁的语法，另一种则是有点冗长的语法。从优雅的角度来看，Ruby似乎更能给我们一种自由的编程体验，所以很多人都放弃了Objective-C。</p>

<p>但这是一个不幸的笑话。Objective-C其实并不像别人认为的那样是件紧身衣，它和Ruby一样都受Smalltalk影响，它拥有很多Ruby开发者都喜爱的语言功能–动态方法查找、鸭子类型、开放的类和通常情况下高度可变的runtime等这些功能在Objective-C中同样存在，即使那些不出名的技术也是一样。Objective-C的这些功能都要归功于它的IDE和编译器，但也是因为它们才使你不能自由地编写代码</p>

<p>但是等一下，怎么能说Objective-C是动态语言呢？难道它不是建立在C语言的基础上？</p>

<p>你可以在Objective-C代码中包含任何C或C++的代码，但这不意味着Objective-C仅限于C或C++代码。Objective-C中所有有意思的类操作和对象内省都是来自于一个叫Objective-C Runtime的东西。这个Objective-C Runtime可以和Ruby解释器相媲美。它包含了强大的元编程里所需要的所有重要特性。</p>

<p>其实C语言和Ruby一样是支持这些特性的，用<code>property_getAttributes</code>或<code>method_getImplementation</code>方法就能将selector对应到具体实现(一个selector处理一个方法)，并判断这个对象能否对这个selector做出反应，再遍历子类树。在Objective-C的众多方法中，最重要的就是<code>objc_msgSend</code>方法，是它推动了应用中的每次消息发送。</p>

<hr>

<p><a id='message_in_a_bottle' name='message_in_a_bottle'> </a></p>

<h2>消息的传递</h2>

<p>Smalltalk才是实至名归的第一种面向对象语言，它用“从一个对象发送信息给另一个对象”的新概念取代了“调用函数”的旧概念，对后面的语言发展产生了深远的影响。</p>

<p>你可以在Ruby中通过这样写来实现消息的发送：</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">receiver</span><span class="o">.</span><span class="n">the_message</span> <span class="n">argument</span>
</code></pre></div>
<p>Objective-C的实现方式和Ruby的差不多：</p>
<div class="highlight"><pre><code class="objc language-objc" data-lang="objc"><span class="p">[</span><span class="n">receiver</span> <span class="n">theMessage</span><span class="o">:</span><span class="n">argument</span><span class="p">];</span>
</code></pre></div>
<p>这些消息实现了鸭子类型的方式，也就是说关注的不是这个对象的类型或类本身，而是这个对象能否对一个消息做出反应。</p>

<p>发送消息真的是非常棒的事，但是只有当消息在传送数据时，它的价值才会被发挥地更大：</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="n">receiver</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:the_message</span><span class="p">,</span> <span class="n">argument</span><span class="p">)</span>
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><code class="objc language-objc" data-lang="objc"><span class="p">[</span><span class="n">receiver</span> <span class="n">performSelector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">theMessage</span><span class="o">:</span><span class="p">)</span> 
<span class="nl">withObject:</span><span class="n">argument</span><span class="p">];</span>
</code></pre></div>
<p>正如Ruby中方法需要symbol支持一样，Objective-C中selector也需要string来支持。（在Objective-C中没有symbol。）这样就可以让你通过动态的方式使用一个方法。你甚至可以通过<code>NSSelectorFromString</code>方法来使用string创建一个selector，并在一个对象里执行它。同样的，我们可以在Ruby中也可以创建一个string或symbol，并把传给<code>Object#send</code>方法。</p>

<p>当然，无论是哪种语言，一旦你将一个消息发送给不能处理该消息的对象，那么默认情况下就会抛出一个异常，还会导致应用的崩溃。</p>

<p>当你想在调用一个方法前判断一下这个对象是否能够执行这个方法，你可以用Ruby中的<code>respond_to？</code>方法来检查：</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">if</span> <span class="n">receiver</span><span class="o">.</span><span class="n">respond_to?</span> <span class="ss">:the_message</span>
  <span class="n">receiver</span><span class="o">.</span><span class="n">the_message</span> <span class="n">argument</span>
<span class="k">end</span>
</code></pre></div>
<p>Objective-C中也有差不多的方法：</p>
<div class="highlight"><pre><code class="objc language-objc" data-lang="objc"><span class="k">if</span> <span class="p">([</span><span class="n">receiver</span> <span class="n">respondsToSelector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">theMessage</span><span class="o">:</span><span class="p">)])</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">receiver</span> <span class="n">theMessage</span><span class="o">:</span><span class="n">someThing</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<hr>

<p><a id='getting_metaer_and_metaer' name='getting_metaer_and_metaer'> </a></p>

<h2>变得越来越动态</h2>

<p>如果你想在一个不能修改的类（像系统类）中添加你想要的方法，那么Objective-C里的category一定不会让你失望 -- 很像Ruby中的“开放类”。</p>

<p>举个例子，如果你想将Rails中的<code>to_sentence</code>方法添加到<code>NSArray</code>类中，我们只需要对<code>NSArray</code>这个类进行扩展就好了：</p>
<div class="highlight"><pre><code class="objc language-objc" data-lang="objc"><span class="k">@interface</span> <span class="nc">NSArray</span> <span class="nl">(ToSentence)</span>

<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">toSentence</span><span class="p">;</span>

<span class="k">@end</span>


<span class="k">@implementation</span> <span class="nc">NSArray</span> <span class="nl">(ToSentence)</span>

<span class="k">-</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">toSentence</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">lastObject</span><span class="p">];</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">allButLastObject</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">subarrayWithRange</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">)];</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">allButLastObject</span> <span class="n">componentsJoinedByString</span><span class="o">:</span><span class="p">@</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;,</span> <span class="o">&amp;</span><span class="n">quot</span><span class="p">;];</span>
    <span class="kt">BOOL</span> <span class="n">showComma</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">count</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span> <span class="n">stringByAppendingFormat</span><span class="o">:</span><span class="p">@</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;</span><span class="o">%</span><span class="p">@</span> <span class="n">and</span> <span class="o">&amp;</span><span class="n">quot</span><span class="p">;,</span> <span class="n">showComma</span> <span class="o">?</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;,</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;</span> <span class="o">:</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;];</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span> <span class="n">stringByAppendingString</span><span class="o">:</span><span class="p">[</span><span class="n">self</span> <span class="n">lastObject</span><span class="p">]];</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div>
<p>Category是在编译的时候将方法添加到程序中 -- 让我们在runtime中动态捕捉它们怎么样？</p>

<p>有些消息可以嵌套数据，就像Rails的dynamic finders。Ruby通过对<code>method_missing</code> 和 <code>respond_to</code>这两个方法的重写，先匹配模式，再将新方法的定义添加到这个对象中。</p>

<p>Objective-C中的流程是差不多，但我们不是重写<code>doesNotRecognizeSelector:</code>方法（相当于Ruby中的<code>method_missing</code>方法），而是在<code>resolveClassMethod:</code>方法中捕捉Category添加的方法。假设我们有一个叫<code>+findWhere:equals:</code>的类方法，它可以得到property的名称和值，那么通过正则表达式就可以很容易实现找到property的名字，并通过block来注册这个selector。</p>
<div class="highlight"><pre><code class="objc language-objc" data-lang="objc"><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">resolveClassMethod:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">sel</span> <span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">selectorName</span> <span class="o">=</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">sel</span><span class="p">);</span>

    <span class="n">NSRegularExpression</span> <span class="o">*</span><span class="n">regex</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSRegularExpression</span> <span class="n">regularExpressionWithPattern</span><span class="o">:</span><span class="p">@</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;</span><span class="o">^</span><span class="n">findWhere</span><span class="p">(</span><span class="err">\\</span><span class="n">w</span><span class="o">+</span><span class="p">)</span><span class="n">Equals</span><span class="o">:</span><span class="err">$</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;</span> <span class="n">options</span><span class="o">:</span><span class="mi">0</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="n">NSTextCheckingResult</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">regex</span> <span class="n">firstMatchInString</span><span class="o">:</span><span class="n">selectorName</span> <span class="n">options</span><span class="o">:</span><span class="mi">0</span> <span class="n">range</span><span class="o">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">selectorName</span><span class="p">.</span><span class="n">length</span><span class="p">)];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NSRange</span> <span class="n">propertyNameRange</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span> <span class="n">rangeAtIndex</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">NSString</span> <span class="o">*</span><span class="n">propertyName</span> <span class="o">=</span> <span class="p">[</span><span class="n">selectorName</span> <span class="n">substringWithRange</span><span class="o">:</span><span class="n">propertyNameRange</span><span class="p">];</span>

        <span class="kt">IMP</span> <span class="n">implementation</span>  <span class="o">=</span> <span class="n">imp_implementationWithBlock</span><span class="p">((</span><span class="kt">id</span><span class="p">)</span> <span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">self</span><span class="p">,</span> <span class="kt">id</span> <span class="n">arg1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">findWhere</span><span class="o">:</span><span class="n">propertyName</span> <span class="n">equals</span><span class="o">:</span><span class="n">arg1</span><span class="p">];</span>
        <span class="p">});</span>

        <span class="kt">Class</span> <span class="n">metaClass</span> <span class="o">=</span> <span class="n">object_getClass</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

        <span class="n">class_addMethod</span><span class="p">(</span><span class="n">metaClass</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">implementation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quot</span><span class="p">;@@</span><span class="o">:</span><span class="p">@@</span><span class="o">&amp;</span><span class="n">quot</span><span class="p">;);</span>
        <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="n">resolveClassMethod</span><span class="o">:</span><span class="n">sel</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<p>这个方法的优点就是我们不需要去重写<code>respondsToSelector:</code>，因为每个在类中注册过的selector都会去调用这个方法。现在让我们调用<code>[RGSong findWhereTitleEquals:@“Mercy”]</code>。当<code>findWhereTitleEquals:</code>第一次被调用的时候，runtime并不知道这个方法，所以它会调用<code>resolveClassMethod:</code>，这时我们就将<code>findWhereTitleEquals:</code>这个方法动态添加进去，当第二次调用<code>findWhereTitleEquals:</code>的时候，因为它已经被添加过了，所以就不会再调用<code>resolveClassMethod:</code>了。</p>

<p>这里还有一些别的方法来实现捕捉动态方法。你可以通过重写<code>resolveClassMethod:</code> 和 <code>resolveInstanceMethod:</code>方法（就像上面的一样），可以将消息传递给不同的对象或全权接管这个“调用”，并在消息传递之前，做你想这个消息要完成的任何事。这些方法都会导致运行成本的增加，特别在<code>-forwardInvocation:</code>中会达到顶峰，在这种情况下我们必须要实例化一个对象才能去执行它们。<code>-forwardInvocation:</code>方法中默认调用<code>doesNotRecognizeSelector</code>方法，这导致了应用的频繁异常或崩溃。</p>

<hr>

<p><a id='introspection' name='introspection'> </a></p>

<h2>内省</h2>

<p>动态方法决议并不只是像Ruby和Objective-C这样的语言的技术支持。你也可以通过在runtime中用一种有意思的方式去操作这些对象。</p>

<p>就像在Ruby中调用<code>MyClass#instance_methods</code>一样，你可以在Objective-C中调用<code>class_copyMethodList([MyClass class], &amp;amp;numberOfMethods)</code>来得到一个对象中方法的列表。你还可以通过<code>class_copyPropertyList</code>方法得到一个类中property的列表，它能在你的模型中实现不可思议的内省。比如在这个<code>Rap Genius</code>应用中，我们用这个功能来将JSON中的字典映射到本地对象上。</p>

<p>（如果你非常喜欢Ruby中的mixin，那么Objective-C强大的动态支持也能能实现同样的效果。 Vladimir Mitrovic有一个叫<code>Objective-Mixin</code>的库，它能在runtime时将一个类中的实现复制到另一个类中。）</p>

<hr>

<p><a id='cashing_in' name='cashing_in'> </a></p>

<h2>现学现用</h2>

<p>所有的动态工具都可以用来创建像Core Data这样的东西，Core Data是一个有点像ActiveRecord的持久化对象图。在Core Data中，relationship是“有缺陷的”，也就是说他们只有在被别的对象访问时，才会被加载。每个property的accessor和mutator在runtime中都被重写（使用的就是我们上面提到的动态方法决议）。如果我们访问了一个还没有被加载的对象时，框架就会从持久性储存中动态加载这个对象并将它返回。它保持了内存的低利用率，避免了在任何一个物体被获取时，实体对象图表都要被加载到内存中这样情况的发生。</p>

<p>当Core Data实体中的mutator被调用时，系统会将那个对象标记为需要清理，不需要去重写每个property的getter和setter。</p>

<p>这就是元程序，羡慕吧！</p>

<hr>

<p><a id='what_is_comepielur' name='what_is_comepielur'> </a></p>

<h2>什么是编译器？</h2>

<p>很明显，Objective-C和Ruby并不是同一种语言，目前为止最大的不同就是Objective-C是一种编译型语言。</p>

<p>这就是这些技术中最需要注意的地方。在编译时，编译器会先确定你应用使用的每个selector是不是都在应用中。如果你处理的这个对象有类型信息，那么编译器也会检查确保这个selector在头文件有声明过，这样做就是为了防止在对象中调用未声明的selector。有些方法可以绕过这些讨厌的限制，包括关闭相关的编译警告。这里就是实践元程序化的Objective-C最好的练习。</p>

<p>你可以通过将selector的类型储存为不知道的类型或<code>id</code>来从对象中删除这些类型信息。因为编译器不认识这个类型，所以它只能假设你的程序可以接受发给它的任何消息（假设这些消息在应用中的其他地方被声明了，并且相关的编译标识已经打开）。</p>

<p>善意的忠告：如果我们关掉编译器标识和把对象保存成<code>id</code>类型，那么将会非常危险的事！其实Objective-C中最好的东西之一就是编译器（是的，比元程序还要好）。类型检查保证了我们更快的写和重构代码，也是我们在编程时少犯错误。因为没有人会关掉那些警告，所以你很难去分享你那些<code>id</code>类型的代码。大部分Objective-C开发者还是更愿意使用更强的类型而不是元程序。</p>

<p>事实证明Objective-C更受束缚--但因为编译器能提高更多的安全性和速度，所以我们只能选择这样并承担后果。</p>

<p>事实再次告诉我们，这些语言都是差不多的，Ruby开发者应该享受Objective-C，即使那些中括号让我们望而却步。</p>

</section>
<section class="meta">

<br/>
<br/>
<span>
	<a  href="http://morisunshine.com/2014/03/06/experience_of_develop/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a  href="http://morisunshine.com/2014/03/24/live_in_the_moment/" class="pageNav"  >Next</a>
</span>
<hr>
<span class="author">
  <a href="http://morisunshine.github.com">morisunshine</a>
</span>
<span class="time">
  /
  <time datetime="2014-03-13">2014-03-13</time>
</span>
<br />
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="/categories/#ios" title="ios">ios</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="/tags/#iOS" title="iOS">iOS</a>&nbsp;
  
  <a href="/tags/#ruby" title="ruby">ruby</a>&nbsp;
  
</span>

</section>
<!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"morisunshne"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = 'http://static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- Duoshuo Comment END -->


        </article>
      </div>

    <footer>
        <p><small>Powered by <a href="https://github.com/mojombo/jekyll">Jekyll</a> & <a href="http://pages.github.com">GitHub</a> | Copyright 2012 - 2014 by <a href="/about/">morisunshine</a> | <span class="label label-info" id="timeSpan"></span></small></p>
    </footer>

    </div>

    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;
        i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();
      a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];
      a.async=1;
      a.src=g;
      m.parentNode.insertBefore(a,m)}
      )
      (window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-47868064-1', 'morisunshine.com');
      ga('send', 'pageview');

    </script>

    <!-- Baidu Button BEGIN -->
		<script type="text/javascript" id="bdshare_js" data="type=slide&amp;img=4&amp;pos=right&amp;uid=541841" ></script>
		<script type="text/javascript" id="bdshell_js"></script>
		<script type="text/javascript">
		var bds_config={"bdTop":170};
		document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000);
		</script>
		<!-- Baidu Button END -->
  </body>
</html>
