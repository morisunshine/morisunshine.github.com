<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Just for fun &#8211; Morisunshine's Blog</title>
<meta name="description" content="Describe this nonsense.">


<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/abstract-1.jpg">

<meta name="twitter:title" content="Just for fun">
<meta name="twitter:description" content="Describe this nonsense.">
<meta name="twitter:creator" content="@morisunshine">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Just for fun">
<meta property="og:description" content="Describe this nonsense.">
<meta property="og:url" content="http://localhost:4000/page2/index.html">
<meta property="og:site_name" content="Morisunshine's Blog">





<link rel="canonical" href="http://localhost:4000/page2/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Morisunshine's Blog Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.min.css">
<!-- Webfonts -->
<link href="http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">



</head>

<link rel="stylesheet" href="assets/css/solarized_dark.css">
<script src="assets/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.png" alt="Sheldon photo" class="author-photo">
					<h4>Sheldon</h4>
					<p>1991-12-10</p>
				</li>
				<li><a href="http://localhost:4000/about/">Know More</a></li>
				<li>
					<a href="mailto:sheldon.zen@gmail.com"><i class="icon-envelope"></i> Email</a>
				</li>
				<li>
					<a href="http://twitter.com/morisunshine"><i class="icon-twitter"></i> Twitter</a>
				</li>
				<li>
					<a href="http://weibo.com/u/1626743220"><i class="icon-weibo"></i> weibo</a>
				</li>
				
				
				<li>
					<a href="http://linkedin.com/in/morisunshine"><i class="icon-linkedin"></i> LinkedIn</a>
				</li>
				<li>
					<a href="http://github.com/morisunshine"><i class="icon-github"></i> GitHub</a>
				</li>
				<li>
					<a href="http://stackoverflow.com/users/2194236/morisunshine"><i class="icon-stackexchange"></i> Stackexchange</a>
				</li>
				<li>
					<a href="http://instagram.com/morisunshine"><i class="icon-instagram"></i> Instagram</a>
				</li>
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/posts/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		<li><a href="http://localhost:4000/feed">Feed</a></li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  
  
    <div class="entry-image">
      <img src="http://localhost:4000/images/abstract-1.jpg" alt="Just for fun">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Morisunshine's Blog</h1>
      <h2>Just for fun</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-03-06T00:00:00+08:00"><a href="http://localhost:4000/%E5%BC%80%E5%8F%91/experience_of_develop/">March 06, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sheldon">Sheldon</a></span></span>&nbsp; &bull; &nbsp;<span class="entry-comments"><a href="http://localhost:4000/%E5%BC%80%E5%8F%91/experience_of_develop/#disqus_thread">Comment</a></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/%E5%BC%80%E5%8F%91/experience_of_develop/" rel="bookmark" title="我的开发经验漫谈" itemprop="url">我的开发经验漫谈</a></h1>
    
  </header>
  <div class="entry-content">
    <p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#begin"><strong>项目开始之前</strong></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#specification"><strong>规范</strong></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#code_specification"><strong>代码规范</strong></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#version_specification"><strong>版本控制规范</strong></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#document_specification"><strong>文档规范</strong></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#test_specification"><strong>测试规范</strong></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tidy"><strong>整理</strong></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#summary"><strong>总结</strong></a>  </p>

<p>工作快一年了，参与了一些项目，在项目有崩溃的时候，也有欣喜的时候，我觉得很有必要记录下来，其中，可能是一些理想的化的设想，因为在之前的开发过程并没有实践过，但我觉得是可以一试，并且是有帮助的。</p>

<p><a id='begin' name='begin'> </a></p>

<h2>项目开始之前</h2>

<p>很多次，我都迫不及待地想马上编写代码，我太喜欢那种写代码的感觉了。可是，越写越觉得不对劲，或者写到一半发现这个功能与需求不一样，然后改了又改，或直接重新开始写。<br>
所以，不要急，慢慢来，我们可以先用Mind Map，或者你喜欢的方式将需求分析一下，并对一些功能进行细化。<br>
有大概的了解之后，我就该去考虑每个功能的具体实现，这个功能的难点在哪里，用什么方法比较好，如果没有找到好的方法，可以用现有的方法去代替。
在上面都考虑好了，我们就该往大的方面想，用什么样的方式比较好，或许用到什么框架，设计模式比较好。<br>
也许刚开始的时候，我的经验有限，想到的方法或方式非常有限，但是一旦我开始去考虑这些问题，并且去实践的时候，我对这些方法的考虑开始往全面的方向发展，这就是在积累中成长吧。</p>

<hr>

<p><a id='specification' name='specification'> </a></p>

<h2>规范</h2>

<p>当我看过去写的代码，真的有种不想认自己的娃的冲动啊，根本不知道在写什么，命名非常幼稚，当然，现在可能也还是这样，但现在应该有一部分已经成年了吧。很多人会觉得规范是件很麻烦的事，因为规范会给限制程序员的自由，但个人觉得规范与自由并没有冲突。规范应该是团队之间的一种的约定的事情，它的目的是为了能够减少因代码问题而导致的沟通成本。</p>

<p>规范体现在那些地方呢？</p>

<p><a id='code_specification' name='code_specification'> </a></p>

<h3>代码规范</h3>

<p>我觉得每个团队之间的代码规范应该是不一样，代码规范应该是由团队中的每个成员讨论出来的结果，而不是一个人拍案决定，代码规范的目的应该是让你和每个成员都能很好的阅读，把时间专注到更需要时间的地方。<br>
哪些需要规范呢?<br>
比如在iOS项目开发中，就可以有文件名的规范，图片名的规范，类名的规范等。这些命名都需要考虑仔细，因为它不是为一个人而起的。你还要确保别人也能看懂它的作用，也许你会觉得注释就好，当然，这会是个好办法，但如果只要能看到名字就能知道它的功能，那不是更好么？</p>

<p><a id='version_specification' name='version_specification'> </a></p>

<h3>版本控制规范</h3>

<p>版本控制在开发过程中非常重要，所以版本控制的规范也是非常重要的，以git为例:</p>

<ul>
<li>创建的分支名，就应该清楚让人知道我们在这个分支里做了哪些事情。</li>
<li>commit，每一条commit都应该清楚的描述，不能马虎，这不只帮助你未来的查看，也是让开发人员了解代码演化的重要途径之一，另一方面，也不知不觉中养成细化功能的习惯，这样在以后地开发中，你就会对要开发的功能进行细分，当一个子功能开发完成，就写一个commit。(这里可以参考<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit">google开源项目的commit规范</a>)</li>
</ul>

<p><a id='document_specification' name='document_specification'> </a></p>

<h3>文档规范</h3>

<p>当开始一个项目时，应该需要一个文档，来跟踪你的项目，其中的内容应该包括，这个项目的文件结构，功能，还有一些类的功能。这些也是对代码可读性的扩展。</p>

<p>这么多规范很烦吧，程序员的自由在哪儿，但我觉得我们不只是为现在写程序，很多时候，写程序的时间只占开发整个项目的10%，而很多时间都是在测试，调试，解决bug，或者在寻找以前的代码。所以我们要为未来而写，这对于我来说也是一种自我修养吧。</p>

<p><a id='test_specification' name='test_specification'> </a></p>

<h3>测试规范</h3>

<p>测试，听上去很美好，当在我的以往项目中，这总是被遗忘的事情，或者是根本不会提起的事情，只有当问题产生，才会悔不当初，有它该多好。每次下定决心，一定要写一个测试的时候，总是懒于去行动，但励志要成为优秀工程师的我们一定不会忽略它的，所以测试的规范，也是非常重要的，它也让你知道一这段测试的功能与该有的结果，这也是对功能性的一个很好的补充，也为以后的改动带来了很多方便。</p>

<hr>

<p><a id='tidy' name='tidy'> </a></p>

<h2>整理</h2>

<p>你的项目不会是一尘不变的，他会因为时间的推移而增加更多东西，这时也许你之前的那些管理方式就变得很没有效率，想重新捣腾它，发现牵一发而动全身，真抓狂，早干嘛去了。为了避免这样的悲剧再次重演整理就变得很重要了，整理包括目录结构、资源和代码的整理，文件结构可以参考这篇<a href="http://blog.jobbole.com/61083/">博文</a>,资源和代码整理则是根据上面提到的各种规范，整理的目的应该是让项目清晰和简洁。</p>

<hr>

<p><a id='summary' name='summary'> </a></p>

<h2>总结</h2>

<p>写了这么多，其实也是对自己过去的经验的整理，也是对自己的勉励，博客的意义在于分享，而分享又是为了更好的交流，希望能提出一些宝贵的意见，让我们一起成长。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-02-27T00:00:00+08:00"><a href="http://localhost:4000/ios/UICollectionView_UIKit_Dynamics/">February 27, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sheldon">Sheldon</a></span></span>&nbsp; &bull; &nbsp;<span class="entry-comments"><a href="http://localhost:4000/ios/UICollectionView_UIKit_Dynamics/#disqus_thread">Comment</a></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/ios/UICollectionView_UIKit_Dynamics/" rel="bookmark" title="UICollectionView+UIKit Dynamics" itemprop="url">UICollectionView+UIKit Dynamics</a></h1>
    
  </header>
  <div class="entry-content">
    <p><a href="http://www.objc.io/issue-5/collection-views-and-uidynamics.html">原文</a>作者<a href="https://twitter.com/ashfurrow">Ash Furrow</a>。转载请注明出处！</p>

<p>感谢<a href="http://blog.codingcoder.com/">破土</a>参与翻译。</p>

<p>UIKit Dynamics 是iOS7中基于物理动画引擎的一个新功能--它被特别设计使其能很好地与collection Views配合工作，collection view是在iOS6中才被引入的新特性。接下来，我们要好好看看如何将这两个特性结合在一起。 </p>

<p>这篇文章将讨论两个实现UIkit Dynamics的collection view的例子。第一个例子展示了如何去实现像iOS7里Messages应用中的弹簧效果，如果你还不大了解iOS7中Messages的弹簧效果是什么样子的，下面这张gif图可以帮你大概了解下：</p>

<p><img src="http://img.onevcat.com/2013/ios7-message-app-spring.gif" alt="Example"></p>

<p>然后再进一步结合了有可伸缩效果的平铺机制。</p>

<p>第二个例子展现了如何用UIKit Dynamics来模拟牛顿摆，物体可以在某一时刻被加入到collection view，并和其他物体相互作用。</p>

<p>在我们开始之前，我假定你们对<code>UICollectionView</code>是如何工作是有基本的了解--查看<a href="http://www.objc.io/issue-3/collection-view-layouts.html">这篇objc.io博客</a>博客会有你想要的所有细节。我也假定你已经理解了<code>UIKit Dynamics</code>的工作原理--阅读这篇<a href="http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/">博客</a>，可以了解更多UIKit Dynamics的知识。</p>

<p>文章中的两个例子项目都已经在GitHub中:</p>

<ul>
<li><a href="https://github.com/objcio/issue-5-springy-collection-view">ASHSpringyCollectionView</a>(基于<a href="https://github.com/TeehanLax/UICollectionView-Spring-Demo">UICollectionView Spring Demo</a>)</li>
<li><a href="https://github.com/objcio/issue-5-newtonian-collection-view">Newtownian UICollectionView</a></li>
</ul>

<h1>Dynamic Animator</h1>

<p>支持UICollectionView实现UIkit Dynamic的最关键部分就是UIDynamicAnimator。要实现这样的UIKit Dynamics的效果，我们需要自己自定义一个继承于UICollectionViewFlowLayout的子类，并且在这个子类里面持有一个UIDynamicAnimator的对象。</p>

<p>当我们创建我们自己的dynamic animator时，我们不会使用常用的初始化方法<code>-(instancetype)initWithReferenceView:(UIView*)view;</code>
因为，我们不需要把这个dynamic animator关联一个view，而是给它关联一个collection view layout。所以我们使用<code>- (instancetype)initWithCollectionViewLayout:(UICollectionViewLayout*)layout;</code>
这个初始化方法，并把collection view layout作为参数传入。
这很关键，当他的behavior物体的属性应该被更新的时候，dynamic animator必须能够使collection view layout无效。换句话说，dynamic animator将会使旧的layout失效，并根据最新的behavior的items中的attribute重新建立新的layout。</p>

<p>我们很快就能看到这些事情是怎么连接起来的，但是在概念上理解collection view 如何与 dynamic animator相互作用是很重要的。我们将要在自定义的collection view layout的子类中，根据每一个collection view中的<code>UICollectionViewLayoutAttributes</code>对象的属性，创建一个对应的<code>UIAttachmentBehavior</code>对象，并把这个UIAttachmentBehavior对象添加到我们持有的<code>UIDynamicAnimator</code>对象上(过会儿我们将讨论tiling这些)。当我们需要<code>UICollectionViewLayoutAttribute</code>时，我们不再是从头开始计算collection view 每一个item的layout attribute，而是使用<code>UIDynamicAnimator</code>中的layout attribute，因为我们在创建UIDynamicAnimator时就已经计算过每一个item的layout attribute了，所以这里不需要再重复计算一次。一旦模拟状态发生改变，dynamic animator就会使这个layout无效。这会导致UIKit重新查询layout，直到这个模拟静止。</p>

<p>所以重申一下，layout创建了dynamic animator，并且在dynamic animator上添加每个item的layout attribute对应的<code>UIAttachmentBehavior</code>。当collection view需要layout信息时，dynamic animator提供想要的信息。</p>

<h1>继承UICollectionViewFlowLayout</h1>

<p>我们将要创建一个简单的例子来展示如何使用一个带UIkit Dynamic的collection view layout。当然，我们需要做的第一件事就是，创建一个数据源去驱动我们的collection view。我知道以你的能力完全可以独立实现一个数据源，但是为了完整性，我还是提供了一个给你:</p>

<p><div>
    <pre><code class='objc'>@implementation ASHCollectionViewController</p>

<p>static NSString * CellIdentifier = @&quot;CellIdentifier&quot;;</p>

<p>-(void)viewDidLoad 
{
    [super viewDidLoad];
    [self.collectionView registerClass:[UICollectionViewCell class] 
            forCellWithReuseIdentifier:CellIdentifier];</p>

<p>}</p>

<p>-(UIStatusBarStyle)preferredStatusBarStyle 
{
    return UIStatusBarStyleLightContent;</p>

<p>}</p>

<p>-(void)viewDidAppear:(BOOL)animated 
{
    [super viewDidAppear:animated];
    [self.collectionViewLayout invalidateLayout];</p>

<p>}</p>

<h1>pragma mark - UICollectionView Methods</h1>

<p>-(NSInteger)collectionView:(UICollectionView *)collectionView 
    numberOfItemsInSection:(NSInteger)section 
{
    return 120;</p>

<p>}</p>

<p>-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView 
                 cellForItemAtIndexPath:(NSIndexPath *)indexPath 
{
    UICollectionViewCell *cell = [collectionView 
        dequeueReusableCellWithReuseIdentifier:CellIdentifier 
                                  forIndexPath:indexPath];</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">cell.backgroundColor = [UIColor orangeColor];
return cell;
</code></pre></div>
<p>}</p>

<p>@end</code></pre>
  </div></p>

<p>我们注意到当视图第一次出现的时候，这个layout是被无效的。这是因为没有用Storybards的结果(当使用Storyboards时，调用prepareLayout方法的时机是不同的--或是相同的--在WWDC的视频中他们没有告诉我们这些)。所以，当这些试图一出现我们就需要手动使这个collection view layout无效。当我们用tiling的时候，就不需要这样。</p>

<p>让我们创建我们自己的collection view layout。我们需要强引用一个dynamic animator, 并且使用它来驱动我们的collcetion view layout的attribute。我们在实现文件里定义了一个私有的property:</p>

<p><div>
    <pre><code class='objc'>@interface ASHSpringyCollectionViewFlowLayout ()</p>

<p>@property (nonatomic, strong) UIDynamicAnimator *dynamicAnimator;</p>

<p>@end</code></pre>
  </div></p>

<p>我们将在layout的初始化方法中初始化我们的dynamic animator。还要设置一些属于父类UICollectionViewFlowLayout中的property:</p>

<p><div>
    <pre><code class='objc'>- (id)init 
{
    if (!(self = [super init])) return nil;</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">self.minimumInteritemSpacing = 10;
self.minimumLineSpacing = 10;
self.itemSize = CGSizeMake(44, 44);
self.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10);

self.dynamicAnimator = [[UIDynamicAnimator alloc] initWithCollectionViewLayout:self];

return self;
</code></pre></div>
<p>}</code></pre>
  </div></p>

<p>我们将实现的下一个方法是prepareLayout。我们首先需要调用父类的方法。因为我们是继承<code>UICollectionViewFlowLayout</code>类，所以在调用父类的prepareLayout的时，可以使collection view layout attribute都放置在合适的位置。我们可以依靠基类<code>UICollectionViewFlowLayout</code>的<code>prepareLayout</code>方法来提供一个默认的排布，并且能够使用<code>[super layoutAttributesForElementsInRect:visibleRect];</code>方法得到指定rect内的所有item的layout attributes。</p>

<p><div>
    <pre><code class='objc'>[super prepareLayout];</p>

<p>CGSize contentSize = self.collectionView.contentSize;
NSArray *items = [super layoutAttributesForElementsInRect:
    CGRectMake(0.0f, 0.0f, contentSize.width, contentSize.height)];</code></pre>
  </div></p>

<p>这真的是效率低下的代码。因为我们的collection view中可能会有成千上万个cell，一次性加载所有的cell是一个可能会产生难以置信的内存紧张的操作。我们要在一段时间内遍历所有的元素，这也成为耗时的操作。这真的是效率的双重打击！别担心--我们是负责任的开发者，所以我们会很快解决这个问题的。我们先暂时继续使用简单、粗暴的实现方式。</p>

<p>当加载完我们所有的collection view layout attribute之后，我们需要检查他们是否都已经被加载到我们的animator里了。如果一个behavior已经在animator中存在，那么我们就不能重新添加，否则就会得到一个非常难懂的运行异常提示:</p>

<p><div>
    <pre><code class='objc'>&lt;UIDynamicAnimator: 0xa5ba280&gt; (0.004987s) in 
&lt;ASHSpringyCollectionViewFlowLayout: 0xa5b9e60&gt; {{0, 0}, {0, 0}}: 
body &lt;PKPhysicsBody&gt; type:&lt;Rectangle&gt; representedObject:
[&lt;UICollectionViewLayoutAttributes: 0xa281880&gt; 
index path: (&lt;NSIndexPath: 0xa281850&gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44); ] 0xa2877c0<br>
PO:(159.999985,32.000000) AN:(0.000000) VE:(0.000000,0.000000) AV:(0.000000) 
dy:(1) cc:(0) ar:(1) rs:(0) fr:(0.200000) re:(0.200000) de:(1.054650) gr:(0) 
without representedObject for item &lt;UICollectionViewLayoutAttributes: 0xa3833e0&gt; 
index path: (&lt;NSIndexPath: 0xa382410&gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44);</code></pre>
  </div></p>

<p>如果看到了这个错误，那么这基本表明你添加了两个behavior给同一个<code>UICollectionViewLayoutAttribute</code>，这使得系统不知道该怎么处理。</p>

<p>无论如何，一旦我们已经检查好我们是否已经将behavior添加到dynamic animator之后，我们就需要遍历每个collection view layout attribute来创建和添加新的dynamic animator:</p>

<p><div>
    <pre><code class='objc'>if (self.dynamicAnimator.behaviors.count == 0) {
    [items enumerateObjectsUsingBlock:^(id&lt;UIDynamicItem&gt; obj, NSUInteger idx, BOOL *stop) {
        UIAttachmentBehavior *behaviour = [[UIAttachmentBehavior alloc] initWithItem:obj 
                                                                    attachedToAnchor:[obj center]];</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    behaviour.length = 0.0f;
    behaviour.damping = 0.8f;
    behaviour.frequency = 1.0f;

    [self.dynamicAnimator addBehavior:behaviour];

}];
</code></pre></div>
<p>}</code></pre>
  </div></p>

<p>这段代码非常简单。我们为每个item创建了一个以物体的中心为附着点的<code>UIAttachmentBehavior</code>对象。然后又设置了我们的attachment behavior的length为0以便约束这个cell能一直以behavior的附着点为中心。然后又给<code>damping</code>和<code>frequency</code>这两个参数设置一个比较合适的值。</p>

<p>这就是<code>prepareLayout</code>。我们现在需要实现<code>layoutAttributesForElementsInRect:</code> 和 <code>layoutAttributesForItemAtIndexPath:</code>这两个方法，UIKit会调用它们来询问collection view每一个item的布局信息。我们写的代码会把这些查询交给专门做这些事的dynamic animator:</p>

<p><div>
    <pre><code class='objc'>-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect 
{
    return [self.dynamicAnimator itemsInRect:rect];</p>

<p>}</p>

<p>-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath 
{
    return [self.dynamicAnimator layoutAttributesForCellAtIndexPath:indexPath];</p>

<p>}</code></pre>
  </div></p>

<h1>响应滚动事件</h1>

<p>我们目前实现的代码给我们展示的只是一个在正常滑动下只有静态感觉的<code>UICollectionView</code>运行起来没什么特别的。看上去很好，但不是真的动态，不是么？</p>

<p>为了使它表现地动态点，我们需要layout和dynamic animator能够对collection view中滑动位置的变化做出反应。幸好这里有个非常适合这个要求的方法<code>shouldInvalidateLayoutForBoundsChange:</code>。这个方法会在collection view 的bound发生改变的时候被调用，根据最新的<code>content offset</code>调整我们的dynamic animator中的behaviors的参数。在重新调整这些behavior的item之后，我们在这个方法中返回NO；因为dynamic animator会关心layout的无效问题，所以在这种情况下，它不需要去主动使其无效:</p>

<p><div>
    <pre><code class='objc'>-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds 
{
    UIScrollView *scrollView = self.collectionView;
    CGFloat delta = newBounds.origin.y - scrollView.bounds.origin.y;</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">CGPoint touchLocation = [self.collectionView.panGestureRecognizer locationInView:self.collectionView];

[self.dynamicAnimator.behaviors enumerateObjectsUsingBlock:^(UIAttachmentBehavior *springBehaviour, NSUInteger idx, BOOL *stop) {
    CGFloat yDistanceFromTouch = fabsf(touchLocation.y - springBehaviour.anchorPoint.y);
    CGFloat xDistanceFromTouch = fabsf(touchLocation.x - springBehaviour.anchorPoint.x);
    CGFloat scrollResistance = (yDistanceFromTouch + xDistanceFromTouch) / 1500.0f;

    UICollectionViewLayoutAttributes *item = springBehaviour.items.firstObject;
    CGPoint center = item.center;
if (delta &amp;lt; 0) {
        center.y += MAX(delta, delta*scrollResistance);

}
else {
        center.y += MIN(delta, delta*scrollResistance);

}
    item.center = center;

    [self.dynamicAnimator updateItemUsingCurrentState:item];

}];

return NO;
</code></pre></div>
<p>}</code></pre>
  </div></p>

<p>让我们仔细查看这个代码的细节。首先我们得到了这个scroll view(这是我们的collection view)，然后计算它的content offset中y的变化(在这个例子中，我们的collection view是垂直滑动的)。一旦我们得到这个增量，我们需要得到用户接触的位置。这是非常重要的，因为我们希望离接触位置比较近的那些物体能移动地更迅速些，而离接触位置比较远的那些物体则应该滞后些。</p>

<p>对于dynamic animator中的每个behavior，我们将接触点到该behavior物体的x和y的距离之和除以1500，1500是我根据经验设的。分母越小，这个collection view的的交互就越有弹簧的感觉。因为我们有了这种“滑动阻力”，我们根据它的增量乘上<code>scrollResistance</code>这个变量来指定这个behavior物体的中心的y。最后，我们在滑动阻力大于增量的情况下对增量和滑动阻力的结果进行了选择。 (这意味着物体开始往错误的方向移动了)。如果我们用了这么大的分母，那么这种情况是不可能的，但是在一些更具弹性的collection view layout中还是需要注意的。</p>

<p>就是这么一回事。以我的经验，这个方法对多达几百个物体的collection view来说也是是适用的。超过这个数量的话，一次性加载所有物体到内存中就会变成很大的负担，并且在滑动的时候就会开始卡顿了。</p>

<p><img src="http://f.cl.ly/items/411o450x2E3A3c3m2b3k/springyCollectionView.gif" alt="Example"></p>

<h1>Tiling your Dynamic Behaviors for Performance</h1>

<p>当你的collection view中只有几百个cell的时候，他运行的很好，但当数据源超过这个范围的时候会发生什么呢？或者在运行的时你不能预测你的数据源有多大呢？我们的简单粗暴的方法就不管用了。</p>

<p>除了在<code>prepareLayout</code>中加载所有的物体，如果我们能更聪明地知道哪些物体会加载那该多好啊。是的，就是这些显示的或即将显示的物体。这就是我们要采取的办法。</p>

<p>我们需要做的第一件事就是是跟踪dynamic animator中的所有behavior物体的index path。我在collection view 中添加一个property来做这件事:</p>

<p><div>
    <pre><code class='objc'>@property (nonatomic, strong) NSMutableSet *visibleIndexPathsSet;</code></pre>
  </div></p>

<p>我们用set是因为它具有常数复杂度的查找效率，并且我们经常地查找<code>visibleIndexPathsSet</code>中是否已经包含了某个index path。</p>

<p>在我们实现全新的<code>prepareLayout</code>方法之前--有一个问题就是什么是tiles behavior--理解tiling的意思是非常重要的。当我们title behavior的时候，我们会在这些item离开collection view 的可视范围的时候删除对应的behavior，在这些item进入可视范围的时候又添加对应的behavior。这是一个大麻烦:我们需要在滚动中创建新的behavior。这就意味着让人觉得创建它们就好像它们本来就已经在dynamic animator里了一样，并且它们是在<code>shouldInvalidateLayoutForBoundsChange:</code>方法被修改的。</p>

<p>因为我们是在滚动中创建这些新的behavior，所以我们需要维持现在collection view 的一些状态。尤其我们需要跟踪最近一次我们<code>bound</code>变化的增量。我们会在滚动时用这个状态去创建我们的behavior:</p>

<p><div>
    <pre><code class='objc'>@property (nonatomic, assign) CGFloat latestDelta;</code></pre>
  </div></p>

<p>添加完这个property后，我们将要在<code>shouldInvalidateLayoutForBoundsChange:</code>方法中添加下面这行代码:</p>

<p><div>
    <pre><code class='objc'>self.latestDelta = delta;</code></pre>
  </div></p>

<p>这就是我们需要修改我们的方法来响应滚动事件。我们的这两个方法是为了将collection view中items的layout信息传给dynamic animator，这种方式没有变化。事实上，当你的collection view实现了dynamic animator的大部分情况下，都需要实现我们上面提到的两个方法<code>layoutAttributesForElementsInRect:</code>和<code>layoutAttributesForItemAtIndexPath:</code>。</p>

<p>这里最难懂的部分就是tiling mechanism。我们将要完全重写我们的prepareLayout。</p>

<p>这个方法的第一步是将那些物体的index path已经不再屏幕上的behavior从dynamic animator上删除。第二步是添加那些即将显示的物体的behavior。</p>

<p>让我们先看一下第一步。</p>

<p>像以前一样，我们要调用<code>super prepareLayout</code>，这样我们就能依赖父类<code>UICollectionViewFlowLayout</code>提供的默认排布。还像以前一样，我们通过父类获取一个矩形内的所有元素的layout attribute。不同的是我们不是获取整个collection view 中的元素属性，而只是获取显示范围内的。</p>

<p>所以我们需要计算这个显示矩形。但是别着急！有件事要记住。我们的用户可能会非常快地滑动collection view，导致了dynamic animator不能跟上，所以我们需要稍微扩大显示范围，这样就能包含到那些将要显示的物体了。否则，在滑动很快的时候就会出现频闪现象了。让我们计算一下显示范围:</p>

<p><div>
    <pre><code class='objc'>CGRect originalRect = (CGRect){.origin = self.collectionView.bounds.origin, .size = self.collectionView.frame.size};
CGRect visibleRect = CGRectInset(originalRect, -100, -100);</code></pre>
  </div></p>

<p>我确信在实际显示矩形上的每个方向都扩大100个像素对我的demo来说是可行的。仔细查看这些值是否适合你们的collection view，尤其是当你们的cell很小的情况下。</p>

<p>接下来我们就需要收集在显示范围内的collection view layout attributes。还有它们的index paths:</p>

<p><div>
    <pre><code class='objc'>NSArray *itemsInVisibleRectArray = [super layoutAttributesForElementsInRect:visibleRect];</p>

<p>NSSet *itemsIndexPathsInVisibleRectSet = [NSSet setWithArray:[itemsInVisibleRectArray valueForKey:@&quot;indexPath&quot;]];</code></pre>
  </div></p>

<p>注意我们是在用一个NSSet。这是因为它具有常数复杂度的查找效率，并且我们经常的查找visibleIndexPathsSet是否已经包含了某个index path:</p>

<p>接下来我们要做的就是遍历dynamic animator 的behaviors，过滤掉那些已经在<code>itemsIndexPathsInVisibleRectSet</code>中的item。因为我们已经过滤掉我们的behavior，所以我们将要遍历的这些item都是不在显示范围里的，我们就可以将这些item从animator中删除掉(连同<code>visibleIndexPathsSet</code>属性中的index path):</p>

<p><div>
    <pre><code class='objc'>NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(UIAttachmentBehavior *behaviour, NSDictionary *bindings) {
    BOOL currentlyVisible = [itemsIndexPathsInVisibleRectSet member:[[[behaviour items] firstObject] indexPath]] != nil;
    return !currentlyVisible;
}]</p>

<p>NSArray *noLongerVisibleBehaviours = [self.dynamicAnimator.behaviors filteredArrayUsingPredicate:predicate];</p>

<p>[noLongerVisibleBehaviours enumerateObjectsUsingBlock:^(id obj, NSUInteger index, BOOL *stop) {
    [self.dynamicAnimator removeBehavior:obj];
    [self.visibleIndexPathsSet removeObject:[[[obj items] firstObject] indexPath]];</p>

<p>}];</code></pre>
  </div></p>

<p>下一步就是要得到新出现item的<code>UICollectionViewLayoutAttributes</code>数组--那些item的index path在<code>itemsIndexPathsInVisibleRectSet</code>而不在<code>visibleIndexPathsSet</code>:</p>

<p><div>
    <pre><code class='objc'>NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(UICollectionViewLayoutAttributes *item, NSDictionary *bindings) {
    BOOL currentlyVisible = [self.visibleIndexPathsSet member:item.indexPath] != nil;
    return !currentlyVisible;</p>

<p>}];
NSArray *newlyVisibleItems = [itemsInVisibleRectArray filteredArrayUsingPredicate:predicate];</code></pre>
  </div></p>

<p>一旦我们有新的layout attribute出现，我就可以遍历他们来创建新的behavior，并且将他们的index path添加到<code>visibleIndexPathsSet</code>中。首先，无论如何，我都需要获取到用户手指触碰的位置。如果它是<code>CGPointZero</code>的话，那就表示这个用户没有在滑动collection view，我就不需要在滚动时创建新的behavior:</p>

<p><div>
    <pre><code class='objc'>CGPoint touchLocation = [self.collectionView.panGestureRecognizer locationInView:self.collectionView];</code></pre>
  </div></p>

<p>这是一个潜在的威胁。如果用户很快地滑动了collection view 之后释放了他的手指呢？这个collection view 就会一直滚动，但是我们的方法就不会在滚动时创建新的behavior了。幸运的是，那也就意味这scroll view滚动太快很难被注意到！好哇！这可能会是个问题，但是，只是针对那些拥有大量cell的collection view。在这种情况下，增加你的显示范围的界限就可以加载更多物体了。</p>

<p>现在我们需要枚举我们刚显示的item，为他们创建behavior，再将他们的index path 添加到<code>visibleIndexPathsSet</code>。我们还需要在滚动时做些运算来创建behavior:</p>

<p><div>
    <pre><code class='objc'>[newlyVisibleItems enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes *item, NSUInteger idx, BOOL *stop) {
    CGPoint center = item.center;
    UIAttachmentBehavior *springBehaviour = [[UIAttachmentBehavior alloc] initWithItem:item attachedToAnchor:center];</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">springBehaviour.length = 0.0f;
springBehaviour.damping = 0.8f;
springBehaviour.frequency = 1.0f;

if (!CGPointEqualToPoint(CGPointZero, touchLocation)) {
    CGFloat yDistanceFromTouch = fabsf(touchLocation.y - springBehaviour.anchorPoint.y);
    CGFloat xDistanceFromTouch = fabsf(touchLocation.x - springBehaviour.anchorPoint.x);
    CGFloat scrollResistance = (yDistanceFromTouch + xDistanceFromTouch) / 1500.0f;

if (self.latestDelta &amp;lt; 0) {
        center.y += MAX(self.latestDelta, self.latestDelta*scrollResistance);

}
else {
        center.y += MIN(self.latestDelta, self.latestDelta*scrollResistance);

}
    item.center = center;

}

[self.dynamicAnimator addBehavior:springBehaviour];
[self.visibleIndexPathsSet addObject:item.indexPath];
</code></pre></div>
<p>}];</code></pre>
  </div></p>

<p>大部分代码看起来还是挺熟悉的。大概有一半是来自没有实现tiling的<code>prepareLayout</code>。另一半是来自<code>shouldInvalidateLayoutForBoundsChange</code>方法。我们用latestDelta这个property来表示<code>bound</code>变化的增量，适当地调整<code>UICollectionViewLayoutAttributes</code>使这些cell表现地就像被attachment behavior拉着一样。</p>

<p>就是这样，真的！我已经在真机上测试过显示上千个cell的情况了，它运行地非常完美。<a href="https://github.com/objcio/issue-5-springy-collection-view">去试试吧</a>。</p>

<h1>超越瀑布流布局</h1>

<p>一般来说，当我们使用<code>UICollectionView</code>的时候，继承<code>UICollectionViewFlowLayout</code>会比继承<code>UICollectionViewLayout</code>更容易。这是因为flow layout 会为我们做很多事。然而，瀑布流布局是严格基于它们的尺寸一个接一个的展现出来。如果你有一个layout不能适应这个标准怎么办？好的，如果你已经尝试用<code>UICollectionViewFlowLayout</code>来适应，而且你很确定它不能很好运行，那么就应该抛弃<code>UICollectionViewFlowLayout</code>这个定制性比较弱的子类，而应该直接在<code>UICollectionViewLayout</code>这个基类上进行定制。</p>

<p>当处理UIKit Dynamic的时候也是适用的。</p>

<p>让我们继承<code>UICollectionViewLayout</code>。当继承<code>UICollectionViewLayout</code>的时候需要实现<code>collectionViewContentSize</code>方法，这点非常重要。否则这个collection view就不知道如果去显示自己，也不会有显示任何东西。因为我们想要我们的collection view不要再滑动，我们将会返回我们的collection view的frame的尺寸，减去它的<code>contentInset.top</code>:</p>

<p><div>
    <pre><code class='objc'>-(CGSize)collectionViewContentSize 
{
    return CGSizeMake(self.collectionView.frame.size.width, 
        self.collectionView.frame.size.height - self.collectionView.contentInset.top);</p>

<p>}</code></pre>
  </div></p>

<p>在这个(有教育意义)的例子中，我们的collection view总是会以零个cell开始，物体通过<code>performBatchUpdates:</code>方法添加。这就意味着我们必须使用<code>-[UICollectionViewLayout prepareForCollectionViewUpdates:]</code>方法来添加我们的behavior(即这个collection view的数据源总是以零开始)。</p>

<p>除了给各个物体添加附着behavior外，我们还将保留另外两个behavior:重力和碰撞。对于添加在这个collection view中的每个item来说，我们必须把这些item添加到我们的碰撞和附着behavior中。最后一步就是设置这些item的初始位置为屏幕外的某些地方，这样就有被附着behavior拉入到屏幕内的效果了:</p>

<p><div>
    <pre><code class='objc'>-(void)prepareForCollectionViewUpdates:(NSArray *)updateItems
{
    [super prepareForCollectionViewUpdates:updateItems];</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">[updateItems enumerateObjectsUsingBlock:^(UICollectionViewUpdateItem *updateItem, NSUInteger idx, BOOL *stop) {
    if (updateItem.updateAction == UICollectionUpdateActionInsert) {
        UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes 
            layoutAttributesForCellWithIndexPath:updateItem.indexPathAfterUpdate];

        attributes.frame = CGRectMake(CGRectGetMaxX(self.collectionView.frame) + kItemSize, 300, kItemSize, kItemSize);

        UIAttachmentBehavior *attachmentBehaviour = [[UIAttachmentBehavior alloc] initWithItem:attributes 
                                                                              attachedToAnchor:attachmentPoint];
        attachmentBehaviour.length = 300.0f;
        attachmentBehaviour.damping = 0.4f;
        attachmentBehaviour.frequency = 1.0f;
        [self.dynamicAnimator addBehavior:attachmentBehaviour];

        [self.gravityBehaviour addItem:attributes];
        [self.collisionBehaviour addItem:attributes];

    }

}];
</code></pre></div>
<p>}</code></pre>
  </div></p>

<p><img src="http://www.objc.io/images/issue-5/newtonianCollectionView@2x.gif" alt="Example"></p>

<p>删除就有点复杂了。我们希望这些物体有&quot;掉落&quot;的效果而不是简单的消失。这就不仅仅是从collection view 中删除这个cell这么简单了，因为我们希望在它离开了屏幕之前还是保留它。我已经在代码中实现了这样的效果，但是有点坑爹。</p>

<p>基本上我们要做的是在layout中提供一个方法，在它删除attachment behavior两秒之后，将这个cell从collection view中删除。我们希望在这段时间里，这个cell能掉出屏幕，但是这不一定会发生。如果没有发生，也没关系。只要淡出就行了。然而，我们必须避免在这两秒内没有新的cell被添加，也没有旧的cell被删除。(我说过有点坑。)</p>

<p>欢迎在github上提出pull requests</p>

<p>这个方法是有些限制的。我将cell数量的上限设为10，但是即使这样，在像iPad2这样比较久的设备中，动画就会运行地很慢。然而，这个例子充分地展示你可以自己实现有意思的动力学模拟的方法--这并不意味着这是一个可以解决任何问题的万金油。你的模拟中包括性能的各个方面，都是取决于你自己。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-02-19T00:00:00+08:00"><a href="http://localhost:4000/ruby/make_your_own_gem/">February 19, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sheldon">Sheldon</a></span></span>&nbsp; &bull; &nbsp;<span class="entry-comments"><a href="http://localhost:4000/ruby/make_your_own_gem/#disqus_thread">Comment</a></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/ruby/make_your_own_gem/" rel="bookmark" title="制作自己的Gem" itemprop="url">制作自己的Gem</a></h1>
    
  </header>
  <div class="entry-content">
    <p>&nbsp;<a href="#introduce"><strong>什么是Gem？</strong></a><br>
&nbsp;<a href="#first_gem"><strong>第一个Gem</strong></a><br>
&nbsp;<a href="#include_more_files"><strong>包含更多文件</strong></a><br>
&nbsp;<a href="#adding_an_executable"><strong>添加可执行文件</strong></a><br>
&nbsp;<a href="#writing_tests"><strong>测试</strong></a><br>
&nbsp;<a href="#documenting_your_code"><strong>文档</strong></a>  </p>

<p><a id='introduce' name='introduce'> </a></p>

<h2>什么是Gem?</h2>

<p>RubyGems是一个方便而强大的Ruby程序包管理器，Ruby的第三方插件是用gem方式来管理，非常容易发布和共享，一个简单的命令就可以安装上第三方的扩展库。特点：能远程安装包，包之间依赖关系的管理，简单可靠的卸载，查询机制，能查询本地和远程服务器的包信息，能保持一个包的不同版本，基于Web的查看接口，能查看你安装的gem的信息。</p>

<hr>

<p><a id='first_gem' name='first_gem'> </a></p>

<h2>第一个Gem</h2>

<p>我们要创建一个名叫<code>moondemo</code>的gem，首先，就要创建一个名字为<code>moondemo_yourname</code>的目录，这个是为了后面的发布，如果你想发布的话，就要检查一下你的gem名字是否已经被人使用了，如果已经被人使用，那就要换个名字了。<br>
然后这个目录里的基本文件结构应该是这样的。 </p>

<p><div>
    <pre><code class='ruby'>➜  tree<br>
.<br>
├── moondemo.gemspec<br>
├── lib<br>
│   └── moondemo.rb</code></pre>
  </div></p>

<p>gem中的代码被放在<code>lib</code>目录中，这里有个约定就是<code>lib</code>中必须有个和gem同名的ruby文件，这样当<code>require &#39;moondemo&#39;</code>运行的时候，这个gem就会被加载，这个文件就是负责配置你的gem的代码和API。</p>

<p><div>
    <pre><code class='ruby'>➜  cat lib/moondemo.rb
class moondemo
  def self.hi
    puts &quot;Hello world!&quot;
  end
end</code></pre>
  </div></p>

<p>而<code>.gemspec</code>文件是定义了这个gem的信息，比如是这个gem的功能，作者等，并且当这个gem发布的时候，会将这些信息显示到这个gem的主页上(就像<a href="http://rubygems.org/gems/jekyll">jekyll</a>)。</p>

<p><div>
    <pre><code class='ruby'>➜  cat moondemo.gemspec
Gem::Specification.new do |s|
  s.name        = &#39;moondemo&#39;
  s.version     = &#39;0.0.0&#39;
  s.date        = &#39;2014-02-19&#39;
  s.summary     = &quot;moondemo!&quot;
  s.description = &quot;A simple hello world gem&quot;
  s.authors     = [&quot;sheldon huang&quot;]
  s.email       = &#39;allenwenzhou@gmail.com&#39;
  s.files       = [&quot;lib/moondemo.rb&quot;]
  s.homepage    =
    &#39;http://rubygems.org/gems/moondemo&#39;
  s.license       = &#39;MIT&#39;
end</code></pre>
  </div></p>

<p>这里有很多选项，一看名字就知道他们是要代表什么内容的，如果你还想知道更多就看一些这个<a href="http://guides.rubygems.org/specification-reference/">文档</a></p>

<p>当我们创建完成了一个.gemspec，就可以编译出一个gem了，是不是有点小激动啊。但如果想要测试它就必须要在本地安装编译好的gem。</p>

<p><div>
    <pre><code class='ruby'>➜ gem build moondemo.gemspec
  Successfully built RubyGem
  Name: moondemo
  Version: 0.0.1
  File: moondemo-0.0.1.gem</p>

<p>➜ gem install ./moondemo-0.0.1.gem
Successfully installed moondemo-0.0.1
Parsing documentation for moondemo-0.0.1
Installing ri documentation for moondemo-0.0.1
1 gem installed</code></pre>
  </div></p>

<p>上面这些步骤，只能是在本地已经装好了我们自己的gem，但还没有使用它，
我们需要<code>require</code>这个gem然后根据自己定义的方法来使用它。</p>

<p><div>
    <pre><code class='ruby'>➜ irb
2.0.0-p353 :001 &gt; require &#39;moondemo&#39;
 =&gt; true
2.0.0-p353 :002 &gt; MoonDemo.hi
Hello world!
 =&gt; nil</code></pre>
  </div></p>

<p>现在就可以将你的gem发布到Ruby社区上了，当在发布之前需要将你的帐号安装在电脑上，如果你在RubyGems.org上注册了帐号，那就只需要输入一个命令,再输入自己的密码就可以了</p>

<p><div>
    <pre><code class='ruby'>➜ curl -u 你的帐号名 https://rubygems.org/api/v1/api_key.yaml &gt; ~/.gem/credentials; chmod 0600 ~/.gem/credentials</p>

<p>Enter host password for user &#39;你的帐号名&#39;:</code></pre>
  </div></p>

<p>一旦你的用户名已经被安装了，就可以直接发布你的gem了。</p>

<p><div>
    <pre><code class='ruby'>➜ gem push moondemo-0.0.1.gem
Pushing gem to https://rubygems.org...
Successfully registered gem: moondemo (0.0.1)</code></pre>
  </div></p>

<p>很快的，你的gem就可以被任何人使用了</p>

<p><div>
    <pre><code class='ruby'>➜ gem install moondemo
Successfully installed moondemo-0.0.1
Parsing documentation for moondemo-0.0.1
1 gem installed</code></pre>
  </div></p>

<p>用Ruby和RubyGems来分享代码是不是很简单。</p>

<hr>

<p><a id='include_more_files' name='include_more_files'> </a></p>

<h2>包含更多文件</h2>

<p>我们以后代码当然不会这么简单，如果代码变得非常多了之后，该怎么办呢，当然是要是要将代码分到不同的文件中了。<br>
比如我们想在刚才的gem中添加根据不同语言来输出不同语言的&quot;Hello world&quot;。<br>
我们就可以添加一个<code>Translator</code>文件，刚才提到过，gem的根文件是负责加载代码的，所以其他的功能的文件就需要放在<code>lib</code>中和gem同名的目录中，我们可以这样分:</p>

<p><div>
    <pre><code class='bash'>➜ tree
.
├── lib
│   ├── moondemo
│   │   └── translator.rb
│   └── moondemo.rb
├── moondemo-0.0.1.gem</code></pre>
  </div></p>

<p><code>Translator</code>中的内容是:</p>

<p><div>
    <pre><code class='ruby'>class Translator
  def initialize(language)
    @language = language
  end</p>

<p>def hi
    case @language
      when &quot;chinese&quot;
        &quot;你好，世界!&quot;
      else
        &quot;Hello world!&quot;
      end
  end
end</code></pre>
  </div></p>

<p>所以接下来，<code>moondemo.rb</code>中需要加载<code>Translator</code>:</p>

<p><div>
    <pre><code class='ruby'>class MoonDemo
  def self.hi(language = &quot;english&quot;)
    translator = Translator.new(language)
    translator.hi
  end
end</code></pre>
  </div></p>

<p><em>注意:每次新建了一个目录或者文件，都不要忘记加到.gemspec文件中，就像这样</em></p>

<p><div>
    <pre><code class='ruby'>s.authors     = [&quot;Sheldon&quot;]
 s.email       = &#39;allenwenzhou@gmial.com&#39;
 s.files       = [&quot;lib/moondemo.rb&quot;,&quot;lib/moondemo/translator.rb&quot;]</code></pre>
  </div></p>

<p><em>如果没有上面的修改的话，这个新建的目录是不会被加载到已安装的gem里的</em></p>

<p>让我们再运行一篇</p>

<p><div>
    <pre><code class='ruby'>➜ irb -Ilib -rmoondemo
2.0.0-p353 :001 &gt; MoonDemo.hi(&quot;english&quot;)
 =&gt; &quot;Hello world!&quot;
2.0.0-p353 :002 &gt; MoonDemo.hi(&quot;chinese&quot;)
 =&gt; &quot;你好，世界!&quot;</code></pre>
  </div></p>

<p>这里我们使用了一个新的命令行<code>-Ilib</code>,通常RubyGems会为你包含了<code>lib</code>路径，所以很多时候，我们不需要去考虑配置它们的加载路径，但是，如果你把代码运行在RubyGems的项目之外，你就要自己去配置这些了。</p>

<p>如果你添加了一些新的文件到你的gem中，那么你一定要记住在发布之前将这些文件添加到你的<code>.gemspec</code>的<code>files</code>数组中。这样很麻烦是么，所以很多人就选择用<a href="http://docs.seattlerb.org/hoe/">Hoe</a>,<a href="https://github.com/technicalpickles/jeweler">Jeweler</a>,<a href="http://rake.rubyforge.org/classes/Rake/GemPackageTask.html">Rake</a>,<a href="http://railscasts.com/episodes/245-new-gem-with-bundler">Bundler</a>或者用<a href="https://github.com/wycats/newgem-template/blob/master/newgem.gemspec">动态的gemspec</a>来实现自动化。</p>

<p>添加更多的目录也都是按照上面一样的步骤，我们要将我们的文件结构分布合理，这样对于我们以后的维护和未来开发人员来说就不会是一件头疼的事儿了。</p>

<p><a id='adding_an_executable' name='adding_an_executable'> </a></p>

<h2>添加可执行文件</h2>

<p>gem除了可以提供Ruby代码库外，还可以在你的可执行文件路径里提供很多可执行可执行文件文件。可能最有名的就是<code>rake</code>，
添加一个可执行可执行可执行文件文件其实很简单，你只需要将你的可执行文件放在你的gem的<code>bin</code>目录下，然后在将这个文件添加到<code>.gemspec</code>文件中<code>executables</code>的列表里就可以了，让我们试一下:</p>

<p><div>
    <pre><code class='bash'>➜  mkdir bin
➜  touch bin/moondemo
➜  chmod a+x bin/moondemo</code></pre>
  </div></p>

<p>这个可执行文件只需要在开头用<a href="http://www.catb.org/jargon/html/S/shebang.html">shebang</a>来表明这是用程序来运行的，下面就是这个可执行文件的内容:</p>

<p><div>
    <pre><code class='ruby'>#!/usr/bin/env ruby</p>

<p>require &#39;moondemo&#39;
puts MoonDemo.hi(ARGV[0])</code></pre>
  </div></p>

<p>这个可执行文件的内容很简单，它只是加载了moondemo这个gem，然后在命令行中通过输入一个参数来判断是用哪个国家的语言来说&quot;hello, world&quot;。下面就是运行的例子:</p>

<p><div>
    <pre><code class='bash'>➜  ruby -Ilib ./bin/moondemo
Hello world!
➜  ruby -Ilib ./bin/moondemo chinese
你好，世界!</code></pre>
  </div></p>

<p>最后，我们要将这个可执行文件添加到<code>.gemspec</code></p>

<p><div>
    <pre><code class='ruby'>s.executables &lt;&lt; &#39;moondemo&#39;</code></pre>
  </div></p>

<p>更新你的gem，上传到官网上，这样你就可以在命令行中有自己的命令了，是不是很帅啊。这里要提醒一下，上传新的gem时，要记得修改<code>.gemspec</code>中的版本号。详情看<a href="http://guides.rubygems.org/patterns/#semantic-versioning">这儿</a></p>

<p>在看一下用我们自己定义的命令行吧:</p>

<p><div>
    <pre><code class='bash'>➜  ~  moondemo
Hello world!
➜  ~  moondemo chinese
你好，世界!</code></pre>
  </div></p>

<p>世界在向我们招手呢。哈哈哈~~~</p>

<p><a id='writing_tests' name='writing_tests'> </a></p>

<h1>测试</h1>

<p>测试我们的gem是非常重要的，它不仅保证了这个gem是正常的，也保证了别人能知道你的gem是正常的。当我们评价一个gem的时候，很多Ruby开发者会倾向于通过查看测试用例来做为主要依据。</p>

<p>Gems是支持将测试文件添加到程序包中的，所以当gem被下载了之后，我们可以直接运行测试用例。这里有个帮助我们如何在不同框架和解释器下写测试用例的社区叫<a href="http://test.rubygems.org/">GemTesters</a>
总而言之:去测试我们的Gem吧！啥都别想了！</p>

<p><code>Test::Unit</code>是Ruby的自带测试框架。这里有很多<a href="https://github.com/seattlerb/minitest/blob/master/README.txt">教程</a>，当然还是有很多其他的测试框架，<a href="http://rspec.info/">RSpec</a>就是比较有名的一个，是不是迫不及待，让我们测试吧！</p>

<p>我们需要在原来的基础上再添加一些文件，一个名为<code>Rakefile</code>的文件和一个名为<code>test</code>的目录:</p>

<p><div>
    <pre><code class='bash'>.
├── Rakefile
├── bin
│   └── moondemo
├── lib
│   ├── moondemo
│   │   └── translator.rb
│   └── moondemo.rb
├── moondemo-0.0.1.gem
├── moondemo.gemspec
├── npm-debug.log
└── test
    └── test_moondemo.rb</code></pre>
  </div></p>

<p><code>Rakefile</code>文件是为了实现自动化的测试:</p>

<p><div>
    <pre><code class='ruby'>require &#39;rake/testtask&#39;</p>

<p>Rake::TestTask.new do |t|
        t.libs &lt;&lt; &#39;test&#39;
end</p>

<p>desc &quot;Run tests&quot;
task :default =&gt; :test
~</code></pre>
  </div></p>

<p>下面就是一个简单的测试用例了:</p>

<p><div>
    <pre><code class='ruby'>require &#39;test/unit&#39;
require &#39;moondemo&#39;</p>

<p>class MoonDemoTest &lt; Test::Unit::TestCase
  def test<em>english</em>hello
    assert_equal &quot;Hello world!&quot;,
      MoonDemo.hi(&quot;english&quot;)
  end</p>

<p>def test<em>any</em>hello
    assert_equal &quot;Hello world!&quot;,
      MoonDemo.hi(&quot;ruby&quot;)
  end</p>

<p>def test<em>spanish</em>hello
    assert_equal &quot;你好，世界!&quot;,
      MoonDemo.hi(&quot;chinese&quot;)
  end
end</code></pre>
  </div></p>

<p>最后，让我们运行这个测试:</p>

<p><div>
    <pre><code class='bash'>➜  rake test
Run options:</p>

<h1>Running tests:</h1>

<p>Finished tests in 0.006151s, 487.7256 tests/s, 487.7256 assertions/s.
3 tests, 3 assertions, 0 failures, 0 errors, 0 skips</code></pre>
  </div></p>

<p>很好，全部都通过了！</p>

<p><a id='documenting_your_code' name='documenting_your_code'> </a></p>

<h1>文档</h1>

<p>文档和测试是一样重要的，大部分gem都是用RDoc来生成文档的，这里有很多<a href="http://docs.seattlerb.org/rdoc/RDoc/Markup.html">教程</a>.
很简单，先切换到gem的根目录下，再命令行中输入<code>rdoc</code>，你就会发现多出了一个名为<code>doc</code>的目录，里面就是我们的文档了，当然你可以自己再进行一些调整。
除了RDoc呢，我们还有另外的选择<a href="http://yardoc.org/">YARD</a>，当我们发布了gem的时候呢，<a href="http://rubydoc.info/">RubyDoc.info</a>会根据你的gem自动生成YARDocs，并且它是可以向下兼容RDoc。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-02-15T00:00:00+08:00"><a href="http://localhost:4000/%E6%8A%98%E8%85%BE/my_first_blog/">February 15, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sheldon">Sheldon</a></span></span>&nbsp; &bull; &nbsp;<span class="entry-comments"><a href="http://localhost:4000/%E6%8A%98%E8%85%BE/my_first_blog/#disqus_thread">Comment</a></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/%E6%8A%98%E8%85%BE/my_first_blog/" rel="bookmark" title="第一篇博客" itemprop="url">第一篇博客</a></h1>
    
  </header>
  <div class="entry-content">
    <p>果然生命在于折腾啊，折腾完之后，就会发现之前觉得挺难的事其实也没什么大不了，比如弄这个博客，以前对技术牛人的评判标准就是有个自己域名的博客，崇拜之情如黄河泛滥不可收拾，当自己有勇气去搭建一个的时侯，发现原来这么简单，只要买个域名就可以了，当然那些有些博客是很牛的，但对我来说，这样简单的博客就是我想要的，而内容才是博客最重要的地方。</p>

<p>至于我会在博客里写什么？在这个问题上，没有很明确的限制，希望它是我成长的记事本，无论是生活的哪个方面。我相信人的一生是一个漫长积累的过程，我希望能在这里见证这个过程。也可以理解为娱乐自己。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2013-07-14T00:00:00+08:00"><a href="http://localhost:4000/ios/iOS_Decorator/">July 14, 2013</a></time></span><span class="author vcard"><span class="fn"><a href="http://localhost:4000/about/" title="About Sheldon">Sheldon</a></span></span>&nbsp; &bull; &nbsp;<span class="entry-comments"><a href="http://localhost:4000/ios/iOS_Decorator/#disqus_thread">Comment</a></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://localhost:4000/ios/iOS_Decorator/" rel="bookmark" title="iOS设计模式学习---装饰模式" itemprop="url">iOS设计模式学习---装饰模式</a></h1>
    
  </header>
  <div class="entry-content">
    <h2>定义</h2>

<p>装饰模式（Decorator），动态地为一个对象添加额外的职责，是继承的替代方案，属于结构型模式。通过装饰模式扩展对象的功能比继承子类方式更灵活，使用继承子类的方式，是在编译时静态决定的，即编译时绑定，而且所有的子类都会继承相同的行为。然而，如果使用组合的方式扩展对象的行为，就可以在运行时动态地进行扩展，将来如果需要也可以动态的撤销，而不会影响原类的行为。<br>
<img src="/images/2013-7-14.jpg" alt="图片">  </p>

<h2>实例</h2>

<p>接下来，通过Object-C来实践一下，我设想一个场景，用Decorator模式来实现一下对某个手机的GPS和蓝牙功能扩展
首先，我们需要一个手机的接口或者抽象类，我这里就用抽象类来实现，代码如下：</p>

<p><div>
    <pre><code class='objc'>@interface AbstractCellPhone : NSObject
- (NSString *)callNumber;
- (NSString *)sendMessage;
@end</code></pre>
  </div></p>

<p><div>
    <pre><code class='objc'>#import &quot;AbstractCellPhone.h&quot;</p>

<p>@implementation AbstractCellPhone</p>

<ul>
<li><p>(NSString *)callNumber
{
return @&quot;phone call somebody&quot;;
}</p></li>
<li><p>(NSString *)sendMessage
{
return @&quot;phone send a message to somebody&quot;;
}
@end</code></pre>
</div></p></li>
</ul>

<p>AbstractCellPhone也就是结构图中的Component，然后，我再来实现Nokia和Moto的手机类，这类要继承AbstractCellPhone，也就是图中ConcreteComponent类要继承Component，实现代码如下：</p>

<p><div>
    <pre><code class='objc'>#import &quot;AbstractCellPhone.h&quot;<br>
@interface NokiaPhone : AbstractCellPhone
@end</code></pre>
  </div></p>

<p><div>
    <pre><code class='objc'>#import &quot;NokiaPhone.h&quot;</p>

<p>@implementation NokiaPhone</p>

<ul>
<li><p>(NSString *)callNumber
{
return @&quot;NokiaPhone call somebody&quot;;
}</p></li>
<li><p>(NSString *)sendMessage
{
return @&quot;NokiaPhone send Message to Somebody&quot;;
}</p></li>
</ul>

<p>@end</code></pre>
  </div></p>

<p>接下来我需要一个Decorator接口或者抽象类，实现代码如下：</p>

<p><div>
    <pre><code class='objc'>#import &quot;AbstractCellPhone.h&quot;</p>

<p>@interface Decorator : AbstractCellPhone
{
@protected AbstractCellPhone <em>abstractCellPhone;
}
-(void)SetComponents:(Components</em>)component;
@end</code></pre>
  </div></p>

<p><div>
    <pre><code class='objc'>#import &quot;Decorator.h&quot;</p>

<p>@implementation Decorator
-(void)SetComponents:(Components*)component{
    components = component;
}</p>

<ul>
<li><p>(NSString *)callNumber
{
return components.callNumber;
}</p></li>
<li><p>(NSString *)sendMessage
{
return components.sendMessage;
}
@end</code></pre>
</div></p></li>
</ul>

<p>正如结构图中，这个Decorator即继承了AbstractCellPhone，又包含了一个私有的AbstractCellPhone的对象。这样做的意义是：Decorator类又使用了另外一个Component类。我们可以使用一个或多个Decorator对象来“装饰”一个Component对象，且装饰后的对象仍然是一个Component对象。在下来，我要实现GSP和蓝牙的功能扩展，它们要继承自Decorator，代码如下：</p>

<p><div>
    <pre><code class='objc'>#import &quot;Decorator.h&quot;</p>

<p>@interface DecoratorGPS : Decorator</p>

<p>@end</code></pre>
  </div></p>

<p><div>
    <pre><code class='objc'>#import &quot;DecoratorGPS.h&quot;</p>

<p>@implementation DecoratorGPS</p>

<ul>
<li><p>(NSString *)callNumber
{
return [NSString stringWithFormat:@&quot;%@ with GPS&quot;, [super callNumber]];
}</p></li>
<li><p>(NSString *)sendMessage
{
return [NSString stringWithFormat:@&quot;%@ with GPS&quot;, [super sendMessage]];
}</p></li>
</ul>

<p>@end</code></pre>
  </div></p>

<p>最后，用客户端程序验证一下：</p>

<p><div>
    <pre><code class='objc'>int main(int argc, const char *argv[])
{
    @autoreleasepool {</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    Components *phone = [[ConcreteComponent alloc] init];
    NSLog(@&amp;quot;%@&amp;quot;,phone.callNumber);
    NSLog(@&amp;quot;%@&amp;quot;,phone.sendMessage);
    ConcreteDecoratorA *GPS = [[ConcreteDecoratorA alloc] init];
    [GPS SetComponents:phone];
    NSLog(@&amp;quot;%@&amp;quot;,GPS.callNumber);
    NSLog(@&amp;quot;%@&amp;quot;,GPS.sendMessage);
    ConcreteDecoratorB *bluetooth = [[ConcreteDecoratorB alloc] init];
    [bluetooth SetComponents:phone];
    NSLog(@&amp;quot;%@&amp;quot;,bluetooth.callNumber);
    NSLog(@&amp;quot;%@&amp;quot;,bluetooth.sendMessage);
}
return 0;
</code></pre></div>
<p>}</code></pre>
  </div></p>

<p>执行结果：</p>

<p><div>
    <pre><code class='objc'>NokiaPhone call somebody
 NokiaPhone send Message to Somebody
 NokiaPhone call somebody with GPS
 NokiaPhone send Message to Somebody with GPS
 NokiaPhone call somebody with BlueTooth
 NokiaPhone send Message to Somebody with BlueTooth</code></pre>
  </div></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    
      <a href="http://localhost:4000" class="btn">Previous</a>
    
  
  <ul class="inline-list">
    <li>
      
        <a href="http://localhost:4000">1</a>
      
    </li>
    
      <li>
        
          <span class="current-page">2</span>
        
      </li>
    
      <li>
        
          <a href="http://localhost:4000/page3">3</a>
        
      </li>
    
  </ul>
  
    <a href="http://localhost:4000/page3" class="btn">Next</a>
  
</div><!-- /.pagination -->
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2014 Sheldon. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl = 
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-47868064-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
          

</body>
</html>