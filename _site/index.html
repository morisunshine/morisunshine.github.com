<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Latest Posts &#8211; Morisunshine's Blog</title>
<meta name="description" content="Describe this nonsense.">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://morisunshine.com/images/abstract-1.jpg">

<meta name="twitter:title" content="Latest Posts">
<meta name="twitter:description" content="Describe this nonsense.">
<meta name="twitter:creator" content="@morisunshine">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Latest Posts">
<meta property="og:description" content="Describe this nonsense.">
<meta property="og:url" content="http://morisunshine.com/index.html">
<meta property="og:site_name" content="Morisunshine's Blog">





<link rel="canonical" href="http://morisunshine.com/">
<link href="http://morisunshine.com/feed.xml" type="application/atom+xml" rel="alternate" title="Morisunshine's Blog Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://morisunshine.com/assets/css/main.min.css">
<!-- Webfonts -->
<link href="http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://morisunshine.com/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://morisunshine.com/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://morisunshine.com/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://morisunshine.com/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://morisunshine.com/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://morisunshine.com/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://morisunshine.com/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://morisunshine.com">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://morisunshine.com/images/avatar.png" alt="Sheldon photo" class="author-photo">
					<h4>Sheldon</h4>
					<p>1991-12-10</p>
				</li>
				<li><a href="http://morisunshine.com/about/">Learn More</a></li>
				<li>
					<a href="mailto:sheldon.zen@gmail.com"><i class="icon-envelope"></i> Email</a>
				</li>
				<li>
					<a href="http://twitter.com/morisunshine"><i class="icon-twitter"></i> Twitter</a>
				</li>
				
				
				<li>
					<a href="http://linkedin.com/in/morisunshine"><i class="icon-linkedin"></i> LinkedIn</a>
				</li>
				<li>
					<a href="http://github.com/morisunshine"><i class="icon-github"></i> GitHub</a>
				</li>
				<li>
					<a href="http://stackoverflow.com/users/2194236/morisunshine"><i class="icon-stackexchange"></i> Stackexchange</a>
				</li>
				<li>
					<a href="http://instagram.com/morisunshine"><i class="icon-instagram"></i> Instagram</a>
				</li>
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://morisunshine.com/posts/">All Posts</a></li>
				<li><a href="http://morisunshine.com/tags/">All Tags</a></li>
			</ul>
		</li>
		<li><a href="http://morisunshine.com"></a></li><li><a href=""></a></li>
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/">dargadgetz</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="http://morisunshine.com/images/abstract-1.jpg" alt="Latest Posts">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Morisunshine's Blog</h1>
      <h2>Latest Posts</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-03-24T00:00:00+08:00"><a href="http://morisunshine.com/%E7%94%9F%E6%B4%BB/live_in_the_moment/">March 24, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://morisunshine.com/about/" title="About Sheldon">Sheldon</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://morisunshine.com/%E7%94%9F%E6%B4%BB/live_in_the_moment/" rel="bookmark" title="我的时间观---活在当下" itemprop="url">我的时间观---活在当下</a></h1>
    
  </header>
  <div class="entry-content">
    <p><img src="/images/p2014_3_24.jpg" alt="图片" /></p>

<p>经常有这样的困惑，觉得每天的时间都不够用，对未来做了很多计划，但最终总是证明“计划赶不上变化”，所以那些计划就这样被积压，或者被遗弃，感觉时间真是吝啬。但当自己拥有足够的时间时，却拖延症作祟，什么都不想动，只想坐在那里，什么都不想，让自己放空，但这时内心却是无比挣扎，很想打败拖延症，可是内心总有个懒散的声音在说“好不容易放个假，应该好好休息一下，看什么书啊，多累啊”，好吧，大多数时候总是信了他的话。</p>

<p>后来开始上班，在公司里面接触到了<a href="http://zh.wikipedia.org/wiki/GTD">GTD</a>，也就是一种时间管理方法，它通过将任务记录下来，然后进行整理，再进行检查的方式，来实现集中精力完成正在做的事情。怎么样？听起来很美好吧，这简直就是我的梦想，如果能达到这样的效果，人生该多么美好啊，把每件事情在短时间里做好，你就可以有很多时间去做自己想做的事了。但人生哪有那么容易呢，这里还是回到那个问题—我是拖延症。该怎么让一个拖延症去有效率的做事情呢，还要每天去计划，每天去整理，每天去打勾啊，真是想的太美了。</p>

<p>忘记告诉你了，我喜欢禅学，所以会经常看一些佛学书，在很多书中都提到一句话—“活在当下”，当我第一次看到这句话时，只是轻轻翻过去了，因为实在是太普通的一句话了，但是当这么多本书都在提到时，我觉得我应该好好思考了。“活在当下”是什么呢？其实和GTD的主要目的是一致的，就是专心做好当下这一刻的事。可是禅中的涵义就更深刻多了，我不仅是要做好现在要做的事，还要注重当下的感觉，就像我们总是会去纠结那些自己现在不想做的，却又应该做的事情，这些都是我们对未来未知的不确定。“活在当下”就告诉我们“不要急，先做好现在的事”。为什么这么强调现在？因为现在是过去的未来，是未来的过去，而我们又无法改变过去，而只能通过现在才能改变未来，所以现在才是最重要的。就像佛说“当下是我们唯一拥有的一刻，在当下这一刻快乐地生活，是可以办到的事”。</p>

<p>对于我来说GTD是一个方法，它开始时会给你一些条条框框，你要这样，你要那样，有点让我手足无措，内心无法自由，但当很多人在用了很长时间之后，都可以游刃有余。</p>

<p>所以给自己一点自由，别让自己活在自己营造的压力下，偶尔的拖延症都是可以理解的，我们都不是完美的人，所以当我们没有达到我们想要的程度时，不用着急，给自己一点时间，慢慢积累，努力练习。我一直相信人生是一场慢热积累的过程。所以现在没有成为你想要的样子，也许是你的积分不够吧。</p>


  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-03-13T00:00:00+08:00"><a href="http://morisunshine.com/ios/objc_is_not_what_you_think_it_is/">March 13, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://morisunshine.com/about/" title="About Sheldon">Sheldon</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://morisunshine.com/ios/objc_is_not_what_you_think_it_is/" rel="bookmark" title="Objective-C 不是你想的那样" itemprop="url">Objective-C 不是你想的那样</a></h1>
    
  </header>
  <div class="entry-content">
    <p>本文由<a href="http://morisunshine.com/">morisunshine</a>译自<a href="http://news.rapgenius.com/Soroush-khanlou-objective-c-isnt-what-you-think-it-is-if-you-think-like-a-rubyist-annotated">“Objective-C isn’t what you think it is”</a>。转载请注明出处！</p>

<hr />

<p> <a href="#message_in_a_bottle"><strong>消息的传递</strong></a>     <br />
 <a href="#getting_metaer_and_metaer"><strong>变得越来越动态</strong></a><br />
 <a href="#introspection"><strong>内省</strong></a><br />
 <a href="#cashing_in"><strong>现学现用</strong></a><br />
 <a href="#what_is_comepielur"><strong>什么是编译器？</strong></a>  </p>

<p>Ruby 和 Objective-C 这两种语言看上去好像天南地北：一种是动态语言，另一种则是静态语言；一种是解释型语言，另一种是编译型语言；一种有简洁的语法，另一种则是有点冗长的语法。从优雅的角度来看，Ruby似乎更能给我们一种自由的编程体验，所以很多人都放弃了Objective-C。</p>

<p>但这是一个不幸的笑话。Objective-C其实并不像别人认为的那样是件紧身衣，它和Ruby一样都受Smalltalk影响，它拥有很多Ruby开发者都喜爱的语言功能–动态方法查找、鸭子类型、开放的类和通常情况下高度可变的runtime等这些功能在Objective-C中同样存在，即使那些不出名的技术也是一样。Objective-C的这些功能都要归功于它的IDE和编译器，但也是因为它们才使你不能自由地编写代码</p>

<p>但是等一下，怎么能说Objective-C是动态语言呢？难道它不是建立在C语言的基础上？</p>

<p>你可以在Objective-C代码中包含任何C或C++的代码，但这不意味着Objective-C仅限于C或C++代码。Objective-C中所有有意思的类操作和对象内省都是来自于一个叫Objective-C Runtime的东西。这个Objective-C Runtime可以和Ruby解释器相媲美。它包含了强大的元编程里所需要的所有重要特性。</p>

<p>其实C语言和Ruby一样是支持这些特性的，用<code>property_getAttributes</code>或<code>method_getImplementation</code>方法就能将selector对应到具体实现(一个selector处理一个方法)，并判断这个对象能否对这个selector做出反应，再遍历子类树。在Objective-C的众多方法中，最重要的就是<code>objc_msgSend</code>方法，是它推动了应用中的每次消息发送。</p>

<hr />

<p><a id="message_in_a_bottle" name="message_in_a_bottle"> </a></p>

<h2 id="section">消息的传递</h2>

<p>Smalltalk才是实至名归的第一种面向对象语言，它用“从一个对象发送信息给另一个对象”的新概念取代了“调用函数”的旧概念，对后面的语言发展产生了深远的影响。</p>

<p>你可以在Ruby中通过这样写来实现消息的发送：</p>

<pre><code class="language-ruby">
receiver.the_message argument

</code></pre>

<p>Objective-C的实现方式和Ruby的差不多：</p>

<pre><code class="language-objc">
[receiver theMessage:argument];

</code></pre>

<p>这些消息实现了鸭子类型的方式，也就是说关注的不是这个对象的类型或类本身，而是这个对象能否对一个消息做出反应。</p>

<p>发送消息真的是非常棒的事，但是只有当消息在传送数据时，它的价值才会被发挥地更大：</p>

<pre><code class="language-ruby">
receiver.send(:the_message, argument)

</code></pre>
<p>和</p>

<pre><code class="language-objc">
[receiver performSelector:@selector(theMessage:) 
withObject:argument];

</code></pre>

<p>正如Ruby中方法需要symbol支持一样，Objective-C中selector也需要string来支持。（在Objective-C中没有symbol。）这样就可以让你通过动态的方式使用一个方法。你甚至可以通过<code>NSSelectorFromString</code>方法来使用string创建一个selector，并在一个对象里执行它。同样的，我们可以在Ruby中也可以创建一个string或symbol，并把传给<code>Object#send</code>方法。</p>

<p>当然，无论是哪种语言，一旦你将一个消息发送给不能处理该消息的对象，那么默认情况下就会抛出一个异常，还会导致应用的崩溃。</p>

<p>当你想在调用一个方法前判断一下这个对象是否能够执行这个方法，你可以用Ruby中的<code>respond_to？</code>方法来检查：</p>

<pre><code class="language-ruby">
if receiver.respond_to? :the_message
  receiver.the_message argument
end

</code></pre>

<p>Objective-C中也有差不多的方法：</p>

<pre><code class="language-objc">
if ([receiver respondsToSelector:@selector(theMessage:)]) {
    [receiver theMessage:someThing];
}

</code></pre>

<hr />

<p><a id="getting_metaer_and_metaer" name="getting_metaer_and_metaer"> </a></p>

<h2 id="section-1">变得越来越动态</h2>

<p>如果你想在一个不能修改的类（像系统类）中添加你想要的方法，那么Objective-C里的category一定不会让你失望 – 很像Ruby中的“开放类”。</p>

<p>举个例子，如果你想将Rails中的<code>to_sentence</code>方法添加到<code>NSArray</code>类中，我们只需要对<code>NSArray</code>这个类进行扩展就好了：</p>

<pre><code class="language-objc">
@interface NSArray (ToSentence)

- (NSString *)toSentence;

@end


@implementation NSArray (ToSentence)

- (NSString *)toSentence {
    if (self.count == 0) return @&amp;quot;&amp;quot;;
    if (self.count == 1) return [self lastObject];
    NSArray *allButLastObject = [self subarrayWithRange:NSMakeRange(0, self.count-1)];
    NSString *result = [allButLastObject componentsJoinedByString:@&amp;quot;, &amp;quot;];
    BOOL showComma = self.count &amp;gt; 2;
    result = [result stringByAppendingFormat:@&amp;quot;%@ and &amp;quot;, showComma ? @&amp;quot;,&amp;quot; : @&amp;quot;&amp;quot;];
    result = [result stringByAppendingString:[self lastObject]];
    return result;
}

@end

</code></pre>

<p>Category是在编译的时候将方法添加到程序中 – 让我们在runtime中动态捕捉它们怎么样？</p>

<p>有些消息可以嵌套数据，就像Rails的dynamic finders。Ruby通过对<code>method_missing</code> 和 <code>respond_to</code>这两个方法的重写，先匹配模式，再将新方法的定义添加到这个对象中。</p>

<p>Objective-C中的流程是差不多，但我们不是重写<code>doesNotRecognizeSelector:</code>方法（相当于Ruby中的<code>method_missing</code>方法），而是在<code>resolveClassMethod:</code>方法中捕捉Category添加的方法。假设我们有一个叫<code>+findWhere:equals:</code>的类方法，它可以得到property的名称和值，那么通过正则表达式就可以很容易实现找到property的名字，并通过block来注册这个selector。</p>

<pre><code class="language-objc">
+ (BOOL)resolveClassMethod:(SEL)sel {
    NSString *selectorName = NSStringFromSelector(sel);

    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@&amp;quot;^findWhere(\\w+)Equals:$&amp;quot; options:0 error:nil];
    NSTextCheckingResult *result = [regex firstMatchInString:selectorName options:0 range:NSMakeRange(0, selectorName.length)];
    if (result) {
        NSRange propertyNameRange = [result rangeAtIndex:1];
        NSString *propertyName = [selectorName substringWithRange:propertyNameRange];

        IMP implementation  = imp_implementationWithBlock((id) ^(id self, id arg1) {
            return [self findWhere:propertyName equals:arg1];
        });

        Class metaClass = object_getClass(self);

        class_addMethod(metaClass, sel, implementation, &amp;quot;@@:@@&amp;quot;);
        return YES;
    }

    return [super resolveClassMethod:sel];
}

</code></pre>

<p>这个方法的优点就是我们不需要去重写<code>respondsToSelector:</code>，因为每个在类中注册过的selector都会去调用这个方法。现在让我们调用<code>[RGSong findWhereTitleEquals:@“Mercy”]</code>。当<code>findWhereTitleEquals:</code>第一次被调用的时候，runtime并不知道这个方法，所以它会调用<code>resolveClassMethod:</code>，这时我们就将<code>findWhereTitleEquals:</code>这个方法动态添加进去，当第二次调用<code>findWhereTitleEquals:</code>的时候，因为它已经被添加过了，所以就不会再调用<code>resolveClassMethod:</code>了。</p>

<p>这里还有一些别的方法来实现捕捉动态方法。你可以通过重写<code>resolveClassMethod:</code> 和 <code>resolveInstanceMethod:</code>方法（就像上面的一样），可以将消息传递给不同的对象或全权接管这个“调用”，并在消息传递之前，做你想这个消息要完成的任何事。这些方法都会导致运行成本的增加，特别在<code>-forwardInvocation:</code>中会达到顶峰，在这种情况下我们必须要实例化一个对象才能去执行它们。<code>-forwardInvocation:</code>方法中默认调用<code>doesNotRecognizeSelector</code>方法，这导致了应用的频繁异常或崩溃。</p>

<hr />

<p><a id="introspection" name="introspection"> </a></p>

<h2 id="section-2">内省</h2>

<p>动态方法决议并不只是像Ruby和Objective-C这样的语言的技术支持。你也可以通过在runtime中用一种有意思的方式去操作这些对象。</p>

<p>就像在Ruby中调用<code>MyClass#instance_methods</code>一样，你可以在Objective-C中调用<code>class_copyMethodList([MyClass class], &amp;amp;numberOfMethods)</code>来得到一个对象中方法的列表。你还可以通过<code>class_copyPropertyList</code>方法得到一个类中property的列表，它能在你的模型中实现不可思议的内省。比如在这个<code>Rap Genius</code>应用中，我们用这个功能来将JSON中的字典映射到本地对象上。</p>

<p>（如果你非常喜欢Ruby中的mixin，那么Objective-C强大的动态支持也能能实现同样的效果。 Vladimir Mitrovic有一个叫<code>Objective-Mixin</code>的库，它能在runtime时将一个类中的实现复制到另一个类中。）</p>

<hr />

<p><a id="cashing_in" name="cashing_in"> </a></p>

<h2 id="section-3">现学现用</h2>

<p>所有的动态工具都可以用来创建像Core Data这样的东西，Core Data是一个有点像ActiveRecord的持久化对象图。在Core Data中，relationship是“有缺陷的”，也就是说他们只有在被别的对象访问时，才会被加载。每个property的accessor和mutator在runtime中都被重写（使用的就是我们上面提到的动态方法决议）。如果我们访问了一个还没有被加载的对象时，框架就会从持久性储存中动态加载这个对象并将它返回。它保持了内存的低利用率，避免了在任何一个物体被获取时，实体对象图表都要被加载到内存中这样情况的发生。</p>

<p>当Core Data实体中的mutator被调用时，系统会将那个对象标记为需要清理，不需要去重写每个property的getter和setter。</p>

<p>这就是元程序，羡慕吧！</p>

<hr />

<p><a id="what_is_comepielur" name="what_is_comepielur"> </a></p>

<h2 id="section-4">什么是编译器？</h2>

<p>很明显，Objective-C和Ruby并不是同一种语言，目前为止最大的不同就是Objective-C是一种编译型语言。</p>

<p>这就是这些技术中最需要注意的地方。在编译时，编译器会先确定你应用使用的每个selector是不是都在应用中。如果你处理的这个对象有类型信息，那么编译器也会检查确保这个selector在头文件有声明过，这样做就是为了防止在对象中调用未声明的selector。有些方法可以绕过这些讨厌的限制，包括关闭相关的编译警告。这里就是实践元程序化的Objective-C最好的练习。</p>

<p>你可以通过将selector的类型储存为不知道的类型或<code>id</code>来从对象中删除这些类型信息。因为编译器不认识这个类型，所以它只能假设你的程序可以接受发给它的任何消息（假设这些消息在应用中的其他地方被声明了，并且相关的编译标识已经打开）。</p>

<p>善意的忠告：如果我们关掉编译器标识和把对象保存成<code>id</code>类型，那么将会非常危险的事！其实Objective-C中最好的东西之一就是编译器（是的，比元程序还要好）。类型检查保证了我们更快的写和重构代码，也是我们在编程时少犯错误。因为没有人会关掉那些警告，所以你很难去分享你那些<code>id</code>类型的代码。大部分Objective-C开发者还是更愿意使用更强的类型而不是元程序。</p>

<p>事实证明Objective-C更受束缚–但因为编译器能提高更多的安全性和速度，所以我们只能选择这样并承担后果。</p>

<p>事实再次告诉我们，这些语言都是差不多的，Ruby开发者应该享受Objective-C，即使那些中括号让我们望而却步。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-03-06T00:00:00+08:00"><a href="http://morisunshine.com/%E5%BC%80%E5%8F%91/experience_of_develop/">March 06, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://morisunshine.com/about/" title="About Sheldon">Sheldon</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://morisunshine.com/%E5%BC%80%E5%8F%91/experience_of_develop/" rel="bookmark" title="我的开发经验漫谈" itemprop="url">我的开发经验漫谈</a></h1>
    
  </header>
  <div class="entry-content">
    <p>    <a href="#begin"><strong>项目开始之前</strong></a>     <br />
    <a href="#specification"><strong>规范</strong></a><br />
     <a href="#code_specification"><strong>代码规范</strong></a><br />
     <a href="#version_specification"><strong>版本控制规范</strong></a><br />
     <a href="#document_specification"><strong>文档规范</strong></a><br />
     <a href="#test_specification"><strong>测试规范</strong></a><br />
    <a href="#tidy"><strong>整理</strong></a><br />
    <a href="#summary"><strong>总结</strong></a>  </p>

<p>工作快一年了，参与了一些项目，在项目有崩溃的时候，也有欣喜的时候，我觉得很有必要记录下来，其中，可能是一些理想的化的设想，因为在之前的开发过程并没有实践过，但我觉得是可以一试，并且是有帮助的。</p>

<p><a id="begin" name="begin"> </a></p>

<h2 id="section">项目开始之前</h2>

<p>很多次，我都迫不及待地想马上编写代码，我太喜欢那种写代码的感觉了。可是，越写越觉得不对劲，或者写到一半发现这个功能与需求不一样，然后改了又改，或直接重新开始写。<br />
所以，不要急，慢慢来，我们可以先用Mind Map，或者你喜欢的方式将需求分析一下，并对一些功能进行细化。    <br />
有大概的了解之后，我就该去考虑每个功能的具体实现，这个功能的难点在哪里，用什么方法比较好，如果没有找到好的方法，可以用现有的方法去代替。
在上面都考虑好了，我们就该往大的方面想，用什么样的方式比较好，或许用到什么框架，设计模式比较好。 <br />
也许刚开始的时候，我的经验有限，想到的方法或方式非常有限，但是一旦我开始去考虑这些问题，并且去实践的时候，我对这些方法的考虑开始往全面的方向发展，这就是在积累中成长吧。</p>

<hr />

<p><a id="specification" name="specification"> </a></p>

<h2 id="section-1">规范</h2>

<p>当我看过去写的代码，真的有种不想认自己的娃的冲动啊，根本不知道在写什么，命名非常幼稚，当然，现在可能也还是这样，但现在应该有一部分已经成年了吧。很多人会觉得规范是件很麻烦的事，因为规范会给限制程序员的自由，但个人觉得规范与自由并没有冲突。规范应该是团队之间的一种的约定的事情，它的目的是为了能够减少因代码问题而导致的沟通成本。</p>

<p>规范体现在那些地方呢？</p>

<p><a id="code_specification" name="code_specification"> </a></p>

<h3 id="section-2">代码规范</h3>

<p>我觉得每个团队之间的代码规范应该是不一样，代码规范应该是由团队中的每个成员讨论出来的结果，而不是一个人拍案决定，代码规范的目的应该是让你和每个成员都能很好的阅读，把时间专注到更需要时间的地方。 <br />
哪些需要规范呢?<br />
比如在iOS项目开发中，就可以有文件名的规范，图片名的规范，类名的规范等。这些命名都需要考虑仔细，因为它不是为一个人而起的。你还要确保别人也能看懂它的作用，也许你会觉得注释就好，当然，这会是个好办法，但如果只要能看到名字就能知道它的功能，那不是更好么？</p>

<p><a id="version_specification" name="version_specification"> </a></p>

<h3 id="section-3">版本控制规范</h3>

<p>版本控制在开发过程中非常重要，所以版本控制的规范也是非常重要的，以git为例:</p>

<ul>
  <li>创建的分支名，就应该清楚让人知道我们在这个分支里做了哪些事情。</li>
  <li>commit，每一条commit都应该清楚的描述，不能马虎，这不只帮助你未来的查看，也是让开发人员了解代码演化的重要途径之一，另一方面，也不知不觉中养成细化功能的习惯，这样在以后地开发中，你就会对要开发的功能进行细分，当一个子功能开发完成，就写一个commit。(这里可以参考<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit">google开源项目的commit规范</a>)</li>
</ul>

<p><a id="document_specification" name="document_specification"> </a></p>

<h3 id="section-4">文档规范</h3>

<p>当开始一个项目时，应该需要一个文档，来跟踪你的项目，其中的内容应该包括，这个项目的文件结构，功能，还有一些类的功能。这些也是对代码可读性的扩展。</p>

<p>这么多规范很烦吧，程序员的自由在哪儿，但我觉得我们不只是为现在写程序，很多时候，写程序的时间只占开发整个项目的10%，而很多时间都是在测试，调试，解决bug，或者在寻找以前的代码。所以我们要为未来而写，这对于我来说也是一种自我修养吧。</p>

<p><a id="test_specification" name="test_specification"> </a></p>

<h3 id="section-5">测试规范</h3>

<p>测试，听上去很美好，当在我的以往项目中，这总是被遗忘的事情，或者是根本不会提起的事情，只有当问题产生，才会悔不当初，有它该多好。每次下定决心，一定要写一个测试的时候，总是懒于去行动，但励志要成为优秀工程师的我们一定不会忽略它的，所以测试的规范，也是非常重要的，它也让你知道一这段测试的功能与该有的结果，这也是对功能性的一个很好的补充，也为以后的改动带来了很多方便。</p>

<hr />
<p><a id="tidy" name="tidy"> </a></p>

<h2 id="section-6">整理</h2>

<p>你的项目不会是一尘不变的，他会因为时间的推移而增加更多东西，这时也许你之前的那些管理方式就变得很没有效率，想重新捣腾它，发现牵一发而动全身，真抓狂，早干嘛去了。为了避免这样的悲剧再次重演整理就变得很重要了，整理包括目录结构、资源和代码的整理，文件结构可以参考这篇<a href="http://blog.jobbole.com/61083/">博文</a>,资源和代码整理则是根据上面提到的各种规范，整理的目的应该是让项目清晰和简洁。</p>

<hr />
<p><a id="summary" name="summary"> </a></p>

<h2 id="section-7">总结</h2>

<p>写了这么多，其实也是对自己过去的经验的整理，也是对自己的勉励，博客的意义在于分享，而分享又是为了更好的交流，希望能提出一些宝贵的意见，让我们一起成长。</p>


  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-02-27T00:00:00+08:00"><a href="http://morisunshine.com/ios/UICollectionView_UIKit_Dynamics/">February 27, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://morisunshine.com/about/" title="About Sheldon">Sheldon</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://morisunshine.com/ios/UICollectionView_UIKit_Dynamics/" rel="bookmark" title="UICollectionView+UIKit Dynamics" itemprop="url">UICollectionView+UIKit Dynamics</a></h1>
    
  </header>
  <div class="entry-content">
    <p><a href="http://www.objc.io/issue-5/collection-views-and-uidynamics.html">原文</a>作者<a href="https://twitter.com/ashfurrow">Ash Furrow</a>。转载请注明出处！</p>

<p>感谢<a href="http://blog.codingcoder.com/">破土</a>参与翻译。</p>

<p>UIKit Dynamics 是iOS7中基于物理动画引擎的一个新功能–它被特别设计使其能很好地与collection Views配合工作，collection view是在iOS6中才被引入的新特性。接下来，我们要好好看看如何将这两个特性结合在一起。 </p>

<p>这篇文章将讨论两个实现UIkit Dynamics的collection view的例子。第一个例子展示了如何去实现像iOS7里Messages应用中的弹簧效果，如果你还不大了解iOS7中Messages的弹簧效果是什么样子的，下面这张gif图可以帮你大概了解下：</p>

<p><img src="http://img.onevcat.com/2013/ios7-message-app-spring.gif" alt="Example" /></p>

<p>然后再进一步结合了有可伸缩效果的平铺机制。</p>

<p>第二个例子展现了如何用UIKit Dynamics来模拟牛顿摆，物体可以在某一时刻被加入到collection view，并和其他物体相互作用。</p>

<p>在我们开始之前，我假定你们对<code>UICollectionView</code>是如何工作是有基本的了解–查看<a href="http://www.objc.io/issue-3/collection-view-layouts.html">这篇objc.io博客</a>博客会有你想要的所有细节。我也假定你已经理解了<code>UIKit Dynamics</code>的工作原理–阅读这篇<a href="http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/">博客</a>，可以了解更多UIKit Dynamics的知识。</p>

<p>文章中的两个例子项目都已经在GitHub中:</p>

<ul>
  <li><a href="https://github.com/objcio/issue-5-springy-collection-view">ASHSpringyCollectionView</a>(基于<a href="https://github.com/TeehanLax/UICollectionView-Spring-Demo">UICollectionView Spring Demo</a>)</li>
  <li><a href="https://github.com/objcio/issue-5-newtonian-collection-view">Newtownian UICollectionView</a></li>
</ul>

<h1 id="dynamic-animator">Dynamic Animator</h1>

<p>支持UICollectionView实现UIkit Dynamic的最关键部分就是UIDynamicAnimator。要实现这样的UIKit Dynamics的效果，我们需要自己自定义一个继承于UICollectionViewFlowLayout的子类，并且在这个子类里面持有一个UIDynamicAnimator的对象。</p>

<p>当我们创建我们自己的dynamic animator时，我们不会使用常用的初始化方法<code>-(instancetype)initWithReferenceView:(UIView*)view;</code>
因为，我们不需要把这个dynamic animator关联一个view，而是给它关联一个collection view layout。所以我们使用<code>- (instancetype)initWithCollectionViewLayout:(UICollectionViewLayout*)layout;</code>
这个初始化方法，并把collection view layout作为参数传入。
这很关键，当他的behavior物体的属性应该被更新的时候，dynamic animator必须能够使collection view layout无效。换句话说，dynamic animator将会使旧的layout失效，并根据最新的behavior的items中的attribute重新建立新的layout。</p>

<p>我们很快就能看到这些事情是怎么连接起来的，但是在概念上理解collection view 如何与 dynamic animator相互作用是很重要的。我们将要在自定义的collection view layout的子类中，根据每一个collection view中的<code>UICollectionViewLayoutAttributes</code>对象的属性，创建一个对应的<code>UIAttachmentBehavior</code>对象，并把这个UIAttachmentBehavior对象添加到我们持有的<code>UIDynamicAnimator</code>对象上(过会儿我们将讨论tiling这些)。当我们需要<code>UICollectionViewLayoutAttribute</code>时，我们不再是从头开始计算collection view 每一个item的layout attribute，而是使用<code>UIDynamicAnimator</code>中的layout attribute，因为我们在创建UIDynamicAnimator时就已经计算过每一个item的layout attribute了，所以这里不需要再重复计算一次。一旦模拟状态发生改变，dynamic animator就会使这个layout无效。这会导致UIKit重新查询layout，直到这个模拟静止。</p>

<p>所以重申一下，layout创建了dynamic animator，并且在dynamic animator上添加每个item的layout attribute对应的<code>UIAttachmentBehavior</code>。当collection view需要layout信息时，dynamic animator提供想要的信息。</p>

<h1 id="uicollectionviewflowlayout">继承UICollectionViewFlowLayout</h1>

<p>我们将要创建一个简单的例子来展示如何使用一个带UIkit Dynamic的collection view layout。当然，我们需要做的第一件事就是，创建一个数据源去驱动我们的collection view。我知道以你的能力完全可以独立实现一个数据源，但是为了完整性，我还是提供了一个给你:</p>

<pre><code class="language-objc">
@implementation ASHCollectionViewController

static NSString * CellIdentifier = @"CellIdentifier";

-(void)viewDidLoad 
{
    [super viewDidLoad];
    [self.collectionView registerClass:[UICollectionViewCell class] 
            forCellWithReuseIdentifier:CellIdentifier];

}

-(UIStatusBarStyle)preferredStatusBarStyle 
{
    return UIStatusBarStyleLightContent;

}

-(void)viewDidAppear:(BOOL)animated 
{
    [super viewDidAppear:animated];
    [self.collectionViewLayout invalidateLayout];

}

#pragma mark - UICollectionView Methods

-(NSInteger)collectionView:(UICollectionView *)collectionView 
    numberOfItemsInSection:(NSInteger)section 
{
    return 120;

}

-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView 
                 cellForItemAtIndexPath:(NSIndexPath *)indexPath 
{
    UICollectionViewCell *cell = [collectionView 
        dequeueReusableCellWithReuseIdentifier:CellIdentifier 
                                  forIndexPath:indexPath];
    
    cell.backgroundColor = [UIColor orangeColor];
    return cell;

}

@end

</code></pre>

<p>我们注意到当视图第一次出现的时候，这个layout是被无效的。这是因为没有用Storybards的结果(当使用Storyboards时，调用prepareLayout方法的时机是不同的–或是相同的–在WWDC的视频中他们没有告诉我们这些)。所以，当这些试图一出现我们就需要手动使这个collection view layout无效。当我们用tiling的时候，就不需要这样。</p>

<p>让我们创建我们自己的collection view layout。我们需要强引用一个dynamic animator, 并且使用它来驱动我们的collcetion view layout的attribute。我们在实现文件里定义了一个私有的property:</p>

<pre><code class="language-objc">
@interface ASHSpringyCollectionViewFlowLayout ()

@property (nonatomic, strong) UIDynamicAnimator *dynamicAnimator;

@end

</code></pre>

<p>我们将在layout的初始化方法中初始化我们的dynamic animator。还要设置一些属于父类UICollectionViewFlowLayout中的property:</p>

<pre><code class="language-objc">
- (id)init 
{
    if (!(self = [super init])) return nil;
    
    self.minimumInteritemSpacing = 10;
    self.minimumLineSpacing = 10;
    self.itemSize = CGSizeMake(44, 44);
    self.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10);
    
    self.dynamicAnimator = [[UIDynamicAnimator alloc] initWithCollectionViewLayout:self];
    
    return self;

}

</code></pre>

<p>我们将实现的下一个方法是prepareLayout。我们首先需要调用父类的方法。因为我们是继承<code>UICollectionViewFlowLayout</code>类，所以在调用父类的prepareLayout的时，可以使collection view layout attribute都放置在合适的位置。我们可以依靠基类<code>UICollectionViewFlowLayout</code>的<code>prepareLayout</code>方法来提供一个默认的排布，并且能够使用<code>[super layoutAttributesForElementsInRect:visibleRect];</code>方法得到指定rect内的所有item的layout attributes。</p>

<pre><code class="language-objc">
[super prepareLayout];

CGSize contentSize = self.collectionView.contentSize;
NSArray *items = [super layoutAttributesForElementsInRect:
    CGRectMake(0.0f, 0.0f, contentSize.width, contentSize.height)];

</code></pre>

<p>这真的是效率低下的代码。因为我们的collection view中可能会有成千上万个cell，一次性加载所有的cell是一个可能会产生难以置信的内存紧张的操作。我们要在一段时间内遍历所有的元素，这也成为耗时的操作。这真的是效率的双重打击！别担心–我们是负责任的开发者，所以我们会很快解决这个问题的。我们先暂时继续使用简单、粗暴的实现方式。</p>

<p>当加载完我们所有的collection view layout attribute之后，我们需要检查他们是否都已经被加载到我们的animator里了。如果一个behavior已经在animator中存在，那么我们就不能重新添加，否则就会得到一个非常难懂的运行异常提示:</p>

<pre><code class="language-objc">
&lt;UIDynamicAnimator: 0xa5ba280&gt; (0.004987s) in 
&lt;ASHSpringyCollectionViewFlowLayout: 0xa5b9e60&gt; \{\{0, 0}, \{0, 0\}\}: 
body &lt;PKPhysicsBody&gt; type:&lt;Rectangle&gt; representedObject:
[&lt;UICollectionViewLayoutAttributes: 0xa281880&gt; 
index path: (&lt;NSIndexPath: 0xa281850&gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44); ] 0xa2877c0  
PO:(159.999985,32.000000) AN:(0.000000) VE:(0.000000,0.000000) AV:(0.000000) 
dy:(1) cc:(0) ar:(1) rs:(0) fr:(0.200000) re:(0.200000) de:(1.054650) gr:(0) 
without representedObject for item &lt;UICollectionViewLayoutAttributes: 0xa3833e0&gt; 
index path: (&lt;NSIndexPath: 0xa382410&gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44);

</code></pre>

<p>如果看到了这个错误，那么这基本表明你添加了两个behavior给同一个<code>UICollectionViewLayoutAttribute</code>，这使得系统不知道该怎么处理。</p>

<p>无论如何，一旦我们已经检查好我们是否已经将behavior添加到dynamic animator之后，我们就需要遍历每个collection view layout attribute来创建和添加新的dynamic animator:</p>

<pre><code class="language-objc">
if (self.dynamicAnimator.behaviors.count == 0) {
	[items enumerateObjectsUsingBlock:^(id&lt;UIDynamicItem&gt; obj, NSUInteger idx, BOOL *stop) {
        UIAttachmentBehavior *behaviour = [[UIAttachmentBehavior alloc] initWithItem:obj 
                                                                    attachedToAnchor:[obj center]];
        
        behaviour.length = 0.0f;
        behaviour.damping = 0.8f;
        behaviour.frequency = 1.0f;
        
        [self.dynamicAnimator addBehavior:behaviour];
    
	}];

}

</code></pre>

<p>这段代码非常简单。我们为每个item创建了一个以物体的中心为附着点的<code>UIAttachmentBehavior</code>对象。然后又设置了我们的attachment behavior的length为0以便约束这个cell能一直以behavior的附着点为中心。然后又给<code>damping</code>和<code>frequency</code>这两个参数设置一个比较合适的值。</p>

<p>这就是<code>prepareLayout</code>。我们现在需要实现<code>layoutAttributesForElementsInRect:</code> 和 <code>layoutAttributesForItemAtIndexPath:</code>这两个方法，UIKit会调用它们来询问collection view每一个item的布局信息。我们写的代码会把这些查询交给专门做这些事的dynamic animator:</p>

<pre><code class="language-objc">
-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect 
{
    return [self.dynamicAnimator itemsInRect:rect];

}

-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath 
{
    return [self.dynamicAnimator layoutAttributesForCellAtIndexPath:indexPath];

}

</code></pre>

<h1 id="section">响应滚动事件</h1>

<p>我们目前实现的代码给我们展示的只是一个在正常滑动下只有静态感觉的<code>UICollectionView</code>运行起来没什么特别的。看上去很好，但不是真的动态，不是么？</p>

<p>为了使它表现地动态点，我们需要layout和dynamic animator能够对collection view中滑动位置的变化做出反应。幸好这里有个非常适合这个要求的方法<code>shouldInvalidateLayoutForBoundsChange:</code>。这个方法会在collection view 的bound发生改变的时候被调用，根据最新的<code>content offset</code>调整我们的dynamic animator中的behaviors的参数。在重新调整这些behavior的item之后，我们在这个方法中返回NO；因为dynamic animator会关心layout的无效问题，所以在这种情况下，它不需要去主动使其无效:</p>

<pre><code class="language-objc">
-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds 
{
    UIScrollView *scrollView = self.collectionView;
    CGFloat delta = newBounds.origin.y - scrollView.bounds.origin.y;
    
    CGPoint touchLocation = [self.collectionView.panGestureRecognizer locationInView:self.collectionView];
    
    [self.dynamicAnimator.behaviors enumerateObjectsUsingBlock:^(UIAttachmentBehavior *springBehaviour, NSUInteger idx, BOOL *stop) {
        CGFloat yDistanceFromTouch = fabsf(touchLocation.y - springBehaviour.anchorPoint.y);
        CGFloat xDistanceFromTouch = fabsf(touchLocation.x - springBehaviour.anchorPoint.x);
        CGFloat scrollResistance = (yDistanceFromTouch + xDistanceFromTouch) / 1500.0f;
        
        UICollectionViewLayoutAttributes *item = springBehaviour.items.firstObject;
        CGPoint center = item.center;
	if (delta &lt; 0) {
            center.y += MAX(delta, delta*scrollResistance);
        
	}
	else {
            center.y += MIN(delta, delta*scrollResistance);
        
	}
        item.center = center;
        
        [self.dynamicAnimator updateItemUsingCurrentState:item];
    
    }];
    
    return NO;

}

</code></pre>

<p>让我们仔细查看这个代码的细节。首先我们得到了这个scroll view(这是我们的collection view)，然后计算它的content offset中y的变化(在这个例子中，我们的collection view是垂直滑动的)。一旦我们得到这个增量，我们需要得到用户接触的位置。这是非常重要的，因为我们希望离接触位置比较近的那些物体能移动地更迅速些，而离接触位置比较远的那些物体则应该滞后些。</p>

<p>对于dynamic animator中的每个behavior，我们将接触点到该behavior物体的x和y的距离之和除以1500，1500是我根据经验设的。分母越小，这个collection view的的交互就越有弹簧的感觉。因为我们有了这种“滑动阻力”，我们根据它的增量乘上<code>scrollResistance</code>这个变量来指定这个behavior物体的中心的y。最后，我们在滑动阻力大于增量的情况下对增量和滑动阻力的结果进行了选择。 (这意味着物体开始往错误的方向移动了)。如果我们用了这么大的分母，那么这种情况是不可能的，但是在一些更具弹性的collection view layout中还是需要注意的。</p>

<p>就是这么一回事。以我的经验，这个方法对多达几百个物体的collection view来说也是是适用的。超过这个数量的话，一次性加载所有物体到内存中就会变成很大的负担，并且在滑动的时候就会开始卡顿了。</p>

<p><img src="http://f.cl.ly/items/411o450x2E3A3c3m2b3k/springyCollectionView.gif" alt="Example" /></p>

<h1 id="tiling-your-dynamic-behaviors-for-performance">Tiling your Dynamic Behaviors for Performance</h1>

<p>当你的collection view中只有几百个cell的时候，他运行的很好，但当数据源超过这个范围的时候会发生什么呢？或者在运行的时你不能预测你的数据源有多大呢？我们的简单粗暴的方法就不管用了。</p>

<p>除了在<code>prepareLayout</code>中加载所有的物体，如果我们能更聪明地知道哪些物体会加载那该多好啊。是的，就是这些显示的或即将显示的物体。这就是我们要采取的办法。</p>

<p>我们需要做的第一件事就是是跟踪dynamic animator中的所有behavior物体的index path。我在collection view 中添加一个property来做这件事:</p>

<pre><code class="language-objc">
@property (nonatomic, strong) NSMutableSet *visibleIndexPathsSet;

</code></pre>

<p>我们用set是因为它具有常数复杂度的查找效率，并且我们经常地查找<code>visibleIndexPathsSet</code>中是否已经包含了某个index path。</p>

<p>在我们实现全新的<code>prepareLayout</code>方法之前–有一个问题就是什么是tiles behavior–理解tiling的意思是非常重要的。当我们title behavior的时候，我们会在这些item离开collection view 的可视范围的时候删除对应的behavior，在这些item进入可视范围的时候又添加对应的behavior。这是一个大麻烦:我们需要在滚动中创建新的behavior。这就意味着让人觉得创建它们就好像它们本来就已经在dynamic animator里了一样，并且它们是在<code>shouldInvalidateLayoutForBoundsChange:</code>方法被修改的。</p>

<p>因为我们是在滚动中创建这些新的behavior，所以我们需要维持现在collection view 的一些状态。尤其我们需要跟踪最近一次我们<code>bound</code>变化的增量。我们会在滚动时用这个状态去创建我们的behavior:</p>

<pre><code class="language-objc">
@property (nonatomic, assign) CGFloat latestDelta;

</code></pre>

<p>添加完这个property后，我们将要在<code>shouldInvalidateLayoutForBoundsChange:</code>方法中添加下面这行代码:</p>

<pre><code class="language-objc">
self.latestDelta = delta;

</code></pre>

<p>这就是我们需要修改我们的方法来响应滚动事件。我们的这两个方法是为了将collection view中items的layout信息传给dynamic animator，这种方式没有变化。事实上，当你的collection view实现了dynamic animator的大部分情况下，都需要实现我们上面提到的两个方法<code>layoutAttributesForElementsInRect:</code>和<code>layoutAttributesForItemAtIndexPath:</code>。</p>

<p>这里最难懂的部分就是tiling mechanism。我们将要完全重写我们的prepareLayout。</p>

<p>这个方法的第一步是将那些物体的index path已经不再屏幕上的behavior从dynamic animator上删除。第二步是添加那些即将显示的物体的behavior。</p>

<p>让我们先看一下第一步。</p>

<p>像以前一样，我们要调用<code>super prepareLayout</code>，这样我们就能依赖父类<code>UICollectionViewFlowLayout</code>提供的默认排布。还像以前一样，我们通过父类获取一个矩形内的所有元素的layout attribute。不同的是我们不是获取整个collection view 中的元素属性，而只是获取显示范围内的。</p>

<p>所以我们需要计算这个显示矩形。但是别着急！有件事要记住。我们的用户可能会非常快地滑动collection view，导致了dynamic animator不能跟上，所以我们需要稍微扩大显示范围，这样就能包含到那些将要显示的物体了。否则，在滑动很快的时候就会出现频闪现象了。让我们计算一下显示范围:</p>

<pre><code class="language-objc">
CGRect originalRect = (CGRect){.origin = self.collectionView.bounds.origin, .size = self.collectionView.frame.size};
CGRect visibleRect = CGRectInset(originalRect, -100, -100);

</code></pre>

<p>我确信在实际显示矩形上的每个方向都扩大100个像素对我的demo来说是可行的。仔细查看这些值是否适合你们的collection view，尤其是当你们的cell很小的情况下。</p>

<p>接下来我们就需要收集在显示范围内的collection view layout attributes。还有它们的index paths:</p>

<pre><code class="language-objc">
NSArray *itemsInVisibleRectArray = [super layoutAttributesForElementsInRect:visibleRect];

NSSet *itemsIndexPathsInVisibleRectSet = [NSSet setWithArray:[itemsInVisibleRectArray valueForKey:@"indexPath"]];

</code></pre>

<p>注意我们是在用一个NSSet。这是因为它具有常数复杂度的查找效率，并且我们经常的查找visibleIndexPathsSet是否已经包含了某个index path:</p>

<p>接下来我们要做的就是遍历dynamic animator 的behaviors，过滤掉那些已经在<code>itemsIndexPathsInVisibleRectSet</code>中的item。因为我们已经过滤掉我们的behavior，所以我们将要遍历的这些item都是不在显示范围里的，我们就可以将这些item从animator中删除掉(连同<code>visibleIndexPathsSet</code>属性中的index path):</p>

<pre><code class="language-objc">
NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(UIAttachmentBehavior *behaviour, NSDictionary *bindings) {
    BOOL currentlyVisible = [itemsIndexPathsInVisibleRectSet member:[[[behaviour items] firstObject] indexPath]] != nil;
    return !currentlyVisible;
}]

NSArray *noLongerVisibleBehaviours = [self.dynamicAnimator.behaviors filteredArrayUsingPredicate:predicate];

[noLongerVisibleBehaviours enumerateObjectsUsingBlock:^(id obj, NSUInteger index, BOOL *stop) {
    [self.dynamicAnimator removeBehavior:obj];
    [self.visibleIndexPathsSet removeObject:[[[obj items] firstObject] indexPath]];

}];

</code></pre>

<p>下一步就是要得到新出现item的<code>UICollectionViewLayoutAttributes</code>数组–那些item的index path在<code>itemsIndexPathsInVisibleRectSet</code>而不在<code>visibleIndexPathsSet</code>:</p>

<pre><code class="language-objc">
NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(UICollectionViewLayoutAttributes *item, NSDictionary *bindings) {
    BOOL currentlyVisible = [self.visibleIndexPathsSet member:item.indexPath] != nil;
    return !currentlyVisible;

}];
NSArray *newlyVisibleItems = [itemsInVisibleRectArray filteredArrayUsingPredicate:predicate];

</code></pre>

<p>一旦我们有新的layout attribute出现，我就可以遍历他们来创建新的behavior，并且将他们的index path添加到<code>visibleIndexPathsSet</code>中。首先，无论如何，我都需要获取到用户手指触碰的位置。如果它是<code>CGPointZero</code>的话，那就表示这个用户没有在滑动collection view，我就不需要在滚动时创建新的behavior:</p>

<pre><code class="language-objc">
CGPoint touchLocation = [self.collectionView.panGestureRecognizer locationInView:self.collectionView];

</code></pre>

<p>这是一个潜在的威胁。如果用户很快地滑动了collection view 之后释放了他的手指呢？这个collection view 就会一直滚动，但是我们的方法就不会在滚动时创建新的behavior了。幸运的是，那也就意味这scroll view滚动太快很难被注意到！好哇！这可能会是个问题，但是，只是针对那些拥有大量cell的collection view。在这种情况下，增加你的显示范围的界限就可以加载更多物体了。</p>

<p>现在我们需要枚举我们刚显示的item，为他们创建behavior，再将他们的index path 添加到<code>visibleIndexPathsSet</code>。我们还需要在滚动时做些运算来创建behavior:</p>

<pre><code class="language-objc">
[newlyVisibleItems enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes *item, NSUInteger idx, BOOL *stop) {
    CGPoint center = item.center;
    UIAttachmentBehavior *springBehaviour = [[UIAttachmentBehavior alloc] initWithItem:item attachedToAnchor:center];
    
    springBehaviour.length = 0.0f;
    springBehaviour.damping = 0.8f;
    springBehaviour.frequency = 1.0f;
    
    if (!CGPointEqualToPoint(CGPointZero, touchLocation)) {
        CGFloat yDistanceFromTouch = fabsf(touchLocation.y - springBehaviour.anchorPoint.y);
        CGFloat xDistanceFromTouch = fabsf(touchLocation.x - springBehaviour.anchorPoint.x);
        CGFloat scrollResistance = (yDistanceFromTouch + xDistanceFromTouch) / 1500.0f;
        
	if (self.latestDelta &lt; 0) {
            center.y += MAX(self.latestDelta, self.latestDelta*scrollResistance);
        
	}
	else {
            center.y += MIN(self.latestDelta, self.latestDelta*scrollResistance);
        
	}
        item.center = center;
    
    }
    
    [self.dynamicAnimator addBehavior:springBehaviour];
    [self.visibleIndexPathsSet addObject:item.indexPath];

}];

</code></pre>

<p>大部分代码看起来还是挺熟悉的。大概有一半是来自没有实现tiling的<code>prepareLayout</code>。另一半是来自<code>shouldInvalidateLayoutForBoundsChange</code>方法。我们用latestDelta这个property来表示<code>bound</code>变化的增量，适当地调整<code>UICollectionViewLayoutAttributes</code>使这些cell表现地就像被attachment behavior拉着一样。</p>

<p>就是这样，真的！我已经在真机上测试过显示上千个cell的情况了，它运行地非常完美。<a href="https://github.com/objcio/issue-5-springy-collection-view">去试试吧</a>。</p>

<h1 id="section-1">超越瀑布流布局</h1>

<p>一般来说，当我们使用<code>UICollectionView</code>的时候，继承<code>UICollectionViewFlowLayout</code>会比继承<code>UICollectionViewLayout</code>更容易。这是因为flow layout 会为我们做很多事。然而，瀑布流布局是严格基于它们的尺寸一个接一个的展现出来。如果你有一个layout不能适应这个标准怎么办？好的，如果你已经尝试用<code>UICollectionViewFlowLayout</code>来适应，而且你很确定它不能很好运行，那么就应该抛弃<code>UICollectionViewFlowLayout</code>这个定制性比较弱的子类，而应该直接在<code>UICollectionViewLayout</code>这个基类上进行定制。</p>

<p>当处理UIKit Dynamic的时候也是适用的。</p>

<p>让我们继承<code>UICollectionViewLayout</code>。当继承<code>UICollectionViewLayout</code>的时候需要实现<code>collectionViewContentSize</code>方法，这点非常重要。否则这个collection view就不知道如果去显示自己，也不会有显示任何东西。因为我们想要我们的collection view不要再滑动，我们将会返回我们的collection view的frame的尺寸，减去它的<code>contentInset.top</code>:</p>

<pre><code class="language-objc">
-(CGSize)collectionViewContentSize 
{
    return CGSizeMake(self.collectionView.frame.size.width, 
        self.collectionView.frame.size.height - self.collectionView.contentInset.top);

}

</code></pre>

<p>在这个(有教育意义)的例子中，我们的collection view总是会以零个cell开始，物体通过<code>performBatchUpdates:</code>方法添加。这就意味着我们必须使用<code>-[UICollectionViewLayout prepareForCollectionViewUpdates:]</code>方法来添加我们的behavior(即这个collection view的数据源总是以零开始)。</p>

<p>除了给各个物体添加附着behavior外，我们还将保留另外两个behavior:重力和碰撞。对于添加在这个collection view中的每个item来说，我们必须把这些item添加到我们的碰撞和附着behavior中。最后一步就是设置这些item的初始位置为屏幕外的某些地方，这样就有被附着behavior拉入到屏幕内的效果了:</p>

<pre><code class="language-objc">
-(void)prepareForCollectionViewUpdates:(NSArray *)updateItems
{
    [super prepareForCollectionViewUpdates:updateItems];

    [updateItems enumerateObjectsUsingBlock:^(UICollectionViewUpdateItem *updateItem, NSUInteger idx, BOOL *stop) {
	    if (updateItem.updateAction == UICollectionUpdateActionInsert) {
            UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes 
                layoutAttributesForCellWithIndexPath:updateItem.indexPathAfterUpdate];
        
            attributes.frame = CGRectMake(CGRectGetMaxX(self.collectionView.frame) + kItemSize, 300, kItemSize, kItemSize);

            UIAttachmentBehavior *attachmentBehaviour = [[UIAttachmentBehavior alloc] initWithItem:attributes 
                                                                                  attachedToAnchor:attachmentPoint];
            attachmentBehaviour.length = 300.0f;
            attachmentBehaviour.damping = 0.4f;
            attachmentBehaviour.frequency = 1.0f;
            [self.dynamicAnimator addBehavior:attachmentBehaviour];
        
            [self.gravityBehaviour addItem:attributes];
            [self.collisionBehaviour addItem:attributes];
        
	    }
    
    }];

}

</code></pre>

<p><img src="http://www.objc.io/images/issue-5/newtonianCollectionView@2x.gif" alt="Example" /></p>

<p>删除就有点复杂了。我们希望这些物体有”掉落”的效果而不是简单的消失。这就不仅仅是从collection view 中删除这个cell这么简单了，因为我们希望在它离开了屏幕之前还是保留它。我已经在代码中实现了这样的效果，但是有点坑爹。</p>

<p>基本上我们要做的是在layout中提供一个方法，在它删除attachment behavior两秒之后，将这个cell从collection view中删除。我们希望在这段时间里，这个cell能掉出屏幕，但是这不一定会发生。如果没有发生，也没关系。只要淡出就行了。然而，我们必须避免在这两秒内没有新的cell被添加，也没有旧的cell被删除。(我说过有点坑。)</p>

<p>欢迎在github上提出pull requests</p>

<p>这个方法是有些限制的。我将cell数量的上限设为10，但是即使这样，在像iPad2这样比较久的设备中，动画就会运行地很慢。然而，这个例子充分地展示你可以自己实现有意思的动力学模拟的方法–这并不意味着这是一个可以解决任何问题的万金油。你的模拟中包括性能的各个方面，都是取决于你自己。</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    <div class="entry-meta"><span class="entry-date date published updated"><time datetime="2014-02-19T00:00:00+08:00"><a href="http://morisunshine.com/ruby/make_your_own_gem/">February 19, 2014</a></time></span><span class="author vcard"><span class="fn"><a href="http://morisunshine.com/about/" title="About Sheldon">Sheldon</a></span></span></div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="http://morisunshine.com/ruby/make_your_own_gem/" rel="bookmark" title="制作自己的Gem" itemprop="url">制作自己的Gem</a></h1>
    
  </header>
  <div class="entry-content">
    <p> <a href="#introduce"><strong>什么是Gem？</strong></a>     <br />
 <a href="#first_gem"><strong>第一个Gem</strong></a><br />
 <a href="#include_more_files"><strong>包含更多文件</strong></a><br />
 <a href="#adding_an_executable"><strong>添加可执行文件</strong></a><br />
 <a href="#writing_tests"><strong>测试</strong></a><br />
 <a href="#documenting_your_code"><strong>文档</strong></a>  </p>

<p><a id="introduce" name="introduce"> </a></p>

<h2 id="gem">什么是Gem?</h2>

<p>RubyGems是一个方便而强大的Ruby程序包管理器，Ruby的第三方插件是用gem方式来管理，非常容易发布和共享，一个简单的命令就可以安装上第三方的扩展库。特点：能远程安装包，包之间依赖关系的管理，简单可靠的卸载，查询机制，能查询本地和远程服务器的包信息，能保持一个包的不同版本，基于Web的查看接口，能查看你安装的gem的信息。</p>

<hr />

<p><a id="first_gem" name="first_gem"> </a></p>

<h2 id="gem-1">第一个Gem</h2>

<p>我们要创建一个名叫<code>moondemo</code>的gem，首先，就要创建一个名字为<code>moondemo_yourname</code>的目录，这个是为了后面的发布，如果你想发布的话，就要检查一下你的gem名字是否已经被人使用了，如果已经被人使用，那就要换个名字了。  <br />
然后这个目录里的基本文件结构应该是这样的。 </p>

<pre><code class="language-ruby">➜  tree  
.  
├── moondemo.gemspec    
├── lib  
│   └── moondemo.rb  

</code></pre>

<p>gem中的代码被放在<code>lib</code>目录中，这里有个约定就是<code>lib</code>中必须有个和gem同名的ruby文件，这样当<code>require 'moondemo'</code>运行的时候，这个gem就会被加载，这个文件就是负责配置你的gem的代码和API。</p>

<pre><code class="language-ruby">➜  cat lib/moondemo.rb
class moondemo
  def self.hi
    puts "Hello world!"
  end
end

</code></pre>

<p>而<code>.gemspec</code>文件是定义了这个gem的信息，比如是这个gem的功能，作者等，并且当这个gem发布的时候，会将这些信息显示到这个gem的主页上(就像<a href="http://rubygems.org/gems/jekyll">jekyll</a>)。</p>

<pre><code class="language-ruby">➜  cat moondemo.gemspec
Gem::Specification.new do |s|
  s.name        = 'moondemo'
  s.version     = '0.0.0'
  s.date        = '2014-02-19'
  s.summary     = "moondemo!"
  s.description = "A simple hello world gem"
  s.authors     = ["sheldon huang"]
  s.email       = 'allenwenzhou@gmail.com'
  s.files       = ["lib/moondemo.rb"]
  s.homepage    =
    'http://rubygems.org/gems/moondemo'
  s.license       = 'MIT'
end

</code></pre>

<p>这里有很多选项，一看名字就知道他们是要代表什么内容的，如果你还想知道更多就看一些这个<a href="http://guides.rubygems.org/specification-reference/">文档</a></p>

<p>当我们创建完成了一个.gemspec，就可以编译出一个gem了，是不是有点小激动啊。但如果想要测试它就必须要在本地安装编译好的gem。</p>

<pre><code class="language-ruby">➜ gem build moondemo.gemspec
  Successfully built RubyGem
  Name: moondemo
  Version: 0.0.1
  File: moondemo-0.0.1.gem
  
➜ gem install ./moondemo-0.0.1.gem
Successfully installed moondemo-0.0.1
Parsing documentation for moondemo-0.0.1
Installing ri documentation for moondemo-0.0.1
1 gem installed

</code></pre>

<p>上面这些步骤，只能是在本地已经装好了我们自己的gem，但还没有使用它，
我们需要<code>require</code>这个gem然后根据自己定义的方法来使用它。</p>

<pre><code class="language-ruby">
➜ irb
2.0.0-p353 :001 &gt; require 'moondemo'
 =&gt; true
2.0.0-p353 :002 &gt; MoonDemo.hi
Hello world!
 =&gt; nil
</code></pre>
<p>现在就可以将你的gem发布到Ruby社区上了，当在发布之前需要将你的帐号安装在电脑上，如果你在RubyGems.org上注册了帐号，那就只需要输入一个命令,再输入自己的密码就可以了</p>

<pre><code class="language-ruby">➜ curl -u 你的帐号名 https://rubygems.org/api/v1/api_key.yaml &gt; ~/.gem/credentials; chmod 0600 ~/.gem/credentials

Enter host password for user '你的帐号名':

</code></pre>

<p>一旦你的用户名已经被安装了，就可以直接发布你的gem了。</p>

<pre><code class="language-ruby">➜ gem push moondemo-0.0.1.gem
Pushing gem to https://rubygems.org...
Successfully registered gem: moondemo (0.0.1)

</code></pre>
<p>很快的，你的gem就可以被任何人使用了</p>

<pre><code class="language-ruby">➜ gem install moondemo
Successfully installed moondemo-0.0.1
Parsing documentation for moondemo-0.0.1
1 gem installed

</code></pre>
<p>用Ruby和RubyGems来分享代码是不是很简单。</p>

<hr />

<p><a id="include_more_files" name="include_more_files"> </a></p>

<h2 id="section">包含更多文件</h2>

<p>我们以后代码当然不会这么简单，如果代码变得非常多了之后，该怎么办呢，当然是要是要将代码分到不同的文件中了。<br />
比如我们想在刚才的gem中添加根据不同语言来输出不同语言的”Hello world”。<br />
我们就可以添加一个<code>Translator</code>文件，刚才提到过，gem的根文件是负责加载代码的，所以其他的功能的文件就需要放在<code>lib</code>中和gem同名的目录中，我们可以这样分:</p>

<pre><code class="language-bash">➜ tree
.
├── lib
│   ├── moondemo
│   │   └── translator.rb
│   └── moondemo.rb
├── moondemo-0.0.1.gem

</code></pre>

<p><code>Translator</code>中的内容是:</p>

<pre><code class="language-ruby">class Translator
  def initialize(language)
    @language = language
  end

  def hi
    case @language
      when "chinese"
        "你好，世界!"
      else
        "Hello world!"
      end
  end
end

</code></pre>

<p>所以接下来，<code>moondemo.rb</code>中需要加载<code>Translator</code>:</p>

<pre><code class="language-ruby">class MoonDemo
  def self.hi(language = "english")
    translator = Translator.new(language)
    translator.hi
  end
end

</code></pre>

<p><em>注意:每次新建了一个目录或者文件，都不要忘记加到.gemspec文件中，就像这样</em></p>

<pre><code class="language-ruby"> s.authors     = ["Sheldon"]
 s.email       = 'allenwenzhou@gmial.com'
 s.files       = ["lib/moondemo.rb","lib/moondemo/translator.rb"]
  
</code></pre>
<p><em>如果没有上面的修改的话，这个新建的目录是不会被加载到已安装的gem里的</em></p>

<p>让我们再运行一篇</p>

<pre><code class="language-ruby">➜ irb -Ilib -rmoondemo
2.0.0-p353 :001 &gt; MoonDemo.hi("english")
 =&gt; "Hello world!"
2.0.0-p353 :002 &gt; MoonDemo.hi("chinese")
 =&gt; "你好，世界!"
 
</code></pre>

<p>这里我们使用了一个新的命令行<code>-Ilib</code>,通常RubyGems会为你包含了<code>lib</code>路径，所以很多时候，我们不需要去考虑配置它们的加载路径，但是，如果你把代码运行在RubyGems的项目之外，你就要自己去配置这些了。</p>

<p>如果你添加了一些新的文件到你的gem中，那么你一定要记住在发布之前将这些文件添加到你的<code>.gemspec</code>的<code>files</code>数组中。这样很麻烦是么，所以很多人就选择用<a href="http://docs.seattlerb.org/hoe/">Hoe</a>,<a href="https://github.com/technicalpickles/jeweler">Jeweler</a>,<a href="http://rake.rubyforge.org/classes/Rake/GemPackageTask.html">Rake</a>,<a href="http://railscasts.com/episodes/245-new-gem-with-bundler">Bundler</a>或者用<a href="https://github.com/wycats/newgem-template/blob/master/newgem.gemspec">动态的gemspec</a>来实现自动化。</p>

<p>添加更多的目录也都是按照上面一样的步骤，我们要将我们的文件结构分布合理，这样对于我们以后的维护和未来开发人员来说就不会是一件头疼的事儿了。</p>

<p><a id="adding_an_executable" name="adding_an_executable"> </a></p>

<h2 id="section-1">添加可执行文件</h2>

<p>gem除了可以提供Ruby代码库外，还可以在你的可执行文件路径里提供很多可执行可执行文件文件。可能最有名的就是<code>rake</code>，
添加一个可执行可执行可执行文件文件其实很简单，你只需要将你的可执行文件放在你的gem的<code>bin</code>目录下，然后在将这个文件添加到<code>.gemspec</code>文件中<code>executables</code>的列表里就可以了，让我们试一下:</p>

<pre><code class="language-bash">➜  mkdir bin
➜  touch bin/moondemo
➜  chmod a+x bin/moondemo

</code></pre>
<p>这个可执行文件只需要在开头用<a href="http://www.catb.org/jargon/html/S/shebang.html">shebang</a>来表明这是用程序来运行的，下面就是这个可执行文件的内容:</p>

<pre><code class="language-ruby">#!/usr/bin/env ruby

require 'moondemo'
puts MoonDemo.hi(ARGV[0])

</code></pre>
<p>这个可执行文件的内容很简单，它只是加载了moondemo这个gem，然后在命令行中通过输入一个参数来判断是用哪个国家的语言来说”hello, world”。下面就是运行的例子:</p>

<pre><code class="language-bash">➜  ruby -Ilib ./bin/moondemo
Hello world!
➜  ruby -Ilib ./bin/moondemo chinese
你好，世界!

</code></pre>

<p>最后，我们要将这个可执行文件添加到<code>.gemspec</code></p>

<pre><code class="language-ruby">s.executables &lt;&lt; 'moondemo'

</code></pre>

<p>更新你的gem，上传到官网上，这样你就可以在命令行中有自己的命令了，是不是很帅啊。这里要提醒一下，上传新的gem时，要记得修改<code>.gemspec</code>中的版本号。详情看<a href="http://guides.rubygems.org/patterns/#semantic-versioning">这儿</a></p>

<p>在看一下用我们自己定义的命令行吧:</p>

<pre><code class="language-bash">
➜  ~  moondemo
Hello world!
➜  ~  moondemo chinese
你好，世界!

</code></pre>

<p>世界在向我们招手呢。哈哈哈~~~</p>

<p><a id="writing_tests" name="writing_tests"> </a></p>

<h1 id="section-2">测试</h1>

<p>测试我们的gem是非常重要的，它不仅保证了这个gem是正常的，也保证了别人能知道你的gem是正常的。当我们评价一个gem的时候，很多Ruby开发者会倾向于通过查看测试用例来做为主要依据。</p>

<p>Gems是支持将测试文件添加到程序包中的，所以当gem被下载了之后，我们可以直接运行测试用例。这里有个帮助我们如何在不同框架和解释器下写测试用例的社区叫<a href="http://test.rubygems.org/">GemTesters</a>
总而言之:去测试我们的Gem吧！啥都别想了！</p>

<p><code>Test::Unit</code>是Ruby的自带测试框架。这里有很多<a href="https://github.com/seattlerb/minitest/blob/master/README.txt">教程</a>，当然还是有很多其他的测试框架，<a href="http://rspec.info/">RSpec</a>就是比较有名的一个，是不是迫不及待，让我们测试吧！</p>

<p>我们需要在原来的基础上再添加一些文件，一个名为<code>Rakefile</code>的文件和一个名为<code>test</code>的目录:</p>

<pre><code class="language-bash">
.
├── Rakefile
├── bin
│   └── moondemo
├── lib
│   ├── moondemo
│   │   └── translator.rb
│   └── moondemo.rb
├── moondemo-0.0.1.gem
├── moondemo.gemspec
├── npm-debug.log
└── test
    └── test_moondemo.rb

</code></pre>

<p><code>Rakefile</code>文件是为了实现自动化的测试:</p>

<pre><code class="language-ruby">
require 'rake/testtask'

Rake::TestTask.new do |t|
        t.libs &lt;&lt; 'test'
end

desc "Run tests"
task :default =&gt; :test
~

</code></pre>

<p>下面就是一个简单的测试用例了:</p>

<pre><code class="language-ruby">require 'test/unit'
require 'moondemo'

class MoonDemoTest &lt; Test::Unit::TestCase
  def test_english_hello
    assert_equal "Hello world!",
      MoonDemo.hi("english")
  end

  def test_any_hello
    assert_equal "Hello world!",
      MoonDemo.hi("ruby")
  end

  def test_spanish_hello
    assert_equal "你好，世界!",
      MoonDemo.hi("chinese")
  end
end

</code></pre>

<p>最后，让我们运行这个测试:</p>

<pre><code class="language-bash">➜  rake test
Run options:

# Running tests:

Finished tests in 0.006151s, 487.7256 tests/s, 487.7256 assertions/s.
3 tests, 3 assertions, 0 failures, 0 errors, 0 skips

</code></pre>

<p>很好，全部都通过了！</p>

<p><a id="documenting_your_code" name="documenting_your_code"> </a></p>

<h1 id="section-3">文档</h1>

<p>文档和测试是一样重要的，大部分gem都是用RDoc来生成文档的，这里有很多<a href="http://docs.seattlerb.org/rdoc/RDoc/Markup.html">教程</a>.
很简单，先切换到gem的根目录下，再命令行中输入<code>rdoc</code>，你就会发现多出了一个名为<code>doc</code>的目录，里面就是我们的文档了，当然你可以自己再进行一些调整。
除了RDoc呢，我们还有另外的选择<a href="http://yardoc.org/">YARD</a>，当我们发布了gem的时候呢，<a href="http://rubydoc.info/">RubyDoc.info</a>会根据你的gem自动生成YARDocs，并且它是可以向下兼容RDoc。</p>


  </div><!-- /.entry-content -->
</article><!-- /.hentry -->


<div class="pagination">
  
    Previous
  
  <ul class="inline-list">
    <li>
      
        <span class="current-page">1</span>
      
    </li>
    
      <li>
        
          <a href="http://morisunshine.com/page2">2</a>
        
      </li>
    
  </ul>
  
    <a href="http://morisunshine.com/page2" class="btn">Next</a>
  
</div><!-- /.pagination -->
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2014 Sheldon. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/hpstr/">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://morisunshine.com/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://morisunshine.com/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl = 
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', '47868064']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

          

</body>
</html>