<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Morisunshine's Blog</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://morisunshine.com/feed.xml" />
<link rel="alternate" type="text/html" href="http://morisunshine.com" />
<updated>2014-05-19T14:05:03+08:00</updated>
<id>http://morisunshine.com/</id>
<author>
  <name>Sheldon</name>
  <uri>http://morisunshine.com/</uri>
  <email>sheldon.zen@gmail.com</email>
</author>


<entry>
  <title type="html"><![CDATA[交互式动画]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/ios/interactive_animations/" />
  <id>http://morisunshine.com/ios/interactive_animations</id>
  <published>2014-05-17T00:00:00+08:00</published>
  <updated>2014-05-17T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.objc.io/issue-12/interactive-animations.html&quot;&gt;原文&lt;/a&gt;作者&lt;a href=&quot;https://twitter.com/chriseidhof&quot;&gt;Chris Eidhof&lt;/a&gt;和&lt;a href=&quot;https://twitter.com/floriankugler&quot;&gt;Florian Kugler&lt;/a&gt;。转载请注明出处！&lt;/p&gt;

&lt;p&gt;在2007年，乔布斯在第一次介绍 iPhone 的时候，iPhone 的触摸屏交互简直就像是一种魔法。最好的例子就是在他&lt;a href=&quot;https://www.youtube.com/watch?v=t4OEsI0Sc_s&amp;amp;t=16m9s&quot;&gt;第一次滑动 TableView 的展示上&lt;/a&gt;。你可以感受到当时观众的反应是多么惊讶，但是对于现在的我们来说早已习以为常。在展示的后面一部分，他特别指出当他给别人看了这个滑动例子，别人说的一句话: &lt;a href=&quot;https://www.youtube.com/watch?v=t4OEsI0Sc_s&amp;amp;t=16m9s&quot;&gt;“当这个界面滑动的时候我就已经被征服了”&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;是什么样的滑动能让人有‘哇哦’的效果呢？&lt;/p&gt;

&lt;p&gt;滑动是最完美地展示了通过触摸屏直接操作的例子。滚动视图遵从于你的手指，当你的手指离开屏幕的时，视图会自然地继续滑动直到该停止的时候停止。它用自然的方式减速，甚至在快到界限的时候也能表现出细腻的弹力效果。滑动在任何时候都保持相应，并且看上去非常真实。&lt;/p&gt;

&lt;h2&gt;动画的状态&lt;/h2&gt;

&lt;p&gt;在 iOS 中的大部分动画仍然没有按照最初 iPhone 指定的滑动标准实现。这里有很多动画一旦它们运行就不能交互（比如说解锁动画，主界面中打开文件夹和关闭文件夹的动画，和导航栏切换的动画，还有很多）。&lt;/p&gt;

&lt;p&gt;然而现在有一些应用给我一种始终在控制动画的体验，我们可以直接操作那些我在用的动画。当我们将这些应用和其他的应用相比较之后，我们就能感觉到明显的区别。这些应用中最优秀的有最初的 Twitter iPad app， 和现在的 Facebook Paper。但目前，使用直接操作为主并且可以中断动画的应用仍然很少。这就给我们做出更好的应用提供了机会，让我们的应用有更不同的，更高质量的体验。&lt;/p&gt;

&lt;h2&gt;真实交互式动画的挑战&lt;/h2&gt;

&lt;p&gt;当我们用 UIView 或者 CAAnimation 来实现交互式动画时会有两个大问题: 这些动画会将你在屏幕上的内容和 layer 上的实际的特定属性分离开来，并且他们直接操作这些特定属性。&lt;/p&gt;

&lt;h3&gt;模型 (Model) 和显示 (Presentation) 的分离&lt;/h3&gt;

&lt;p&gt;Core Animation 是通过分离 layer 的模型属性和你在屏幕上看到的界面 (显示层) 的方式来设计的，这就导致我们很难去创建一个可以在任何时候能交互的动画，因为在动画时，模型和界面已经不能匹配了。这时，我们不得不通过手动的方式来同步这两个的状态，来达到改变动画的效果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;view.layer.center = view.layer.presentationLayer.center;
[view.layer removeAnimationForKey:@&amp;quot;animation&amp;quot;];
// 添加新动画
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;直接控制 vs 间接控制&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;CAAnimation&lt;/code&gt; 动画的更大的问题是它们是直接在 layer 上对属性进行操作的。这意味着什么呢？比如我们想指定一个 layer 从坐标为 (100, 100) 的位置运动到 (300, 300) 的位置，但是在它运动到中间的时候，我们想它停下来并且让它回到它原来的位置，事情就变得非常复杂了。如果你只是简单地删除当前的动画然后再添加一个新的，那么这个 layer 的速率就会不连续。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.objccn.io/issue-12/abrupt.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而，我们想要的是一个漂亮的，流畅地减速和加速的动画。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.objccn.io/issue-12/smooth.png&quot; width=&quot;600&quot; /&gt;&lt;/p&gt;

&lt;p&gt;只有通过&lt;em&gt;间接&lt;/em&gt;操作动画才能达到上面的效果，比如通过模拟力在界面上的表现。新的动画需要用 layer 的当前&lt;em&gt;速度矢量&lt;/em&gt;作为参数传入来达到流畅的效果。&lt;/p&gt;

&lt;p&gt;看一下 UIView 中关于弹簧动画的 API &lt;code&gt;animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:&lt;/code&gt;，你会注意到速率是个 &lt;code&gt;CGFloat&lt;/code&gt;。所以当我们给一个移动 view 的动画在其运动的方向上加一个初始的速率时，你没法告知动画这个 view 现在的运动状态，比如我们不知道要添加的动画的方向是不是和原来的 view 的速度方向垂直。为了使其成为可能，这个速度需要用向量来表示。&lt;/p&gt;

&lt;h2&gt;解决方案&lt;/h2&gt;

&lt;p&gt;让我们看一下我们怎样来正确实现一个可交互并且可以中断的动画。我们来做一个类似于控制中心板的东西来实现这个效果：&lt;/p&gt;

&lt;p&gt;&lt;video controls=&quot;1&quot; style=&quot;display:block;max-width:100%;height:auto;border:0;&quot;&gt;
  &lt;source src=&quot;http://www.objc.io/images/issue-12/interactive-animation.mov&quot;&gt;
&lt;/video&gt;&lt;/p&gt;

&lt;p&gt;这个控制板有两个状态：打开和关闭。你可以通过点击来切换这两个状态，或者通过上下拖动来调调整它向上或向下。我要将这个控制面板的所有状态都做到可以交互，甚至是在动画的过程中也可以，这是一个很大的挑战。比如，当你在这个控制板还没有切换到打开状态的动画过程中，你点击了它，那么它应该从现在这个点的位置马上回到关闭状态的位置。在现在很多的应用中，大部分都是用默认的动画 API，你必须要等一个动画结束之后你才能做自己想做的事情。或者，如果你不等待的话，就会看到一个不连续的速度曲线。我们要解决这个问题。&lt;/p&gt;

&lt;h3&gt;UIKit 力学&lt;/h3&gt;

&lt;p&gt;随着 iOS7 的发布，苹果向我们展示了一个叫 UIKit 力学的动画框架 (可以参见 WWDC 2013 sessions &lt;a href=&quot;https://developer.apple.com/videos/wwdc/2013/index.php?id=206&quot;&gt;206&lt;/a&gt; 和 &lt;a href=&quot;https://developer.apple.com/videos/wwdc/2013/index.php?id=221&quot;&gt;221&lt;/a&gt;)。UIKit 力学是一个基于模拟物理引擎的框架，只要你添加指定的行为到动画对象上来实现 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/uikit/reference/UIDynamicItem_Protocol/Reference/Reference.html&quot;&gt;UIDynamicItem&lt;/a&gt; 协议就能实现很多动画。这个框架非常强大，并且它能够在多个物体间启用像是附着和碰撞这样的复杂行为。请看一下 &lt;a href=&quot;https://developer.apple.com/library/ios/samplecode/DynamicsCatalog/Introduction/Intro.html&quot;&gt;UIKit Dynamics Catalog&lt;/a&gt;，确认一下什么是可用的。&lt;/p&gt;

&lt;p&gt;因为 UIKit 力学中的的动画是被间接驱动的，就像我在上面提到的，这使我们实现真实的交互式动画成为可能，它能在任何时候被中断并且拥有连续的加速度。同时，UIKit 力学在物理层的抽象上能完全胜任我们一般情况下在用户界面中的所需要的所有动画。其实在大部分情况下，我们只会用到其中的一小部分功能。&lt;/p&gt;

&lt;h4&gt;定义行为&lt;/h4&gt;

&lt;p&gt;为了实现我们的控制板的行为，我们将使用 UIkit 力学中的两个不同行为：&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/uikit/reference/UIAttachmentBehavior_Class/Reference/Reference.html&quot;&gt;UIAttachmentBehavior&lt;/a&gt; 和 &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/uikit/reference/UIDynamicItemBehavior_Class/Reference/Reference.html&quot;&gt;UIDynamicItemBehavior&lt;/a&gt;。附着行为用来扮演弹簧的角色，它将界面向目标点拉动。另一方面，我们用动态 item behvaior 定义了比如摩擦系数这样的界面的内置属性。&lt;/p&gt;

&lt;p&gt;我创建了一个我们自己的行为子类，以将这两个行为封装到我们的控制板上:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@interface PaneBehavior : UIDynamicBehavior

@property (nonatomic) CGPoint targetPoint;
@property (nonatomic) CGPoint velocity;

- (instancetype)initWithItem:(id &amp;lt;UIDynamicItem&amp;gt;)item;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过一个 dynamic item 来初始化这个行为，然后就可以设置它的目标点和我们想要的任何速度。在内部，我们创建了附着行为和 dynamic item 行为，并且将这些行为添加到我们自定义的行为中:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)setup
{
    UIAttachmentBehavior *attachmentBehavior = [[UIAttachmentBehavior alloc] initWithItem:self.item attachedToAnchor:CGPointZero];
    attachmentBehavior.frequency = 3.5;
    attachmentBehavior.damping = .4;
    attachmentBehavior.length = 0;
    [self addChildBehavior:attachmentBehavior];
    self.attachmentBehavior = attachmentBehavior;

    UIDynamicItemBehavior *itemBehavior = [[UIDynamicItemBehavior alloc] initWithItems:@[self.item]];
    itemBehavior.density = 100;
    itemBehavior.resistance = 10;
    [self addChildBehavior:itemBehavior];
    self.itemBehavior = itemBehavior;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了用 &lt;code&gt;targetPoint&lt;/code&gt; 和 &lt;code&gt;velocity&lt;/code&gt; 属性来影响 item 的 behavior，我们需要重写它们的 setter 方法，并且分别修改在附着行为和 item behaviors 中的对应的属性。我们对目标点的 setter 方法来说，这个改动很简单：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)setTargetPoint:(CGPoint)targetPoint
{
    _targetPoint = targetPoint;
    self.attachmentBehavior.anchorPoint = targetPoint;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 &lt;code&gt;velocity&lt;/code&gt; 属性，我们需要多做一些工作，因为 dynamic item behavior 只允许相对地改变速度。这就意味如果我们要将 &lt;code&gt;velocity&lt;/code&gt; 设置为绝对值，首先我们就需要得到当前的速度，然后再加上速度差才能得到我们的目标速度。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)setVelocity:(CGPoint)velocity
{
    _velocity = velocity;
    CGPoint currentVelocity = [self.itemBehavior linearVelocityForItem:self.item];
    CGPoint velocityDelta = CGPointMake(velocity.x - currentVelocity.x, velocity.y - currentVelocity.y);
    [self.itemBehavior addLinearVelocity:velocityDelta forItem:self.item];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;将Behavior投入使用&lt;/h3&gt;

&lt;p&gt;我们的控制板有三个不同状态：在开始或结束位置的静止状态，正在被用户拖动的状态，以及在没有用户控制时运动到结束位置的动画状态。&lt;/p&gt;

&lt;p&gt;为了将从直接操作状态 (用户拖动这个滑动板) 过渡到动画状态这个过程做的流畅，我们还有很多其他的事要做。当用户停止拖动控制板时，它会发送一个消息到它的 delegate。根据这个方法，我们可以知道这个板应该朝哪个方向运动，然后在我们自定义的 &lt;code&gt;PaneBehavior&lt;/code&gt; 上设置结束点，以及初始速度 (这非常重要)，并将行为添加到动画器中去，以此确保从拖动操作到动画状态这个过程能够非常流畅。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)draggableView:(DraggableView *)view draggingEndedWithVelocity:(CGPoint)velocity
{
    PaneState targetState = velocity.y &amp;gt;= 0 ? PaneStateClosed : PaneStateOpen;
    [self animatePaneToState:targetState initialVelocity:velocity];
}

- (void)animatePaneToState:(PaneState)targetState initialVelocity:(CGPoint)velocity
{
    if (!self.paneBehavior) {
        PaneBehavior *behavior = [[PaneBehavior alloc] initWithItem:self.pane];
        self.paneBehavior = behavior;
    }
    self.paneBehavior.targetPoint = [self targetPointForState:targetState];
    if (!CGPointEqualToPoint(velocity, CGPointZero)) {
        self.paneBehavior.velocity = velocity;
    }
    [self.animator addBehavior:self.paneBehavior];
    self.paneState = targetState;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦用户用他的手指再次触动控制板时，我必须要将所有的 dynamic behavior 从 animator 删除，这样才不会影响控制板对拖动手势的响应：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)draggableViewBeganDragging:(DraggableView *)view
{
    [self.animator removeAllBehaviors];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们不仅仅允许控制板可以被拖动，还要允许它可以被点击，让它可以从一个位置跳转到另一个位置以达到开关的效果。一旦点击事件发生，我们就会立即调整这个滑动板的目标位置。因为我们不能直接控制动画，但是通过弹力和摩擦力，我们的动画可以非常流畅地执行这个动作：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)didTap:(UITapGestureRecognizer *)tapRecognizer
{
    PaneState targetState = self.paneState == PaneStateOpen ? PaneStateClosed : PaneStateOpen;
    [self animatePaneToState:targetState initialVelocity:CGPointZero];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就实现了我们的大部分功能了。你可以在 &lt;a href=&quot;https://github.com/objcio/issue-12-interactive-animations-uidynamics&quot;&gt;GitHub&lt;/a&gt; 上查看完整的例子。&lt;/p&gt;

&lt;p&gt;重申一点：UIKit 力学可以通过在界面上模拟力来间接地驱动动画（我们的例子中，使用的是弹力和摩擦力）。这间接地使我们在任何时候都能以连续的速度曲线来与界面进行交互。&lt;/p&gt;

&lt;p&gt;现在我们已经通过 UIKit 力学实现了整个交互，让我们回顾一下这个场景。这个例子的动画中我们只用了 UIKit 力学中一小部分功能，并且它的实现方式也非常简单。对于我们来说这是一个去理解它其中的过程的很好的例子，但是如果我们使用的环境中没有 UIKit  力学 (比如说在 Mac 上)，或者你的使用场景中不能很好的适用 UIKit 力学呢。&lt;/p&gt;

&lt;h2&gt;自己操作动画&lt;/h2&gt;

&lt;p&gt;至于在你的应用中大部分时间会用的动画，比如简单的弹力动画，我们控制它真的不难。我们可以做一个练习，来看看如何抛弃 UIKit 力学这个巨大的黑盒子，看要如何“手动”来实现一个简单的交互。想法非常简单：我们只要每秒修改这个 view 的 frame 60 次。每一帧我们都基于当前速度和作用在 view 上的力来调整 view 的 frame 就可以了。&lt;/p&gt;

&lt;h3&gt;物理原理&lt;/h3&gt;

&lt;p&gt;首先让我们看一下我们需要知道的基础物理知识，这样我们才能实现出刚才使用 UIKit 力学实现的那种弹簧动画效果。为了简化问题，虽然引入第二个维度也是很直接的，但我们在这里只关注一维的情况 (在我们的例子中就是这样的情况)。&lt;/p&gt;

&lt;p&gt;我们的目标是依据控制面板当前的位置和上一次动画后到现在为止经过的时间，来计算它的新位置。我们可以把它表示成这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;y = y0 + Δy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;位置的偏移量可以通过速度和时间的函数来表达：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Δy = v ⋅ Δt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个速度可以通过前一次的速度加上速度偏移量算出来，这个速度偏移量是由力在 view 上的作用引起的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;v = v0 + Δv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;速度的变化可以通过作用在这个 view 上的冲量计算出来：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Δv = (F ⋅ Δt) / m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，让我们看一下作用在这个界面上的力。为了得到弹簧效果，我们必须要将摩擦力和弹力结合起来：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;F = F_spring + F_friction
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;弹力的计算方法我们可以从任何一本教科书中得到 (编者注：简单的胡克定律)：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;F_spring = k ⋅ x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 是弹簧的劲度系数，&lt;code&gt;x&lt;/code&gt; 是 view 到目标结束位置的距离 (也就是弹簧的长度)。因此，我们可以把它写成这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;F_spring = k ⋅ abs(y_target - y0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;摩擦力和 view 的速度成正比：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;F_friction = μ ⋅ v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;μ&lt;/code&gt; 是一个简单的摩擦系数。你可以通过别的方式来计算摩擦力，但是这个方法能很好地做出我们想要的动画效果。&lt;/p&gt;

&lt;p&gt;将上面的表达式放在一起，我们就可以算出作用在界面上的力：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;F = k ⋅ abs(y_target - y0) + μ ⋅ v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了实现起来更简单点些，我们将 view 的质量设为 1，这样我们就能计算在位置上的变化：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Δy = (v0 + (k ⋅ abs(y_target - y0) + μ ⋅ v) ⋅ Δt) ⋅ Δt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;实现动画&lt;/h3&gt;

&lt;p&gt;为了实现这个动画，我们首先需要创建我们自己的 &lt;code&gt;Animator&lt;/code&gt; 类，它将扮演驱动动画的角色。这个类使用了 &lt;code&gt;CADisplayLink&lt;/code&gt;，&lt;code&gt;CADisplayLink&lt;/code&gt; 是专门用来将绘图与屏幕刷新频率相同步的定时器。换句话说，如果你的动画是流畅的，这个定时器就会每秒调用你的方法60次。接下来，我们需要实现 &lt;code&gt;Animation&lt;/code&gt; 协议来和我们的 &lt;code&gt;Animator&lt;/code&gt; 一起工作。这个协议只有一个方法，&lt;code&gt;animationTick:finished:&lt;/code&gt;。屏幕每次被刷新时都会调用这个方法，并且在方法中会得到两个参数：第一个参数是前一个 frame 的持续时间，第二个参数是一个指向 &lt;code&gt;BOOL&lt;/code&gt; 的指针。当我们设置这个指针的值为 &lt;code&gt;YES&lt;/code&gt; 时，我们就可以与 &lt;code&gt;Animator&lt;/code&gt; 取得通讯并汇报动画完成；&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@protocol Animation &amp;lt;NSObject&amp;gt;
- (void)animationTick:(CFTimeInterval)dt finished:(BOOL *)finished;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们会在下面实现这个方法。首先，根据时间间隔我们来计算由弹力和摩擦力的合力。然后根据这个力来更新速度，并调整 view 的中心位置。最后，当这个速度降低并且 view 到达结束位置时，我们就停止这个动画：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)animationTick:(CFTimeInterval)dt finished:(BOOL *)finished
{
    static const float frictionConstant = 20;
    static const float springConstant = 300;
    CGFloat time = (CGFloat) dt;

    //摩擦力 = 速度 * 摩擦系数
    CGPoint frictionForce = CGPointMultiply(self.velocity, frictionConstant);
    //弹力 = (目标位置 - 当前位置) * 弹簧劲度系数
    CGPoint springForce = CGPointMultiply(CGPointSubtract(self.targetPoint, self.view.center), springConstant);
    //力 = 弹力 - 摩擦力
    CGPoint force = CGPointSubtract(springForce, frictionForce);

    //速度 = 当前速度 + 力 * 时间 / 质量
    self.velocity = CGPointAdd(self.velocity, CGPointMultiply(force, time));
    //位置 = 当前位置 + 速度 * 时间
    self.view.center = CGPointAdd(self.view.center, CGPointMultiply(self.velocity, time));

    CGFloat speed = CGPointLength(self.velocity);
    CGFloat distanceToGoal = CGPointLength(CGPointSubtract(self.targetPoint, self.view.center));
    if (speed &amp;lt; 0.05 &amp;amp;&amp;amp; distanceToGoal &amp;lt; 1) {
        self.view.center = self.targetPoint;
        *finished = YES;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是这个方法里的全部内容。我们把这个方法封装到一个 &lt;code&gt;SpringAnimation&lt;/code&gt; 对象中。除了这个方法之外，这个对象中还有一个初始化方法，它指定了 view 中心的目标位置 (在我们的例子中，就是打开状态时界面的中心位置，或者关闭状态时界面的中心位置) 和初始的速度。&lt;/p&gt;

&lt;h3&gt;将动画添加到 view 上&lt;/h3&gt;

&lt;p&gt;我们的 view 类刚好和使用 UIDynamic 的例子一样：它有一个拖动手势，并且根据拖动手势来更新中心位置。它也有两个同样的 delegate 方法，这两个方法会实现动画的初始化。首先，一旦用户开始拖动控制板时，我们就取消所有动画：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)draggableViewBeganDragging:(DraggableView *)view
{
    [self cancelSpringAnimation];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦停止拖动，我们就根据从拖动手势中得到的最后一个速率值来开始我们的动画。我们根据拖动状态 &lt;code&gt;paneState&lt;/code&gt; 计算出动画的结束位置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)draggableView:(DraggableView *)view draggingEndedWithVelocity:(CGPoint)velocity
{
    PaneState targetState = velocity.y &amp;gt;= 0 ? PaneStateClosed : PaneStateOpen;
    self.paneState = targetState;
    [self startAnimatingView:view initialVelocity:velocity];
}

- (void)startAnimatingView:(DraggableView *)view initialVelocity:(CGPoint)velocity
{
    [self cancelSpringAnimation];
    self.springAnimation = [UINTSpringAnimation animationWithView:view target:self.targetPoint velocity:velocity];
    [view.animator addAnimation:self.springAnimation];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;剩下来要做的就是添加点击动画了，这很简单。一旦我们触发这个状态，就开始动画。如果这里正在进行弹簧动画，我们就用当时的速度作为开始。如果这个弹簧动画是 nil，那么这个开始速度就是 CGPointZero。想要知道为什么依然可以进行动画，可以看看 &lt;code&gt;animationTick:finished:&lt;/code&gt; 里的代码。当这个起始速度为 0 的时候，弹力就会使速度缓慢地增长，直到面板到达目标位置：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)didTap:(UITapGestureRecognizer *)tapRecognizer
{
    PaneState targetState = self.paneState == PaneStateOpen ? PaneStateClosed : PaneStateOpen;
    self.paneState = targetState;
    [self startAnimatingView:self.pane initialVelocity:self.springAnimation.velocity];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;动画驱动&lt;/h3&gt;

&lt;p&gt;最后，我们需要一个 &lt;code&gt;Animator&lt;/code&gt;，也就是动画的驱动者。Animator 封装了 display link。因为每个 display link 都链接一个指定的 &lt;code&gt;UIScreen&lt;/code&gt;，所以我们根据这个指定的 UIScreen 来初始化我们的 animator。我们初始化一个 display link，并且将它加入到 run loop 中。因为现在还没有动画，所以我们是从暂停状态开始的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (instancetype)initWithScreen:(UIScreen *)screen
{
    self = [super init];
    if (self) {
        self.displayLink = [screen displayLinkWithTarget:self selector:@selector(animationTick:)];
        self.displayLink.paused = YES;
        [self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];
        self.animations = [NSMutableSet new];
    }
    return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦我们添加了这个动画，我们要确保这个 display link 不再是停止状态：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)addAnimation:(id&amp;lt;Animation&amp;gt;)animation
{
    [self.animations addObject:animation];
    if (self.animations.count == 1) {
        self.displayLink.paused = NO;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们设置这个 display link 来调用 &lt;code&gt;animationTick:&lt;/code&gt; 方法，在每个 Tick 中，我们都遍历它的动画数组，并且给这些动画数组中的每个动画发送一个消息。如果这个动画数组中已经没有动画了，我们就暂停这个 display link。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt; - (void)animationTick:(CADisplayLink *)displayLink
 {
     CFTimeInterval dt = displayLink.duration;
     for (id&amp;lt;Animation&amp;gt; a in [self.animations copy]) {
         BOOL finished = NO;
         [a animationTick:dt finished:&amp;amp;finished];
         if (finished) {
             [self.animations removeObject:a];
         }
     }
     if (self.animations.count == 0) {
         self.displayLink.paused = YES;
     }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的项目在 &lt;a href=&quot;https://github.com/objcio/issue-12-interactive-animations&quot;&gt;GitHub&lt;/a&gt; 上。&lt;/p&gt;

&lt;h3&gt;权衡&lt;/h3&gt;

&lt;p&gt;我们必须记住，通过 display link 来驱动动画 (就像我们刚才演示的例子，或者我们使用UIkit力学来做的例子，又或者是使用 Facebook 的 Pop 框架) 是有代价需要进行权衡的。就像 &lt;a href=&quot;https://twitter.com/andy_matuschak/status/464790108072206337&quot;&gt;Andy Matuschar 指出的&lt;/a&gt;那样，UIView 和 CAAnimation 动画比其他任务更少受系统的影响，因为比起你的应用来说，渲染处于更高的优先级。&lt;/p&gt;

&lt;h2&gt;回到 Mac&lt;/h2&gt;

&lt;p&gt;现在 Mac 中还没有 UIKit 力学。如果你想在 Mac 中创建一个真实的交互式动画，你必须自己去实现这些动画。我们已经向你展示了如何在 iOS 中实现这些动画，所以在 OS X 中实现相似的功能也是非常简单的。你可以查看在 GitHub 中的&lt;a href=&quot;https://github.com/objcio/issue-12-interactive-animations-osx&quot;&gt;完整项目&lt;/a&gt;，如果你想要应用到 OS X 中，这里还有一些地方需要修改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一个要修改的就是 &lt;code&gt;Animator&lt;/code&gt;。在Mac中没有 &lt;code&gt;CADisplayLink&lt;/code&gt;，但是取而代之的有 &lt;code&gt;CVDisplayLink&lt;/code&gt;，它是以 C 语言为基础的 API。创建它需要做更多的工作，但也是很直接。&lt;/li&gt;
&lt;li&gt;iOS 中的弹簧动画是基于调整 view 的中心位置来实现的。而 OS X 中的 &lt;code&gt;NSView&lt;/code&gt; 类没有 center 这个属性，所以我们用为 frame 中的 origin 做动画来代替。&lt;/li&gt;
&lt;li&gt;在 Mac 中是没有手势识别，所以我要在我们自定义的 view 子类中实现 &lt;code&gt;mouseDown:&lt;/code&gt;，&lt;code&gt;mouseUp:&lt;/code&gt; 和 &lt;code&gt;mouseDragged:&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面就是我们需要在 Mac 中使用我们的动画效果在代码所需要做的修改。对于像这样的简单 view，它能很好的胜任。但对于更复杂的动画，你可能就不会想通过为 frame 做动画来实现了，我们可以用 &lt;code&gt;transform&lt;/code&gt; 来代替，浏览 Jonathan Willing 写的关于 &lt;a href=&quot;http://jwilling.com/osx-animations&quot;&gt;OS X 动画&lt;/a&gt;的博客，你会获益良多。&lt;/p&gt;

&lt;h3&gt;Facebook 的 POP 框架&lt;/h3&gt;

&lt;p&gt;上个星期围绕着 Facebook 的 &lt;a href=&quot;https://github.com/facebook/pop&quot;&gt;POP 框架&lt;/a&gt;的讨论络绎不绝。POP 框架是 Paper 应用背后支持的动画引擎。它的操作非常像我们上面讲的驱动动画的例子，但是它以非常灵活的方式巧妙地封装到了一个程序包中。&lt;/p&gt;

&lt;p&gt;让我们动手用 POP 来驱动我们的动画吧。因为我们自己的类中已经封装了弹簧动画，这些改变就非常简单了。我们所要做的就是初始化一个 POP 动画来代替我们刚才自己做的动画，并将下面这段代码加入到 view
 中：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (void)animatePaneWithInitialVelocity:(CGPoint)initialVelocity
{
    [self.pane pop_removeAllAnimations];
    POPSpringAnimation *animation = [POPSpringAnimation animationWithPropertyNamed:kPOPViewCenter];
    animation.velocity = [NSValue valueWithCGPoint:initialVelocity];
    animation.toValue = [NSValue valueWithCGPoint:self.targetPoint];
    animation.springSpeed = 15;
    animation.springBounciness = 6;
    [self.pane pop_addAnimation:animation forKey:@&amp;quot;animation&amp;quot;];
    self.animation = animation;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以在 &lt;a href=&quot;https://github.com/objcio/issue-12-interactive-animations-pop&quot;&gt;GitHub&lt;/a&gt; 中找到使用 POP 框架的完整例子。&lt;/p&gt;

&lt;p&gt;让其工作非常简单，并且通过它我们可以实现很多更复杂的动画。但是它真正强大的地方在于它能够实现真正的可交互和可中断的动画，就像我们上面提到的那样，因为它直接支持以速度作为输入参数。如果你打算从一开始到被中断这过程中的任何时候都能交互，像 POP 这样的框架就能帮你实现这些动画，并且它能始终保证动画一直很平滑。&lt;/p&gt;

&lt;p&gt;如果你不满足于用 &lt;code&gt;POPSpringAnimation&lt;/code&gt; 和 &lt;code&gt;POPDecayAnimation&lt;/code&gt; 的开箱即用的处理方式的话，POP 还提供了 &lt;code&gt;POPCustomAnimation&lt;/code&gt; 类，它基本上是一个 display link 的方便的转换，来在动画的每一个 tick 的回调 block 中驱动你自己的动画。&lt;/p&gt;

&lt;h2&gt;展望未来&lt;/h2&gt;

&lt;p&gt;随着 iOS7 中从对拟物化的视觉效果的远离，以及对 UI 行为的关注，真实的交互式动画通向未来的大道变得越来越明显。它们也是将初代 iPhone 中滑动行为的魔力延续到交互的各个方面的一条康庄大道。为了让这些魔力成为现实，我们就不能在开发过程中才想到这些动画，而是应该在设计时就要考虑这些交互，这一点非常重要。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/ios/interactive_animations/&quot;&gt;交互式动画&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on May 17, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Objective-C的命名空间]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/ios/namespacing/" />
  <id>http://morisunshine.com/ios/namespacing</id>
  <published>2014-04-24T00:00:00+08:00</published>
  <updated>2014-04-24T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;本文由&lt;a href=&quot;http://morisunshine.com/&quot;&gt;morisunshine&lt;/a&gt;译自&lt;a href=&quot;http://nshipster.com/namespacing/&quot;&gt;&amp;quot;Namespacing&amp;quot;&lt;/a&gt;。转载请注明出处！&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么Objecive-C中的很多类名都是&lt;code&gt;NS&lt;/code&gt;开头的呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我保证在你第一次给别人介绍Objective-C的时候肯定会听到这句话。&lt;/p&gt;

&lt;p&gt;就像父母要向孩子解释什么是死亡或者圣诞老人是不存在的问题一样，父母总是寄希望时间会让孩子自己找到答案。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;你既然这么问了，实际上&lt;code&gt;NS&lt;/code&gt;代表了&lt;code&gt;NeXTSTEP&lt;/code&gt;（好吧，其实是代表&lt;code&gt;NeXTSTEP/Sun&lt;/code&gt;，我们只是做个简单的介绍），它被用于...&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你越解释，你会发现对方越失望*，接下来，他们不在只是随便问问了，他们开始问一些你更难解释的问题--在Objective-C中&lt;a href=&quot;http://nshipster.com/at-compiler-directives/&quot;&gt;@&lt;/a&gt;是什么？&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;命名一直是Objective-C的硬伤，和那些优雅的语言相比，Objective-C缺乏标识符容器这点引来了很多不切实际的批评家。&lt;/p&gt;

&lt;p&gt;他们总是说：Objective-C不像其他流行语言一样提供模块化机制来避免类名和方法名的冲突。&lt;/p&gt;

&lt;p&gt;相反地，Objective-C 依靠前缀来确保APP中的方法名不会影响其他有相同名字的代码。&lt;/p&gt;

&lt;p&gt;插入一个关于类型系统的题外话之后我们会继续进入关于命名的讨论。&lt;/p&gt;

&lt;h2&gt;C和Objective-C中的类型&lt;/h2&gt;

&lt;p&gt;我曾在这个博客上多次提过Objective-C是直接建立在C语言之上的，一个重要的原因是Objective-C和C语言共用一个类型系统，他们都要求标识符是全局唯一的。&lt;/p&gt;

&lt;p&gt;你可以自己定义一个和&lt;code&gt;@interface&lt;/code&gt;同名的静态变量，编译之后你会得到一个错误：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;@interface XXObject : NSObject
@end

static char * XXObject;//将“XXObject”重新定义为不同的符号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说，Objective-C的runtime在C语言的类型系统上又创建了一个抽象层，它甚至可以允许下面这段代码被编译:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;@protocol Foo
@end

@interface Foo : NSObject &amp;lt;Foo&amp;gt; {
    id Foo;
}

@property id Foo;
+ (id)Foo;
- (id)Foo;
@end

@interface Foo (Foo)
@end

@implementation Foo
@synthesize Foo;

+ (id)Foo {
    id Foo = @&amp;quot;Foo&amp;quot;;
    return Foo;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;通过Objective-C的环境，程序能区别所有相同名字的类，协议，类别，实例变量，实例方法和类方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;一个变量能重新调整一个已经存在的方法也是得益与C语言的类型系统（这个有点像一个变量能够隐藏它的隐藏功能）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;前缀&lt;/h2&gt;

&lt;p&gt;在Objective-C应用中的所有类名都必须是全局唯一的。由于很多不同的框架中会有一些相似的功能，所以在名字上也可能会有重复（users， views， requests / responses 等等），所以&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html&quot;&gt;苹果官方文档&lt;/a&gt;规定类名需要有2-3个字母作为前缀。&lt;/p&gt;

&lt;h3&gt;类前缀&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html&quot;&gt;苹果官方建议&lt;/a&gt;两个字母作为前缀的类名是为官方的库和框架准备的，而对于作为第三方开发者的我们，官方建议使用3个或者更多的字母作为前缀去命名我们的类。&lt;/p&gt;

&lt;p&gt;一个资深的Mac或iOS开发者可能会记得下面大部分的缩写标识符：&lt;/p&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Prefix&lt;/th&gt;
            &lt;th&gt;Frameworks&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;AB&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;AddressBook / AddressBookUI&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;AC&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;Accounts&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;AD&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;iAd&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;AL&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;AssetsLibrary&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;AU&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;AudioUnit&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;AV&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;AVFoundation&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;CA&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;CoreAnimation&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;CB&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;CoreBluetooth&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;CF&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;CoreFoundation / CFNetwork&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;CG&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;CoreGraphics / QuartzCore / ImageIO&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;CI&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;CoreImage&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;CL&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;CoreLocation&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;CM&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;CoreMedia / CoreMotion&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;CV&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;CoreVideo&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;EA&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;ExternalAccessory&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;EK&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;EventKit / EventKitUI&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;GC&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;GameController&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;GLK&lt;/tt&gt;&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;GLKit&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;JS&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;JavaScriptCore&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;MA&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;MediaAccessibility&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;MC&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;MultipeerConnectivity&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;MF&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;MessageUI*&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;MIDI&lt;/tt&gt;&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;CoreMIDI&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;MK&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;MapKit&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;MP&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;MediaPlayer&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;NK&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;NewsstandKit&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;NS&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;Foundation, AppKit, CoreData&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;PK&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;PassKit&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;QL&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;QuickLook&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;SC&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;SystemConfiguration&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;Sec&lt;/tt&gt;&lt;sup&gt;*&lt;/sup&gt;&lt;/td&gt;&lt;td&gt;Security*&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;SK&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;StoreKit / SpriteKit&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;SL&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;Social&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;SS&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;Safari Services&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;TW&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;Twitter&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;UI&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;UIKit&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;UT&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;MobileCoreServices&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4&gt;第三方类前缀&lt;/h4&gt;

&lt;p&gt;直到最近，由于&lt;a href=&quot;http://cocoapods.org/&quot;&gt;CocoaPods&lt;/a&gt;的出现和大量新的iOS开发者的涌现，开源代码的遍布，第三方代码在很大程度上对苹果和其余的Objective-C开发社区来说已经不是问题了。最近苹果官方的命名指南也发生了变化，它将三个字母作为前缀的建议只是做为一个习惯做法。&lt;/p&gt;

&lt;p&gt;正因为这样，那些已经存在的第三方库依然使用2个字母作为前缀，你可以参考一些那些&lt;a href=&quot;https://github.com/search?l=Objective-C&amp;amp;q=stars%3A%3E1&amp;amp;s=stars&amp;amp;type=Repositories&quot;&gt;在GitHub上得到很多start的Objective-C的仓库&lt;/a&gt;。&lt;/p&gt;

&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;Prefix&lt;/th&gt;
            &lt;th&gt;Frameworks&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;AF&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot;&gt;AFNetworking&lt;/a&gt; (&quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Gowalla&quot;&gt;Alamofire&lt;/a&gt;&quot;)&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;RK&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/RestKit/RestKit&quot;&gt;RestKit&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;GPU&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/BradLarson/GPUImage&quot;&gt;GPUImage&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;SD&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;MB&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/jdg/MBProgressHUD&quot;&gt;MBProgressHUD&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;FB&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/facebook/facebook-ios-sdk&quot;&gt;Facebook SDK&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;FM&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/ccgus/fmdb&quot;&gt;FMDB&lt;/a&gt; (&quot;&lt;a href=&quot;http://flyingmeat.com&quot;&gt;Flying Meat&lt;/a&gt;&quot;)&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;JK&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/johnezang/JSONKit&quot;&gt;JSONKit&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;FUI&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/Grouper/FlatUIKit&quot;&gt;FlatUI&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;NI&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/jverkoey/nimbus&quot;&gt;Nimbus&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;td&gt;&lt;tt&gt;RAC&lt;/tt&gt;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot;&gt;Reactive Cocoa&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我们已经看到在在这个&lt;a href=&quot;https://github.com/AshFurrow/AFTabledCollectionView&quot;&gt;第三方库&lt;/a&gt;的前缀已经和我的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot;&gt;AFNetworking&lt;/a&gt;一样了，所以最好还是要在你的代码中遵守要三个字母以上的作为类前缀的规定(https://github.com/AshFurrow/AFTabledCollectionView)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于那些针对特殊功能而写的第三方库的作者，可以考虑在下一次主要升级时使用&lt;a href=&quot;http://nshipster.com/at-compiler-directives/&quot;&gt;@compatibility_alias&lt;/a&gt;来为那些使用者们提供一个天衣无缝的转移路径。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;方法前缀&lt;/h2&gt;

&lt;p&gt;不仅是类容易造成命名冲突，selectors也很容易造成命名冲突，甚至方法比类会有更多的问题。
考虑一下这个category：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;@interface NSString (PigLatin)
- (NSString *)pigLatinString;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 &lt;code&gt;-pigLatinString&lt;/code&gt;方法被另一个category实现了（或者以后版本的iOS或者Mac OS X 在NSString类中也添加了同样名字的方法），那么调用这个方法就会得到未定义的行为错误，因为我们不能保证在runtime中哪个方法会先被定义。&lt;/p&gt;

&lt;p&gt;我们可以通过在方法名前加前缀来避免这个问题，就像加这个类名一样（在类别名前加前缀也是个好办法）：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;@interface NSString (XXXPigLatin)
- (NSString *)xxx_pigLatinString;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;苹果官方建议&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW4&quot;&gt;所有category方法都要使用前缀&lt;/a&gt;，这个建议比类名需要加前缀的规定更加广为人知和接受。&lt;/p&gt;

&lt;p&gt;很多开发者都在热情地讨论着这个规定的某一方面。然而，无论是通过成本角度还是效益角度来衡量命名冲突风险的可能性都是是不全面的:&lt;/p&gt;

&lt;p&gt;category的主要功能是通过语法糖将一些有用的功能包裹进原来的类中。任何一个category方法都可以被选择性实现，你也可以把他当做是self的一个隐型功能方法。&lt;/p&gt;

&lt;p&gt;当我在编译器的环境参数中将&lt;code&gt;OBJC_PRINT_REPLACED_METHODS&lt;/code&gt;这个参数设置为YES，那我们就能在编译的时候检测方法名是否有冲突。实际上，方法名的冲突是很少发生的，而且在发生的时候，他们通常会得到一个&lt;code&gt;needlessly duplicated across dependencies&lt;/code&gt;的提示。即使发生最坏的情况，程序在运行是出现异常，那么很可能是两个方法名一样，那么他们&lt;em&gt;做&lt;/em&gt;的事情也是一样的，所以结果也不会有什么变化。就像Swiss Army Knife写了一个category，他定义了&lt;code&gt;NSArray&lt;/code&gt;中的&lt;code&gt;-firstObject&lt;/code&gt;这个方法，那么只要苹果官方没有在&lt;code&gt;NSArray&lt;/code&gt;中加这个方法的话，那么这个类别方法一直有效的。&lt;/p&gt;

&lt;p&gt;在苹果官方的编程指南中有很多严肃又松散的解释。这里没有固定的文档，他们可能一直变化。看到这里，如果你还是悬而未决，那么你只需要把的category方法名加上前缀，如果你还是选择不去做任何改变，那么你就等着自食其果吧。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;继续添加“category 方法”到你的Tweetbot条款。有效期:一个星期&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Swizzling&lt;/h3&gt;

&lt;p&gt;在Swizzling时，方法名加前缀或者后缀也是非常有必要的，这个我在上周关于&lt;a href=&quot;http://nshipster.com/method-swizzling/&quot;&gt;swizzling&lt;/a&gt;的文章中提到过。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;@implementation UIViewController (Swizzling)

- (void)xxx_viewDidLoad {
    [self xxx_viewDidLoad];

    // Swizzled implementation
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;我们真的需要命名空间么？&lt;/h2&gt;

&lt;p&gt;在最近关于Objective-C替换、改造和重塑的讨论中，我可以明显地发现命名空间是未来的一个趋势。但是它到底给我们带来了什么呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;美学&lt;/strong&gt;？除了IETE成员和军事人员，我想没有人会喜欢&lt;acronym title=&quot;CAPITAL LETTER ACRONYMS&quot;&gt;CLA&lt;/acronym&gt;s的视觉审美，但是用&lt;code&gt;::&lt;/code&gt;，&lt;code&gt;/&lt;/code&gt;或者另外的&lt;code&gt;.&lt;/code&gt;这些符号真的能让我们觉得更好么？你&lt;em&gt;真的&lt;/em&gt;想要以后把&lt;code&gt;NSArray&lt;/code&gt;叫做&amp;quot;Foundation Array&amp;quot;？（那我这个NSHipster.com这个博客不是也得改名字了?!）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语义学&lt;/strong&gt;？让我们比较一下其他的语言，看看他们是怎么用命名空间的，那么你就会意识到命名空间不能解决所有不明确的问题。可能在某些额外环境的情况下，那些命名空间会出现更多问题。&lt;/p&gt;

&lt;p&gt;你还是不赞同，那么你想象一下Objective-C的命名空间的实现可能会像这个样子，你会觉得怎么样:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;@namespace XX
    @implementation Object

    @using F: Foundation;

    - (void)foo {
        F:Array *array = @[@1,@2, @3];

        // ...
    }

    @end
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然Objective-C有繁琐的代码但也有容易理解的明显优点。我们作为开发者去讨论&lt;code&gt;NSString&lt;/code&gt;的时候，我们不会把它理解成别的意思，编译器也是一样。当我们在阅读代码时，我们不需要过多地去考虑这些代码是什么作用的。并且最重要的是，NSString这个类名在google这些搜索引擎中&lt;a href=&quot;http://lmgtfy.com/?q=NSString&quot;&gt;很容易就可以找到， 你不会得到其他结果&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;不管怎样，如果你对这个讨论感兴趣的话，我强烈建议你看一下&lt;a href=&quot;http://optshiftk.com/&quot;&gt;Kyle Sluder&lt;/a&gt;的&lt;a href=&quot;http://optshiftk.com/2012/04/draft-proposal-for-namespaces-in-objective-c/&quot;&gt;this namespace feature proposal&lt;/a&gt;。非常值得一看。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/ios/namespacing/&quot;&gt;Objective-C的命名空间&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on April 24, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[iOS编码规范参考]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/ios/ios_code_standards/" />
  <id>http://morisunshine.com/ios/ios_code_standards</id>
  <published>2014-04-22T00:00:00+08:00</published>
  <updated>2014-04-22T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;h2&gt;注释&lt;/h2&gt;

&lt;p&gt;建议使用&lt;a href=&quot;https://github.com/onevcat/VVDocumenter-Xcode&quot;&gt;VVDocumenter&lt;/a&gt;插件&lt;/p&gt;

&lt;h3&gt;多行注释&lt;/h3&gt;

&lt;p&gt;格式:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;/**

              注释内容
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;单行注释&lt;/h3&gt;

&lt;p&gt;格式:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;///在对文件、类、函数进行注释时推荐使用多行注释，在函数体内对代码块进行注释时，使用单行注释
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;函数的注释&lt;/h3&gt;

&lt;p&gt;函数注释的格式为&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;/**
 *  @brief  
 *  @param
 *  @return
 **/
 在brief中需要写明函数的主要功能、注意事项
 在param中需要写明函数的变量类型、变量的作用
 在return中需要写明函数的返回类型、返回值的作用
 如有其他需要说明的地方，可以在@return后面添加新项。如
 /**
 *  @brief  
 *  @param
 *  @return
 *  @warning
 **/

/**
 *  @brief      上传图片。上传成功后会自动将图片放入缓存，缓存的key为图片的url
 *  @param      UIImage，需要上传的图片
 *  @return     void
 *  @blocks
 *              success:返回的NSDictionary中包含服务器的response信息，包括图片id（id）,url(url),宽度(width),高度(height)。使用括号中的名称从NSDictionary中获取。
 *              failed:返回error
 **/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;命名&lt;/h2&gt;

&lt;h3&gt;常量的命名&lt;/h3&gt;

&lt;p&gt;(如宏、枚举、静态局部变量等)应该以小写字母k开头，使用混合大小写的格式来分隔单词。&lt;/p&gt;

&lt;h3&gt;函数的命名&lt;/h3&gt;

&lt;p&gt;函数名应该已小写字母开头，并混合大小写，其中的每个参数都应该是小写字母开头，读起来应该像句子一样，访问器方法应该与他们getting的成员变量的名字一样，但不应该以get作为前缀，如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;  - (id)getDelegate;    //avoid
  - (id)delegate;       //good
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;变量的命名&lt;/h3&gt;

&lt;p&gt;成员变量应该已小写字母开头，并以下划线作为后缀，如usernameTextField_,使用KVO/KVC绑定成员变量时，可以以一个下划线为前缀。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;公共变量命名:
小写字母开头。如:imageView;&lt;/p&gt;

&lt;p&gt;实例变量命名:&lt;/p&gt;

&lt;p&gt;私有变量:
应该以下划线开头。如:_addButton&lt;/p&gt;

&lt;p&gt;常量命名:
以小写k开头，混合大小写。如:kInvalidHandle, kWritePerm&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;图片的命名&lt;/h3&gt;

&lt;p&gt;应该已“模块+功能+作用+样式”的形式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:message_private_at_button_bg_normal.png
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;类的命名&lt;/h3&gt;

&lt;p&gt;类名、分类名、协议名应该以大写字母开始，并混合小写字母来分隔单词，应该已“模块+功能+子功能”的方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:MessagePrivateAtsomebody
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应用级的类，应避免不用前缀，跨应用级的类，应使用前缀，
&lt;code&gt;objc
如:GTMSendMessage
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;分类名&lt;/h2&gt;

&lt;p&gt;类别名应该有两三个字母作为前缀已表示为某项目的一部分，并且包含所扩展的类的名字，如我们要创建一个NSString的类别以解析，我们将类别放在一个名为GTMNSString+Parsing.h的文件中。类别名本身为GTMStringParsingAdditions(类别名与文件名不同是为了让文件可以包含更多相同功能的扩展)类名与包含类别名之间应一个空格分隔。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
//NSString 为要扩展的类名, GTMStringParsingAdditions为类别名
@interface NSString (GTMStringParsingAdditions)
        - (NSString *)gtm_foobarString;
        @end

        @interface FoobarViewController ()
        @property(nonatomic, retain) NSView *dongleView;
        - (void)performLayout;
        @end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;注意事项&lt;/h2&gt;

&lt;h3&gt;条件语句&lt;/h3&gt;

&lt;p&gt;为避免错误，条件语句体必须使用大括号，即便语句体中的语句可以不必使用大括号（比如只有一行语句）。常见的错误包括在不使用大括号的情况下添加第二行语句，以为它属于if语句的一部分。此外，更可怕的事情是，如果条件语句中的代码行被注释，则本不术语条件语句的下一行代码将变成条件语句的一部分。此外，这种编码风格和所有其它条件语句均保持一致。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
if (!error) {
    return success;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;变量&lt;/h3&gt;

&lt;p&gt;变量的命名应尽可能具有自解释性。除了在for()循环语句中，应避免使用单个字母变量名称。
除非是常量，星号应紧贴变量名称表示指向变量的指针，
&lt;code&gt;objc
如:
NSString *text;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;应尽可能使用属性定义替代单一的实例变量。避免在初始化方法,dealloc方法和自定义的setter和getter方法中直接读取实例变量参数（init,initWithCoder:，等等）&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
@interface NYTSection: NSObject

@property (nonatomic) NSString *headline;

@end

应尽量避免下面的方式:

@interface NYTSection : NSObject {
    NSString *headline;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;下划线&lt;/h3&gt;

&lt;p&gt;当使用属性变量时，应通过self.来获取和更改实例变量。这就意味着所有的属性将是独特的，因为它们的名称前会加上self。本地变量名称中不应包含下划线&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
self.imgView.backgroundColor = [UIColor black];

而尽量避免:

_imgView.backgroundColor = [UIColor black];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Immutable实例初始化&lt;/h3&gt;

&lt;p&gt;在创建NSString,NSDictionary,NSArray和NSNumber等对象的immutable实例时，应使用字面量。需要注意的是，不应将&lt;strong&gt;&lt;em&gt;nil&lt;/em&gt;&lt;/strong&gt;传递给NSArray和NSDictionary字面量，否则会引起程序崩溃。所以在存入数据到NSArray和NSDictionary时也要判断一下数据是否是nil。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;NSArray *names = @[@&amp;quot;Brian&amp;quot;, @&amp;quot;Matt&amp;quot;, @&amp;quot;Chris&amp;quot;, @&amp;quot;Alex&amp;quot;, @&amp;quot;Steve&amp;quot;, @&amp;quot;Paul&amp;quot;];
NSDictionary *productManagers = @{@&amp;quot;iPhone&amp;quot; : @&amp;quot;Kate&amp;quot;, @&amp;quot;iPad&amp;quot; : @&amp;quot;Kamal&amp;quot;, @&amp;quot;Mobile Web&amp;quot; : @&amp;quot;Bill&amp;quot;};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingZIPCode = @10018;

不恰当:
NSArray *names = [NSArray arrayWithObjects:@&amp;quot;Brian&amp;quot;, @&amp;quot;Matt&amp;quot;, @&amp;quot;Chris&amp;quot;, @&amp;quot;Alex&amp;quot;, @&amp;quot;Steve&amp;quot;, @&amp;quot;Paul&amp;quot;, nil];
NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&amp;quot;Kate&amp;quot;, @&amp;quot;iPhone&amp;quot;, @&amp;quot;Kamal&amp;quot;, @&amp;quot;iPad&amp;quot;, @&amp;quot;Bill&amp;quot;, @&amp;quot;Mobile Web&amp;quot;, nil];
NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
NSNumber *ZIPCode = [NSNumber numberWithInteger:10018];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;类型&lt;/h3&gt;

&lt;p&gt;最好用NSInteger和NSUInteger而不是用int，long。其他的float同理。&lt;/p&gt;

&lt;h3&gt;CGRect函数&lt;/h3&gt;

&lt;p&gt;当需要获取一个CGRect矩形的x,y,width,height属性时，应使用CGGeometry函数，而非直接访问结构体成员。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如：
CGRect frame = self.view.frame;

CGFloat x = CGRectGetMinX(frame);
CGFloat y = CGRectGetMinY(frame);
CGFloat width = CGRectGetWidth(frame);
CGFloat height = CGRectGetHeight(frame);

不恰当：
CGRect frame = self.view.frame;

CGFloat x = frame.origin.x;
CGFloat y = frame.origin.y;
CGFloat width = frame.size.width;
CGFloat height = frame.size.height;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;常量&lt;/h3&gt;

&lt;p&gt;相对字符串字面量或数字，我们更推荐适用常量。应使用static方式声明常量，而非使用#define的方式来定义宏。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;例如：
static NSString * const NYTAboutViewControllerCompanyName = @&amp;quot;The New York Times Company&amp;quot;;  
static const CGFloat NYTImageThumbnailHeight = 50.0;

不恰当:
//#define CompanyName @&amp;quot;The New York Times Company&amp;quot;
//#define thumbnailHeight 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;枚举类型&lt;/h3&gt;

&lt;p&gt;在使用enum的时候，推荐适用最新的fixed underlying type(WWDC 2012 session 405- Modern Objective-C)规范，因为它具备更强的类型检查和代码完成功能。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如：
typedef NS_ENUM(NSInteger, NYTAdRequestState) {
    NYTAdRequestStateInactive,
    NYTAdRequestStateLoading
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;布尔变量&lt;/h3&gt;

&lt;p&gt;因为nil将被解析为NO，因此没有必要在条件语句中进行比较。永远不要将任何东西和YES进行直接比较，因为YES被定义为1，而一个BOOL变量可以有8个字节。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如：
if (!someObject) {
}

if (isAwesome)

if (![someObject boolValue])

不恰当：
if (someObject == nil) {
}

if ([someObject boolValue] == NO)

if (isAwesome == YES) // Never do this.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果一个BOOL属性使用形容词来表达，属性将忽略’is’前缀，但会强调惯用名称。
例如：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;@property (assign, getter=isEditable) BOOL editable;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;单例&lt;/h3&gt;

&lt;p&gt;在创建单例对象的共享实例时，应使用线程安全模式。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如：
(instancetype)sharedInstance {
   static id sharedInstance = nil;

   static dispatch_once_t onceToken;
   dispatch_once(&amp;amp;onceToken, ^{
      sharedInstance = [[self alloc] init];
   });

   return sharedInstance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;数字&lt;/h3&gt;

&lt;p&gt;尽量避免数字固定为某个类型如:写5而不写5.0，5.3而不写5.3f)&lt;/p&gt;

&lt;h3&gt;代码组织&lt;/h3&gt;

&lt;p&gt;用 &lt;code&gt;#pragma mark&lt;/code&gt;来将方法分类，这个非常有效，当你用快捷键&lt;code&gt;Control+6&lt;/code&gt;可以高效的寻找到自己想要跳转到的方法&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;//#pragma mark Properties

@dynamic someProperty;

- (void)setCustomProperty:(id)value {}

#pragma mark Lifecycle

+ (id)objectWithThing:(id)thing {}
- (id)init {}

#pragma mark Drawing

#pragma mark UItableView delegate

#pragma mark UITableView datasource

- (void)drawRect:(CGRect) {}

#pragma mark Another functional grouping

#pragma mark GHSuperclass

- (void)someOverriddenMethod {}

#pragma mark NSCopying

- (id)copyWithZone:(NSZone *)zone {}

#pragma mark NSObject

- (NSString *)description {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;判断语句&lt;/h3&gt;

&lt;p&gt;if和else应该和左大括号在同一行&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
if (button.enabled) {
    // Stuff
} else if (otherButton.enabled) {
    // Other stuff
} else {
    // More stuf
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Switch 也是一样&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
switch (something.state) {
    case 0: {
        // Something
        break;
    }

    case 1: {
        // Something
        break;
    }

    case 2:
    case 3: {
        // Something
        break;
    }

    default: {
        // Something
        break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Import&lt;/h3&gt;

&lt;p&gt;在类的头文件中需要引用其他的类的时候，需要用&lt;code&gt;@class&lt;/code&gt;这个关键字，这样能减少类与类之间的依赖。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
store.h:

#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;lt;CoreData/CoreData.h&amp;gt;

@class User;

@interface Store : NSManagedObject

@property (nonatomic, retain) User *user;

@end

Store.m:

#import &amp;quot;Store.h&amp;quot;

#import &amp;quot;User.h&amp;quot;

@implementation Store

//doSomething

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;私有方法&lt;/h3&gt;

&lt;p&gt;关于私有方法，苹果官方建议呢是是使用统一的前缀来分组和辨识。但是千万不用用下划线来作为前缀来命名，或者你可以在前缀前添加一些特殊的标识。&lt;/p&gt;

&lt;h2&gt;git commit 格式&lt;/h2&gt;

&lt;p&gt;可以参考&lt;a href=&quot;https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#&quot;&gt;google开源项目的Commit 规范&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考规范:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;添加了新功能&lt;/strong&gt; &lt;code&gt;feat(大模块+子模块):#例如实现了某个具体功能&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修改了某些功能&lt;/strong&gt;  &lt;code&gt;change(大模块+子模块):#例如修改了某个具体的功能&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;修复了某个Bug&lt;/strong&gt;  &lt;code&gt;fix_bug(大模块+子模块):#修复了什么的bug，最好写上*原因*和*解决方法*。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;比较大的改动&lt;/strong&gt;
```
broken_change():
before: &lt;/p&gt;

&lt;p&gt;after:
```&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;修改了文档&lt;/strong&gt; &lt;code&gt;docs():&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;修改了格式&lt;/strong&gt; &lt;code&gt;style():&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;添加了一些测试&lt;/strong&gt; &lt;code&gt;test(大模块+子模块):&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;一些杂项，比如像解决工程编译错误等问题之后的修改&lt;/strong&gt; &lt;code&gt;chore():&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;对又有代码的重构&lt;/strong&gt; &lt;code&gt;refactor(大模块+子模块):&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;格式&lt;/h2&gt;

&lt;p&gt;一行代码的长度不能超过80个字母&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数声明和定义:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“-”或“+”和返回类型之间应该有一个空格&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
- (void)doSomethingWithString:(NSString *)theString {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法大括号和其它大括号（比如if/else/switch/while等等）应在语句的同一行开始，而在新的一行关闭。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;if (user.isHappy) {
//Do something
}
else {
//Do something else
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当有多个参数的时，如果参数太多超过一行，则应该将每个参数分行，并且冒号对齐&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
- (void)doSomethingWith:(GTMFoo *)theFoo
                   rect:(NSRect)theRect
               interval:(float)theInterval {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当第一个参数短于其他参数的时候，分行时每行至少要缩进4个空格&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;             longKeyword:(NSRect)theRect
       evenLongerKeyword:(float)theInterval
                   error:(NSError **)theError {
          ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;方法调用&lt;/h3&gt;

&lt;p&gt;方法调用应该和方法声明的时候一个格式,要么所有参数放在一行里:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;[myObject doFooWith:arg1 name:arg2 error:arg3];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要么每一行一个参数:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
[myObject doFooWith:arg1
               name:arg2
              error:arg3];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当第一个参数短语其他参数的时候，分行是每行至少要缩进4个空格:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
[myObj short:arg1
          longKeyword:arg2
    evenLongerKeyword:arg3
                error:arg4];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@public 和 @private前面为一个空格&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
@interface MyClass : NSObject{
 @public
 …
 @private
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;协议&lt;/h3&gt;

&lt;p&gt;类型与协议名之间不要空格&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;如:
@interface MyProtocoledClass : NsObject&amp;lt;NSWindowDelegate&amp;gt; {
 @private
  id&amp;lt;MyFancyDelegate&amp;gt; _delegate;
}
-  (void)setDelegate:(id&amp;lt;MyFancyDelegate&amp;gt;)aDelegate;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Blocks&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;在一行的情况
如:
[operation setCompletionBlock:^{ [self onOperationDone]; }];

//block 在新的行里，需要缩进四个空格
[operation setCompletionBlock:^{
      [self.delegate newDataAvailable];
}];

dispatch_async(_fileIOQueue, ^{
      NSString* path = [self sessionFilePath];
      if (path) {
        // ...
      }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;//有参数的block,|(SessionWindow *window)|与|{|之间有一个空格
如:
[[SessionService sharedService]
    loadWindowWithCompletionBlock:^(SessionWindow *window) {
        if (window) {
          [self windowDidLoad:window];
        } else {
          [self errorLoadingWindow];
        }
    }];

//block 中有参数且不能在一行中显示
//要行与行之间要相对有四个空格
[[SessionService sharedService]
      loadWindowWithCompletionBlock:
            ^(SessionWindow *window) {
                   if (window) {
                     [self windowDidLoad:window];
                   } else {
                     [self errorLoadingWindow];
                   }
            }];

//很长的block可以被定义不在一行里
void (^largeBlock)(void) = ^{
    // ...
};
[_operationQueue addOperationWithBlock:largeBlock];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/ios/ios_code_standards/&quot;&gt;iOS编码规范参考&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on April 22, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[@property中attribute的整理]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/ios/Property_of_Objective_C/" />
  <id>http://morisunshine.com/ios/Property_of_Objective_C</id>
  <published>2014-04-16T00:00:00+08:00</published>
  <updated>2014-04-16T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&lt;code&gt;assign&lt;/code&gt;:指定setter方法用简单的赋值，这是默认操作。你可以对标量类型（如int）使用这个属性。你可以想象一个float，它不是一个对象，所以它不能retain、copy。可以简单赋值，不更改索引计数(Reference Counting)。使用assign: 对基础数据类型 （NSInteger）和C数据类型（int, float, double, char,等）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;retain&lt;/code&gt;:指定retain应该在后面的对象上调用，前一个值发送一条release消息。你可以想象一个NSString实例，它是一个对象，而且你可能想要retain它。
 释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1 ，使用retain： 对其他NSObject和其子类 ，retain，是说明该属性在赋值的时候，先release之前的值，然后再赋新值给属性，引用再加1。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;copy&lt;/code&gt;:指定应该使用对象的副本（深度复制），前一个值发送一条release消息。基本上像retain，但是没有增加引用计数，是分配一块新的内存来放置它。copy是创建一个新对象，retain是创建一个指针，引用对象计数加1。copy：建立一个索引计数为1的对象，然后释放旧对象，copy是创建一个新对象，retain是创建一个指针，引用对象计数加1。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;readonly:&lt;/code&gt;将只生成getter方法而不生成setter方法（getter方法没有get前缀)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;readwrite&lt;/code&gt;:默认属性，将生成不带额外参数的getter和setter方法（setter方法只有一个参数）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;atomic&lt;/code&gt;:对于对象的默认属性，就是setter/getter生成的方法是一个原子操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter的情况，相关于方法头尾加了锁一样。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nonatomic&lt;/code&gt;:不保证setter/getter的原子性，多线程情况下数据可能会有问题。nonatomic，非原子性访问，不加同步，多线程并发访问会提高性能。先释放原先变量，再将新变量retain然后赋值；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strong&lt;/code&gt;:ARC中默认的方式是Strong，所以一般情况下，你是不需要写Strong的，strong关键字与retain关似，用了它，引用计数自动＋1。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;weak&lt;/code&gt;:weak所指向的指针顾名思义，只有很多的引用关系，当指向的内存地址被释放掉，weak指针也就会被释放掉了，这些指针都将被赋值为nil，这样的好处能有效的防止野指针&lt;/p&gt;

&lt;p&gt;&lt;code&gt;unsafe_unretained&lt;/code&gt;:unsafe_unretained与weak有点类似，但是当所指向的指针被释放后，这些指针不会被赋值为nil，而成为野指针。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/ios/Property_of_Objective_C/&quot;&gt;@property中attribute的整理&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on April 16, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[我的时间观---活在当下]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/%E7%94%9F%E6%B4%BB/live_in_the_moment/" />
  <id>http://morisunshine.com/%E7%94%9F%E6%B4%BB/live_in_the_moment</id>
  <published>2014-03-24T00:00:00+08:00</published>
  <updated>2014-03-24T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&lt;img src=&quot;/images/p2014_3_24.jpg&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;

&lt;p&gt;经常有这样的困惑，觉得每天的时间都不够用，对未来做了很多计划，但最终总是证明“计划赶不上变化”，所以那些计划就这样被积压，或者被遗弃，感觉时间真是吝啬。但当自己拥有足够的时间时，却拖延症作祟，什么都不想动，只想坐在那里，什么都不想，让自己放空，但这时内心却是无比挣扎，很想打败拖延症，可是内心总有个懒散的声音在说“好不容易放个假，应该好好休息一下，看什么书啊，多累啊”，好吧，大多数时候总是信了他的话。&lt;/p&gt;

&lt;p&gt;后来开始上班，在公司里面接触到了&lt;a href=&quot;http://zh.wikipedia.org/wiki/GTD&quot;&gt;GTD&lt;/a&gt;，也就是一种时间管理方法，它通过将任务记录下来，然后进行整理，再进行检查的方式，来实现集中精力完成正在做的事情。怎么样？听起来很美好吧，这简直就是我的梦想，如果能达到这样的效果，人生该多么美好啊，把每件事情在短时间里做好，你就可以有很多时间去做自己想做的事了。但人生哪有那么容易呢，这里还是回到那个问题---我是拖延症。该怎么让一个拖延症去有效率的做事情呢，还要每天去计划，每天去整理，每天去打勾啊，真是想的太美了。&lt;/p&gt;

&lt;p&gt;忘记告诉你了，我喜欢禅学，所以会经常看一些佛学书，在很多书中都提到一句话---“活在当下”，当我第一次看到这句话时，只是轻轻翻过去了，因为实在是太普通的一句话了，但是当这么多本书都在提到时，我觉得我应该好好思考了。“活在当下”是什么呢？其实和GTD的主要目的是一致的，就是专心做好当下这一刻的事。可是禅中的涵义就更深刻多了，我不仅是要做好现在要做的事，还要注重当下的感觉，就像我们总是会去纠结那些自己现在不想做的，却又应该做的事情，这些都是我们对未来未知的不确定。“活在当下”就告诉我们“不要急，先做好现在的事”。为什么这么强调现在？因为现在是过去的未来，是未来的过去，而我们又无法改变过去，而只能通过现在才能改变未来，所以现在才是最重要的。就像佛说“当下是我们唯一拥有的一刻，在当下这一刻快乐地生活，是可以办到的事”。&lt;/p&gt;

&lt;p&gt;对于我来说GTD是一个方法，它开始时会给你一些条条框框，你要这样，你要那样，有点让我手足无措，内心无法自由，但当很多人在用了很长时间之后，都可以游刃有余。&lt;/p&gt;

&lt;p&gt;所以给自己一点自由，别让自己活在自己营造的压力下，偶尔的拖延症都是可以理解的，我们都不是完美的人，所以当我们没有达到我们想要的程度时，不用着急，给自己一点时间，慢慢积累，努力练习。我一直相信人生是一场慢热积累的过程。所以现在没有成为你想要的样子，也许是你的积分不够吧。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/%E7%94%9F%E6%B4%BB/live_in_the_moment/&quot;&gt;我的时间观---活在当下&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on March 24, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Objective-C 不是你想的那样]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/ios/objc_is_not_what_you_think_it_is/" />
  <id>http://morisunshine.com/ios/objc_is_not_what_you_think_it_is</id>
  <published>2014-03-13T00:00:00+08:00</published>
  <updated>2014-03-13T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;本文由&lt;a href=&quot;http://morisunshine.com/&quot;&gt;morisunshine&lt;/a&gt;译自&lt;a href=&quot;http://news.rapgenius.com/Soroush-khanlou-objective-c-isnt-what-you-think-it-is-if-you-think-like-a-rubyist-annotated&quot;&gt;&amp;quot;Objective-C isn&amp;#39;t what you think it is&amp;quot;&lt;/a&gt;。转载请注明出处！&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&amp;nbsp;&lt;a href=&quot;#message_in_a_bottle&quot;&gt;&lt;strong&gt;消息的传递&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#getting_metaer_and_metaer&quot;&gt;&lt;strong&gt;变得越来越动态&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#introspection&quot;&gt;&lt;strong&gt;内省&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#cashing_in&quot;&gt;&lt;strong&gt;现学现用&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#what_is_comepielur&quot;&gt;&lt;strong&gt;什么是编译器？&lt;/strong&gt;&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;Ruby 和 Objective-C 这两种语言看上去好像天南地北：一种是动态语言，另一种则是静态语言；一种是解释型语言，另一种是编译型语言；一种有简洁的语法，另一种则是有点冗长的语法。从优雅的角度来看，Ruby似乎更能给我们一种自由的编程体验，所以很多人都放弃了Objective-C。&lt;/p&gt;

&lt;p&gt;但这是一个不幸的笑话。Objective-C其实并不像别人认为的那样是件紧身衣，它和Ruby一样都受Smalltalk影响，它拥有很多Ruby开发者都喜爱的语言功能–动态方法查找、鸭子类型、开放的类和通常情况下高度可变的runtime等这些功能在Objective-C中同样存在，即使那些不出名的技术也是一样。Objective-C的这些功能都要归功于它的IDE和编译器，但也是因为它们才使你不能自由地编写代码&lt;/p&gt;

&lt;p&gt;但是等一下，怎么能说Objective-C是动态语言呢？难道它不是建立在C语言的基础上？&lt;/p&gt;

&lt;p&gt;你可以在Objective-C代码中包含任何C或C++的代码，但这不意味着Objective-C仅限于C或C++代码。Objective-C中所有有意思的类操作和对象内省都是来自于一个叫Objective-C Runtime的东西。这个Objective-C Runtime可以和Ruby解释器相媲美。它包含了强大的元编程里所需要的所有重要特性。&lt;/p&gt;

&lt;p&gt;其实C语言和Ruby一样是支持这些特性的，用&lt;code&gt;property_getAttributes&lt;/code&gt;或&lt;code&gt;method_getImplementation&lt;/code&gt;方法就能将selector对应到具体实现(一个selector处理一个方法)，并判断这个对象能否对这个selector做出反应，再遍历子类树。在Objective-C的众多方法中，最重要的就是&lt;code&gt;objc_msgSend&lt;/code&gt;方法，是它推动了应用中的每次消息发送。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;message_in_a_bottle&#39; name=&#39;message_in_a_bottle&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;消息的传递&lt;/h2&gt;

&lt;p&gt;Smalltalk才是实至名归的第一种面向对象语言，它用“从一个对象发送信息给另一个对象”的新概念取代了“调用函数”的旧概念，对后面的语言发展产生了深远的影响。&lt;/p&gt;

&lt;p&gt;你可以在Ruby中通过这样写来实现消息的发送：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;
receiver.the_message argument

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Objective-C的实现方式和Ruby的差不多：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
[receiver theMessage:argument];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些消息实现了鸭子类型的方式，也就是说关注的不是这个对象的类型或类本身，而是这个对象能否对一个消息做出反应。&lt;/p&gt;

&lt;p&gt;发送消息真的是非常棒的事，但是只有当消息在传送数据时，它的价值才会被发挥地更大：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;
receiver.send(:the_message, argument)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
[receiver performSelector:@selector(theMessage:) 
withObject:argument];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如Ruby中方法需要symbol支持一样，Objective-C中selector也需要string来支持。（在Objective-C中没有symbol。）这样就可以让你通过动态的方式使用一个方法。你甚至可以通过&lt;code&gt;NSSelectorFromString&lt;/code&gt;方法来使用string创建一个selector，并在一个对象里执行它。同样的，我们可以在Ruby中也可以创建一个string或symbol，并把传给&lt;code&gt;Object#send&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;当然，无论是哪种语言，一旦你将一个消息发送给不能处理该消息的对象，那么默认情况下就会抛出一个异常，还会导致应用的崩溃。&lt;/p&gt;

&lt;p&gt;当你想在调用一个方法前判断一下这个对象是否能够执行这个方法，你可以用Ruby中的&lt;code&gt;respond_to？&lt;/code&gt;方法来检查：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;
if receiver.respond_to? :the_message
  receiver.the_message argument
end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Objective-C中也有差不多的方法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
if ([receiver respondsToSelector:@selector(theMessage:)]) {
    [receiver theMessage:someThing];
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;getting_metaer_and_metaer&#39; name=&#39;getting_metaer_and_metaer&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;变得越来越动态&lt;/h2&gt;

&lt;p&gt;如果你想在一个不能修改的类（像系统类）中添加你想要的方法，那么Objective-C里的category一定不会让你失望 -- 很像Ruby中的“开放类”。&lt;/p&gt;

&lt;p&gt;举个例子，如果你想将Rails中的&lt;code&gt;to_sentence&lt;/code&gt;方法添加到&lt;code&gt;NSArray&lt;/code&gt;类中，我们只需要对&lt;code&gt;NSArray&lt;/code&gt;这个类进行扩展就好了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
@interface NSArray (ToSentence)

- (NSString *)toSentence;

@end


@implementation NSArray (ToSentence)

- (NSString *)toSentence {
    if (self.count == 0) return @&amp;amp;quot;&amp;amp;quot;;
    if (self.count == 1) return [self lastObject];
    NSArray *allButLastObject = [self subarrayWithRange:NSMakeRange(0, self.count-1)];
    NSString *result = [allButLastObject componentsJoinedByString:@&amp;amp;quot;, &amp;amp;quot;];
    BOOL showComma = self.count &amp;amp;gt; 2;
    result = [result stringByAppendingFormat:@&amp;amp;quot;%@ and &amp;amp;quot;, showComma ? @&amp;amp;quot;,&amp;amp;quot; : @&amp;amp;quot;&amp;amp;quot;];
    result = [result stringByAppendingString:[self lastObject]];
    return result;
}

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Category是在编译的时候将方法添加到程序中 -- 让我们在runtime中动态捕捉它们怎么样？&lt;/p&gt;

&lt;p&gt;有些消息可以嵌套数据，就像Rails的dynamic finders。Ruby通过对&lt;code&gt;method_missing&lt;/code&gt; 和 &lt;code&gt;respond_to&lt;/code&gt;这两个方法的重写，先匹配模式，再将新方法的定义添加到这个对象中。&lt;/p&gt;

&lt;p&gt;Objective-C中的流程是差不多，但我们不是重写&lt;code&gt;doesNotRecognizeSelector:&lt;/code&gt;方法（相当于Ruby中的&lt;code&gt;method_missing&lt;/code&gt;方法），而是在&lt;code&gt;resolveClassMethod:&lt;/code&gt;方法中捕捉Category添加的方法。假设我们有一个叫&lt;code&gt;+findWhere:equals:&lt;/code&gt;的类方法，它可以得到property的名称和值，那么通过正则表达式就可以很容易实现找到property的名字，并通过block来注册这个selector。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
+ (BOOL)resolveClassMethod:(SEL)sel {
    NSString *selectorName = NSStringFromSelector(sel);

    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@&amp;amp;quot;^findWhere(\\w+)Equals:$&amp;amp;quot; options:0 error:nil];
    NSTextCheckingResult *result = [regex firstMatchInString:selectorName options:0 range:NSMakeRange(0, selectorName.length)];
    if (result) {
        NSRange propertyNameRange = [result rangeAtIndex:1];
        NSString *propertyName = [selectorName substringWithRange:propertyNameRange];

        IMP implementation  = imp_implementationWithBlock((id) ^(id self, id arg1) {
            return [self findWhere:propertyName equals:arg1];
        });

        Class metaClass = object_getClass(self);

        class_addMethod(metaClass, sel, implementation, &amp;amp;quot;@@:@@&amp;amp;quot;);
        return YES;
    }

    return [super resolveClassMethod:sel];
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法的优点就是我们不需要去重写&lt;code&gt;respondsToSelector:&lt;/code&gt;，因为每个在类中注册过的selector都会去调用这个方法。现在让我们调用&lt;code&gt;[RGSong findWhereTitleEquals:@“Mercy”]&lt;/code&gt;。当&lt;code&gt;findWhereTitleEquals:&lt;/code&gt;第一次被调用的时候，runtime并不知道这个方法，所以它会调用&lt;code&gt;resolveClassMethod:&lt;/code&gt;，这时我们就将&lt;code&gt;findWhereTitleEquals:&lt;/code&gt;这个方法动态添加进去，当第二次调用&lt;code&gt;findWhereTitleEquals:&lt;/code&gt;的时候，因为它已经被添加过了，所以就不会再调用&lt;code&gt;resolveClassMethod:&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;这里还有一些别的方法来实现捕捉动态方法。你可以通过重写&lt;code&gt;resolveClassMethod:&lt;/code&gt; 和 &lt;code&gt;resolveInstanceMethod:&lt;/code&gt;方法（就像上面的一样），可以将消息传递给不同的对象或全权接管这个“调用”，并在消息传递之前，做你想这个消息要完成的任何事。这些方法都会导致运行成本的增加，特别在&lt;code&gt;-forwardInvocation:&lt;/code&gt;中会达到顶峰，在这种情况下我们必须要实例化一个对象才能去执行它们。&lt;code&gt;-forwardInvocation:&lt;/code&gt;方法中默认调用&lt;code&gt;doesNotRecognizeSelector&lt;/code&gt;方法，这导致了应用的频繁异常或崩溃。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;introspection&#39; name=&#39;introspection&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;内省&lt;/h2&gt;

&lt;p&gt;动态方法决议并不只是像Ruby和Objective-C这样的语言的技术支持。你也可以通过在runtime中用一种有意思的方式去操作这些对象。&lt;/p&gt;

&lt;p&gt;就像在Ruby中调用&lt;code&gt;MyClass#instance_methods&lt;/code&gt;一样，你可以在Objective-C中调用&lt;code&gt;class_copyMethodList([MyClass class], &amp;amp;amp;numberOfMethods)&lt;/code&gt;来得到一个对象中方法的列表。你还可以通过&lt;code&gt;class_copyPropertyList&lt;/code&gt;方法得到一个类中property的列表，它能在你的模型中实现不可思议的内省。比如在这个&lt;code&gt;Rap Genius&lt;/code&gt;应用中，我们用这个功能来将JSON中的字典映射到本地对象上。&lt;/p&gt;

&lt;p&gt;（如果你非常喜欢Ruby中的mixin，那么Objective-C强大的动态支持也能能实现同样的效果。 Vladimir Mitrovic有一个叫&lt;code&gt;Objective-Mixin&lt;/code&gt;的库，它能在runtime时将一个类中的实现复制到另一个类中。）&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;cashing_in&#39; name=&#39;cashing_in&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;现学现用&lt;/h2&gt;

&lt;p&gt;所有的动态工具都可以用来创建像Core Data这样的东西，Core Data是一个有点像ActiveRecord的持久化对象图。在Core Data中，relationship是“有缺陷的”，也就是说他们只有在被别的对象访问时，才会被加载。每个property的accessor和mutator在runtime中都被重写（使用的就是我们上面提到的动态方法决议）。如果我们访问了一个还没有被加载的对象时，框架就会从持久性储存中动态加载这个对象并将它返回。它保持了内存的低利用率，避免了在任何一个物体被获取时，实体对象图表都要被加载到内存中这样情况的发生。&lt;/p&gt;

&lt;p&gt;当Core Data实体中的mutator被调用时，系统会将那个对象标记为需要清理，不需要去重写每个property的getter和setter。&lt;/p&gt;

&lt;p&gt;这就是元程序，羡慕吧！&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;what_is_comepielur&#39; name=&#39;what_is_comepielur&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;什么是编译器？&lt;/h2&gt;

&lt;p&gt;很明显，Objective-C和Ruby并不是同一种语言，目前为止最大的不同就是Objective-C是一种编译型语言。&lt;/p&gt;

&lt;p&gt;这就是这些技术中最需要注意的地方。在编译时，编译器会先确定你应用使用的每个selector是不是都在应用中。如果你处理的这个对象有类型信息，那么编译器也会检查确保这个selector在头文件有声明过，这样做就是为了防止在对象中调用未声明的selector。有些方法可以绕过这些讨厌的限制，包括关闭相关的编译警告。这里就是实践元程序化的Objective-C最好的练习。&lt;/p&gt;

&lt;p&gt;你可以通过将selector的类型储存为不知道的类型或&lt;code&gt;id&lt;/code&gt;来从对象中删除这些类型信息。因为编译器不认识这个类型，所以它只能假设你的程序可以接受发给它的任何消息（假设这些消息在应用中的其他地方被声明了，并且相关的编译标识已经打开）。&lt;/p&gt;

&lt;p&gt;善意的忠告：如果我们关掉编译器标识和把对象保存成&lt;code&gt;id&lt;/code&gt;类型，那么将会非常危险的事！其实Objective-C中最好的东西之一就是编译器（是的，比元程序还要好）。类型检查保证了我们更快的写和重构代码，也是我们在编程时少犯错误。因为没有人会关掉那些警告，所以你很难去分享你那些&lt;code&gt;id&lt;/code&gt;类型的代码。大部分Objective-C开发者还是更愿意使用更强的类型而不是元程序。&lt;/p&gt;

&lt;p&gt;事实证明Objective-C更受束缚--但因为编译器能提高更多的安全性和速度，所以我们只能选择这样并承担后果。&lt;/p&gt;

&lt;p&gt;事实再次告诉我们，这些语言都是差不多的，Ruby开发者应该享受Objective-C，即使那些中括号让我们望而却步。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/ios/objc_is_not_what_you_think_it_is/&quot;&gt;Objective-C 不是你想的那样&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on March 13, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[我的开发经验漫谈]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/%E5%BC%80%E5%8F%91/experience_of_develop/" />
  <id>http://morisunshine.com/%E5%BC%80%E5%8F%91/experience_of_develop</id>
  <published>2014-03-06T00:00:00+08:00</published>
  <updated>2014-03-06T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#begin&quot;&gt;&lt;strong&gt;项目开始之前&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#specification&quot;&gt;&lt;strong&gt;规范&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#code_specification&quot;&gt;&lt;strong&gt;代码规范&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#version_specification&quot;&gt;&lt;strong&gt;版本控制规范&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#document_specification&quot;&gt;&lt;strong&gt;文档规范&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#test_specification&quot;&gt;&lt;strong&gt;测试规范&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#tidy&quot;&gt;&lt;strong&gt;整理&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;#summary&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;工作快一年了，参与了一些项目，在项目有崩溃的时候，也有欣喜的时候，我觉得很有必要记录下来，其中，可能是一些理想的化的设想，因为在之前的开发过程并没有实践过，但我觉得是可以一试，并且是有帮助的。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#39;begin&#39; name=&#39;begin&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;项目开始之前&lt;/h2&gt;

&lt;p&gt;很多次，我都迫不及待地想马上编写代码，我太喜欢那种写代码的感觉了。可是，越写越觉得不对劲，或者写到一半发现这个功能与需求不一样，然后改了又改，或直接重新开始写。&lt;br&gt;
所以，不要急，慢慢来，我们可以先用Mind Map，或者你喜欢的方式将需求分析一下，并对一些功能进行细化。&lt;br&gt;
有大概的了解之后，我就该去考虑每个功能的具体实现，这个功能的难点在哪里，用什么方法比较好，如果没有找到好的方法，可以用现有的方法去代替。
在上面都考虑好了，我们就该往大的方面想，用什么样的方式比较好，或许用到什么框架，设计模式比较好。&lt;br&gt;
也许刚开始的时候，我的经验有限，想到的方法或方式非常有限，但是一旦我开始去考虑这些问题，并且去实践的时候，我对这些方法的考虑开始往全面的方向发展，这就是在积累中成长吧。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;specification&#39; name=&#39;specification&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;规范&lt;/h2&gt;

&lt;p&gt;当我看过去写的代码，真的有种不想认自己的娃的冲动啊，根本不知道在写什么，命名非常幼稚，当然，现在可能也还是这样，但现在应该有一部分已经成年了吧。很多人会觉得规范是件很麻烦的事，因为规范会给限制程序员的自由，但个人觉得规范与自由并没有冲突。规范应该是团队之间的一种的约定的事情，它的目的是为了能够减少因代码问题而导致的沟通成本。&lt;/p&gt;

&lt;p&gt;规范体现在那些地方呢？&lt;/p&gt;

&lt;p&gt;&lt;a id=&#39;code_specification&#39; name=&#39;code_specification&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;代码规范&lt;/h3&gt;

&lt;p&gt;我觉得每个团队之间的代码规范应该是不一样，代码规范应该是由团队中的每个成员讨论出来的结果，而不是一个人拍案决定，代码规范的目的应该是让你和每个成员都能很好的阅读，把时间专注到更需要时间的地方。&lt;br&gt;
哪些需要规范呢?&lt;br&gt;
比如在iOS项目开发中，就可以有文件名的规范，图片名的规范，类名的规范等。这些命名都需要考虑仔细，因为它不是为一个人而起的。你还要确保别人也能看懂它的作用，也许你会觉得注释就好，当然，这会是个好办法，但如果只要能看到名字就能知道它的功能，那不是更好么？&lt;/p&gt;

&lt;p&gt;&lt;a id=&#39;version_specification&#39; name=&#39;version_specification&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;版本控制规范&lt;/h3&gt;

&lt;p&gt;版本控制在开发过程中非常重要，所以版本控制的规范也是非常重要的，以git为例:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建的分支名，就应该清楚让人知道我们在这个分支里做了哪些事情。&lt;/li&gt;
&lt;li&gt;commit，每一条commit都应该清楚的描述，不能马虎，这不只帮助你未来的查看，也是让开发人员了解代码演化的重要途径之一，另一方面，也不知不觉中养成细化功能的习惯，这样在以后地开发中，你就会对要开发的功能进行细分，当一个子功能开发完成，就写一个commit。(这里可以参考&lt;a href=&quot;https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit&quot;&gt;google开源项目的commit规范&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&#39;document_specification&#39; name=&#39;document_specification&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;文档规范&lt;/h3&gt;

&lt;p&gt;当开始一个项目时，应该需要一个文档，来跟踪你的项目，其中的内容应该包括，这个项目的文件结构，功能，还有一些类的功能。这些也是对代码可读性的扩展。&lt;/p&gt;

&lt;p&gt;这么多规范很烦吧，程序员的自由在哪儿，但我觉得我们不只是为现在写程序，很多时候，写程序的时间只占开发整个项目的10%，而很多时间都是在测试，调试，解决bug，或者在寻找以前的代码。所以我们要为未来而写，这对于我来说也是一种自我修养吧。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#39;test_specification&#39; name=&#39;test_specification&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;测试规范&lt;/h3&gt;

&lt;p&gt;测试，听上去很美好，当在我的以往项目中，这总是被遗忘的事情，或者是根本不会提起的事情，只有当问题产生，才会悔不当初，有它该多好。每次下定决心，一定要写一个测试的时候，总是懒于去行动，但励志要成为优秀工程师的我们一定不会忽略它的，所以测试的规范，也是非常重要的，它也让你知道一这段测试的功能与该有的结果，这也是对功能性的一个很好的补充，也为以后的改动带来了很多方便。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;tidy&#39; name=&#39;tidy&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;整理&lt;/h2&gt;

&lt;p&gt;你的项目不会是一尘不变的，他会因为时间的推移而增加更多东西，这时也许你之前的那些管理方式就变得很没有效率，想重新捣腾它，发现牵一发而动全身，真抓狂，早干嘛去了。为了避免这样的悲剧再次重演整理就变得很重要了，整理包括目录结构、资源和代码的整理，文件结构可以参考这篇&lt;a href=&quot;http://blog.jobbole.com/61083/&quot;&gt;博文&lt;/a&gt;,资源和代码整理则是根据上面提到的各种规范，整理的目的应该是让项目清晰和简洁。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;summary&#39; name=&#39;summary&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;写了这么多，其实也是对自己过去的经验的整理，也是对自己的勉励，博客的意义在于分享，而分享又是为了更好的交流，希望能提出一些宝贵的意见，让我们一起成长。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/%E5%BC%80%E5%8F%91/experience_of_develop/&quot;&gt;我的开发经验漫谈&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on March 06, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[UICollectionView+UIKit Dynamics]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/ios/UICollectionView_UIKit_Dynamics/" />
  <id>http://morisunshine.com/ios/UICollectionView_UIKit_Dynamics</id>
  <published>2014-02-27T00:00:00+08:00</published>
  <updated>2014-02-27T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.objc.io/issue-5/collection-views-and-uidynamics.html&quot;&gt;原文&lt;/a&gt;作者&lt;a href=&quot;https://twitter.com/ashfurrow&quot;&gt;Ash Furrow&lt;/a&gt;。转载请注明出处！&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&quot;http://blog.codingcoder.com/&quot;&gt;破土&lt;/a&gt;参与翻译。&lt;/p&gt;

&lt;p&gt;UIKit Dynamics 是 iOS 7 中基于物理动画引擎的一个新功能--它被特别设计使其能很好地与 collection views 配合工作，而后者是在 iOS 6 中才被引入的新特性。接下来，我们要好好看看如何将这两个特性结合在一起。 &lt;/p&gt;

&lt;p&gt;这篇文章将讨论两个结合使用 UIkit Dynamics 和 collection view 的例子。第一个例子展示了如何去实现像 iOS 7 里信息 app 中的消息泡泡的弹簧动效，然后再进一步结合平铺机制来实现布局的可伸缩性。第二个例子展现了如何用 UIKit Dynamics 来模拟&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%91%86&quot;&gt;牛顿摆&lt;/a&gt;，这个例子中物体可以一个个地加入到 collection view 中，并和其他物体发生相互作用。&lt;/p&gt;

&lt;p&gt;在我们开始之前，我假定你们对 &lt;code&gt;UICollectionView&lt;/code&gt; 是如何工作是有基本的了解——查看&lt;a href=&quot;http://www.objccn.io/issue-3-3/&quot;&gt;这篇 objc.io 文章&lt;/a&gt;会有你想要的所有细节。我也假定你已经理解了 &lt;code&gt;UIKit Dynamics&lt;/code&gt; 的工作原理--阅读这篇&lt;a href=&quot;http://www.teehanlax.com/blog/introduction-to-uikit-dynamics/&quot;&gt;博客&lt;/a&gt;，可以了解更多 UIKit Dynamics 的知识。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;secondary radius label&quot;&gt;编者注&lt;/span&gt; 如果您阅读本篇文章感觉有点吃力的话，可以先来看看 &lt;a href=&quot;http://im.onevcat.com&quot;&gt;@onevcat&lt;/a&gt; 的&lt;a href=&quot;http://onevcat.com/2012/06/introducing-collection-views/&quot;&gt;《UICollectionView 入门》&lt;/a&gt; 和&lt;a href=&quot;http://onevcat.com/2013/06/uikit-dynamics-started/&quot;&gt;《UIKit Dynamics 入门》&lt;/a&gt;这两篇入门文章，帮助您快速补充相关知识。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章中的两个例子项目都已经在 GitHub 中:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/objcio/issue-5-springy-collection-view&quot;&gt;ASHSpringyCollectionView&lt;/a&gt;（基于 &lt;a href=&quot;https://github.com/TeehanLax/UICollectionView-Spring-Demo&quot;&gt;UICollectionView Spring Demo&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/objcio/issue-5-newtonian-collection-view&quot;&gt;Newtownian UICollectionView&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;关于 UIDynamicAnimator&lt;/h2&gt;

&lt;p&gt;支持 &lt;code&gt;UICollectionView&lt;/code&gt; 实现 UIKit Dynamics 的最关键部分就是 &lt;code&gt;UIDynamicAnimator&lt;/code&gt;。要实现这样的 UIKit Dynamics 的效果，我们需要自己自定义一个继承于 &lt;code&gt;UICollectionViewFlowLayout&lt;/code&gt; 的子类，并且在这个子类对象里面持有一个 UIDynamicAnimator 的对象。&lt;/p&gt;

&lt;p&gt;当我们创建自定义的 dynamic animator 时，我们不会使用常用的初始化方法 &lt;code&gt;-initWithReferenceView:&lt;/code&gt; ，因为我们不需要把这个 dynamic animator 关联一个 view ，而是给它关联一个 collection view layout。所以我们使用 &lt;code&gt;-initWithCollectionViewLayout:&lt;/code&gt; 这个初始化方法，并把 collection view layout 作为参数传入。这很关键，当的 animator 的 behavior item 的属性应该被更新的时候，它必须能够确保 collection view 的 layout 失效。换句话说，dynamic animator 将会经常使旧的 layout 失效。&lt;/p&gt;

&lt;p&gt;我们很快就能看到这些事情是怎么连接起来的，但是在概念上理解 collection view 如何与 dynamic animator 相互作用是很重要的。&lt;/p&gt;

&lt;p&gt;Collection view layout 将会为 collection view 中的每个 &lt;code&gt;UICollectionViewLayoutAttributes&lt;/code&gt; 添加 behavior（稍后我们会讨论平铺它们）。在将这些 behaviors 添加到 dynamic animator 之后，UIKit 将会向 collection view layout 询问 atrribute 的状态。我们此时可以直接将由 dynamic animator 所提供的 items 返回，而不需要自己做任何计算。Animator 将在模拟时禁用 layout。这会导致 UIKit 再次查询 layout，这个过程会一直持续到模拟满足设定条件而结束。&lt;/p&gt;

&lt;p&gt;所以重申一下，layout 创建了 dynamic animator，并且为其中每个 item 的 layout attribute 添加对应的 behaviors。当 collection view 需要 layout 信息时，由 dynamic animator 来提供需要的信息。&lt;/p&gt;

&lt;h2&gt;继承 UICollectionViewFlowLayout&lt;/h2&gt;

&lt;p&gt;我们将要创建一个简单的例子来展示如何使用一个带 UIkit Dynamic 的 collection view layout。当然，我们需要做的第一件事就是，创建一个数据源去驱动我们的 collection view。我知道以你的能力完全可以独立实现一个数据源，但是为了完整性，我还是提供了一个给你:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@implementation ASHCollectionViewController

static NSString * CellIdentifier = @&amp;quot;CellIdentifier&amp;quot;;

-(void)viewDidLoad 
{
    [super viewDidLoad];
    [self.collectionView registerClass:[UICollectionViewCell class] 
            forCellWithReuseIdentifier:CellIdentifier];
}

-(UIStatusBarStyle)preferredStatusBarStyle 
{
    return UIStatusBarStyleLightContent;
}

-(void)viewDidAppear:(BOOL)animated 
{
    [super viewDidAppear:animated];
    [self.collectionViewLayout invalidateLayout];
}

#pragma mark - UICollectionView Methods

-(NSInteger)collectionView:(UICollectionView *)collectionView 
    numberOfItemsInSection:(NSInteger)section 
{
    return 120;
}

-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView 
                 cellForItemAtIndexPath:(NSIndexPath *)indexPath 
{
    UICollectionViewCell *cell = [collectionView 
        dequeueReusableCellWithReuseIdentifier:CellIdentifier 
                                  forIndexPath:indexPath];

    cell.backgroundColor = [UIColor orangeColor];
    return cell;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们注意到当 view 第一次出现的时候，这个 layout 是被无效的。这是因为没有用 Storyboard 的结果（使用或不使用 Storyboard，调用 prepareLayout 方法的时机是不同的，苹果在 WWDC 的视频中并没有告诉我们这一点）。所以，当这些视图一出现我们就需要手动使这个 collection view layout 无效。当我们用平铺（后面会详细介绍）的时候，就不需要这样。&lt;/p&gt;

&lt;p&gt;现在来创建自定义的 collection view layout 吧，我们需要强引用一个 dynamic animator，并且使用它来驱动我们的 collcetion view layout 的 attribute。我们在实现文件里定义了一个私有属性：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@interface ASHSpringyCollectionViewFlowLayout ()

@property (nonatomic, strong) UIDynamicAnimator *dynamicAnimator;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将在 layout 的初始化方法中初始化我们的 dynamic animator。还要设置一些属于父类 &lt;code&gt;UICollectionViewFlowLayout&lt;/code&gt; 中的属性:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;- (id)init 
{
    if (!(self = [super init])) return nil;

    self.minimumInteritemSpacing = 10;
    self.minimumLineSpacing = 10;
    self.itemSize = CGSizeMake(44, 44);
    self.sectionInset = UIEdgeInsetsMake(10, 10, 10, 10);

    self.dynamicAnimator = [[UIDynamicAnimator alloc] initWithCollectionViewLayout:self];

    return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将实现的下一个方法是 prepareLayout。我们首先需要调用父类的方法。因为我们是继承 &lt;code&gt;UICollectionViewFlowLayout&lt;/code&gt; 类，所以在调用父类的 prepareLayout 方法时，可以使 collection view layout 的各个 attribute 都放置在合适的位置。我们可以依靠父类的这个方法来提供一个默认的排布，并且能够使用 &lt;code&gt;[super layoutAttributesForElementsInRect:visibleRect];&lt;/code&gt; 方法得到指定 rect 内的&lt;em&gt;所有&lt;/em&gt; item 的 layout attributes。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[super prepareLayout];

CGSize contentSize = self.collectionView.contentSize;
NSArray *items = [super layoutAttributesForElementsInRect:
    CGRectMake(0.0f, 0.0f, contentSize.width, contentSize.height)];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这&lt;em&gt;真的&lt;/em&gt;是效率低下的代码。因为我们的 collection view 中可能会有成千上万个 cell，一次性加载所有的 cell 是一个可能会产生难以置信的内存紧张的操作。我们要在一段时间内遍历所有的元素，这也成为耗时的操作。这真的是效率的双重打击！别担心——我们是负责任的开发者，所以我们会很快解决这个问题的。我们先暂时继续使用简单、粗暴的实现方式。&lt;/p&gt;

&lt;p&gt;当加载完我们所有的 collection view layout attribute 之后，我们需要检查他们是否都已经被加载到我们的 animator 里了。如果一个 behavior 已经在 animator 中存在，那么我们就不能重新添加，否则就会得到一个非常难懂的运行异常提示:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;UIDynamicAnimator: 0xa5ba280&amp;gt; (0.004987s) in 
&amp;lt;ASHSpringyCollectionViewFlowLayout: 0xa5b9e60&amp;gt; \{\{0, 0}, \{0, 0\}\}: 
body &amp;lt;PKPhysicsBody&amp;gt; type:&amp;lt;Rectangle&amp;gt; representedObject:
[&amp;lt;UICollectionViewLayoutAttributes: 0xa281880&amp;gt; 
index path: (&amp;lt;NSIndexPath: 0xa281850&amp;gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44); ] 0xa2877c0  
PO:(159.999985,32.000000) AN:(0.000000) VE:(0.000000,0.000000) AV:(0.000000) 
dy:(1) cc:(0) ar:(1) rs:(0) fr:(0.200000) re:(0.200000) de:(1.054650) gr:(0) 
without representedObject for item &amp;lt;UICollectionViewLayoutAttributes: 0xa3833e0&amp;gt; 
index path: (&amp;lt;NSIndexPath: 0xa382410&amp;gt; {length = 2, path = 0 - 0}); 
frame = (10 10; 300 44);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果看到了这个错误，那么这基本表明你添加了两个 behavior 给同一个 &lt;code&gt;UICollectionViewLayoutAttribute&lt;/code&gt;，这使得系统不知道该怎么处理。&lt;/p&gt;

&lt;p&gt;无论如何，一旦我们已经检查好我们是否已经将 behavior 添加到 dynamic animator 之后，我们就需要遍历每个 collection view layout attribute 来创建和添加新的 dynamic animator：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;if (self.dynamicAnimator.behaviors.count == 0) {
    [items enumerateObjectsUsingBlock:^(id&amp;lt;UIDynamicItem&amp;gt; obj, NSUInteger idx, BOOL *stop) {
        UIAttachmentBehavior *behaviour = [[UIAttachmentBehavior alloc] initWithItem:obj 
                                                                    attachedToAnchor:[obj center]];

        behaviour.length = 0.0f;
        behaviour.damping = 0.8f;
        behaviour.frequency = 1.0f;

        [self.dynamicAnimator addBehavior:behaviour];
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码非常简单。我们为每个 item 创建了一个以物体的中心为附着点的 &lt;code&gt;UIAttachmentBehavior&lt;/code&gt; 对象。然后又设置了我们的 attachment behavior 的 length 为 0 以便约束这个 cell 能一直以 behavior 的附着点为中心。然后又给 &lt;code&gt;damping&lt;/code&gt; 和 &lt;code&gt;frequency&lt;/code&gt; 这两个参数设置一个比较合适的值。&lt;/p&gt;

&lt;p&gt;这就是 &lt;code&gt;prepareLayout&lt;/code&gt;。我们现在需要实现 &lt;code&gt;layoutAttributesForElementsInRect:&lt;/code&gt; 和 &lt;code&gt;layoutAttributesForItemAtIndexPath:&lt;/code&gt; 这两个方法，UIKit 会调用它们来询问 collection view 每一个 item 的布局信息。我们写的代码会把这些查询交给专门做这些事的 dynamic animator:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect 
{
    return [self.dynamicAnimator itemsInRect:rect];
}

-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath 
{
    return [self.dynamicAnimator layoutAttributesForCellAtIndexPath:indexPath];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;响应滚动事件&lt;/h1&gt;

&lt;p&gt;我们目前实现的代码给我们展示的只是一个在正常滑动下只有静态感觉的 &lt;code&gt;UICollectionView&lt;/code&gt;，运行起来没什么特别的。看上去很好，但不是真的&lt;em&gt;动态&lt;/em&gt;，不是么？&lt;/p&gt;

&lt;p&gt;为了使它表现地动态点，我们需要 layout 和 dynamic animator 能够对 collection view 中滑动位置的变化做出反应。幸好这里有个非常适合这个要求的方法 &lt;code&gt;shouldInvalidateLayoutForBoundsChange:&lt;/code&gt;。这个方法会在 collection view 的 bound 发生改变的时候被调用，根据最新的 &lt;a href=&quot;http://www.objccn.io/issue-3-2/&quot;&gt;content offset&lt;/a&gt; 调整我们的 dynamic animator 中的 behaviors 的参数。在重新调整这些 behavior 的 item 之后，我们在这个方法中返回 NO；因为 dynamic animator 会关心 layout 的无效问题，所以在这种情况下，它不需要去主动使其无效：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;    -(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds 
    {
        UIScrollView *scrollView = self.collectionView;
        CGFloat delta = newBounds.origin.y - scrollView.bounds.origin.y;

        CGPoint touchLocation = [self.collectionView.panGestureRecognizer locationInView:self.collectionView];

        [self.dynamicAnimator.behaviors enumerateObjectsUsingBlock:^(UIAttachmentBehavior *springBehaviour, NSUInteger idx, BOOL *stop) {
            CGFloat yDistanceFromTouch = fabsf(touchLocation.y - springBehaviour.anchorPoint.y);
            CGFloat xDistanceFromTouch = fabsf(touchLocation.x - springBehaviour.anchorPoint.x);
            CGFloat scrollResistance = (yDistanceFromTouch + xDistanceFromTouch) / 1500.0f;

            UICollectionViewLayoutAttributes *item = springBehaviour.items.firstObject;
            CGPoint center = item.center;
            if (delta &amp;lt; 0) {
                center.y += MAX(delta, delta*scrollResistance);
            }
            else {
                center.y += MIN(delta, delta*scrollResistance);
            }
            item.center = center;

            [self.dynamicAnimator updateItemUsingCurrentState:item];
        }];

        return NO;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们仔细查看这个代码的细节。首先我们得到了这个 scroll view（就是我们的 collection view ），然后计算它的 content offset 中 y 的变化（在这个例子中，我们的 collection view 是垂直滑动的）。一旦我们得到这个增量，我们需要得到用户接触的位置。这是非常重要的，因为我们希望离接触位置比较近的那些物体能移动地更迅速些，而离接触位置比较远的那些物体则应该滞后些。&lt;/p&gt;

&lt;p&gt;对于 dynamic animator 中的每个 behavior，我们将接触点到该 behavior 物体的 x 和 y 的距离之和除以 1500，1500 是我根据经验设的。分母越小，这个 collection view 的的交互就越有弹簧的感觉。一旦我们拿到了这个“滑动阻力”的值，我们就可以用它的增量乘上 &lt;code&gt;scrollResistance&lt;/code&gt; 这个变量来指定这个 behavior 物体的中心点的 y 值。最后，我们在滑动阻力大于增量的情况下对增量和滑动阻力的结果进行了选择（这意味着物体开始往错误的方向移动了）。在本例我们用了这么大的分母，那么这种情况是不可能的，但是在一些更具弹性的 collection view layout 中还是需要注意的。&lt;/p&gt;

&lt;p&gt;就是这么一回事。以我的经验，这个方法对多达几百个物体的 collection view 来说也是是适用的。超过这个数量的话，一次性加载所有物体到内存中就会变成很大的负担，并且在滑动的时候就会开始卡顿了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.objccn.io/issue-5/springyCollectionView.gif&quot; alt=&quot;Springy Collection View&quot;&gt;&lt;/p&gt;

&lt;h2&gt;平铺（Tiling）你的 Dynamic Behaviors 来优化性能&lt;/h2&gt;

&lt;p&gt;当你的 collection view 中只有几百个 cell 的时候，他运行的很好，但当数据源超过这个范围的时候会发生什么呢？或者在运行的时你不能预测你的数据源有多大呢？我们的简单粗暴的方法就不管用了。&lt;/p&gt;

&lt;p&gt;除了在 &lt;code&gt;prepareLayout&lt;/code&gt; 中加载&lt;em&gt;所有&lt;/em&gt;的物体，如果我们能&lt;em&gt;更聪明地&lt;/em&gt;知道哪些物体会加载那该多好啊。是的，就是仅加载显示的和即将显示的物体。这正是我们要采取的办法。&lt;/p&gt;

&lt;p&gt;我们需要做的第一件事就是是跟踪 dynamic animator 中的所有 behavior 物体的 index path。我在 collection view 中添加一个属性来做这件事:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@property (nonatomic, strong) NSMutableSet *visibleIndexPathsSet;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们用 set 是因为它具有常数复杂度的查找效率，并且我们&lt;em&gt;经常&lt;/em&gt;地查找 &lt;code&gt;visibleIndexPathsSet&lt;/code&gt; 中是否已经包含了某个 index path。&lt;/p&gt;

&lt;p&gt;在我们实现全新的 &lt;code&gt;prepareLayout&lt;/code&gt; 方法之前——有一个问题就是什么是&lt;strong&gt;平铺 behavior&lt;/strong&gt; —— 理解平铺的意思是非常重要的。当我们平铺behavior 的时候，我们会在这些 item 离开 collection view 的可视范围的时候删除对应的 behavior，在这些 item 进入可视范围的时候又添加对应的 behavior。这是一个大麻烦：我们需要在&lt;em&gt;滚动中&lt;/em&gt;创建新的 behavior。这就意味着让人觉得创建它们就好像它们本来就已经在 dynamic animator 里了一样，并且它们是在 &lt;code&gt;shouldInvalidateLayoutForBoundsChange:&lt;/code&gt; 方法被修改的。&lt;/p&gt;

&lt;p&gt;因为我们是在滚动中创建这些新的 behavior，所以我们需要维持现在 collection view 的一些状态。尤其我们需要跟踪最近一次我们 &lt;code&gt;bound&lt;/code&gt; 变化的增量。我们会在滚动时用这个状态去创建我们的 behavior：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;@property (nonatomic, assign) CGFloat latestDelta;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加完这个 property 后，我们将要在 &lt;code&gt;shouldInvalidateLayoutForBoundsChange:&lt;/code&gt; 方法中添加下面这行代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;self.latestDelta = delta;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是我们需要修改我们的方法来响应滚动事件。我们的这两个方法是为了将 collection view 中 items 的 layout 信息传给 dynamic animator，这种方式没有变化。事实上，当你的 collection view 实现了 dynamic animator 的大部分情况下，都需要实现我们上面提到的两个方法 &lt;code&gt;layoutAttributesForElementsInRect:&lt;/code&gt; 和 &lt;code&gt;layoutAttributesForItemAtIndexPath:&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里最难懂的部分就是平铺机制。我们将要完全重写我们的 prepareLayout。&lt;/p&gt;

&lt;p&gt;这个方法的第一步是将那些物体的 index path 已经不在屏幕上显示的 behavior 从 dynamic animator 上删除。第二步是添加那些即将显示的物体的 behavior。&lt;/p&gt;

&lt;p&gt;让我们先看一下第一步。&lt;/p&gt;

&lt;p&gt;像以前一样，我们要调用 &lt;code&gt;super prepareLayout&lt;/code&gt;，这样我们就能依赖父类 &lt;code&gt;UICollectionViewFlowLayout&lt;/code&gt; 提供的默认排布。还像以前一样，我们通过父类获取一个矩形内的所有元素的 layout attribute。不同的是我们不是获取整个 collection view 中的元素属性，而只是获取显示范围内的。&lt;/p&gt;

&lt;p&gt;所以我们需要计算这个显示矩形。但是别着急！有件事要记住。我们的用户可能会非常快地滑动 collection view，导致了 dynamic animator 不能跟上，所以我们需要稍微扩大显示范围，这样就能包含到那些将要显示的物体了。否则，在滑动很快的时候就会出现频闪现象了。让我们计算一下显示范围:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;CGRect originalRect = (CGRect){.origin = self.collectionView.bounds.origin, .size = self.collectionView.frame.size};
CGRect visibleRect = CGRectInset(originalRect, -100, -100);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我确信在实际显示矩形上的每个方向都扩大100个像素对我的 demo 来说是可行的。仔细查看这些值是否适合你们的 collection view，尤其是当你们的 cell 很小的情况下。&lt;/p&gt;

&lt;p&gt;接下来我们就需要收集在显示范围内的 collection view layout attributes。还有它们的 index paths:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;NSArray *itemsInVisibleRectArray = [super layoutAttributesForElementsInRect:visibleRect];

NSSet *itemsIndexPathsInVisibleRectSet = [NSSet setWithArray:[itemsInVisibleRectArray valueForKey:@&amp;quot;indexPath&amp;quot;]];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意我们是在用一个 NSSet。这是因为它具有常数复杂度的查找效率，并且我们经常的查找 &lt;code&gt;visibleIndexPathsSet&lt;/code&gt; 是否已经包含了某个 index path:&lt;/p&gt;

&lt;p&gt;接下来我们要做的就是遍历 dynamic animator 的 behaviors，过滤掉那些已经在 &lt;code&gt;itemsIndexPathsInVisibleRectSet&lt;/code&gt; 中的 item。因为我们已经过滤掉我们的 behavior，所以我们将要遍历的这些 item 都是不在显示范围里的，我们就可以将这些 item 从 animator 中删除掉（连同 &lt;code&gt;visibleIndexPathsSet&lt;/code&gt; 属性中的 index path）:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(UIAttachmentBehavior *behaviour, NSDictionary *bindings) {
    BOOL currentlyVisible = [itemsIndexPathsInVisibleRectSet member:[[[behaviour items] firstObject] indexPath]] != nil;
    return !currentlyVisible;
}]
NSArray *noLongerVisibleBehaviours = [self.dynamicAnimator.behaviors filteredArrayUsingPredicate:predicate];

[noLongerVisibleBehaviours enumerateObjectsUsingBlock:^(id obj, NSUInteger index, BOOL *stop) {
    [self.dynamicAnimator removeBehavior:obj];
    [self.visibleIndexPathsSet removeObject:[[[obj items] firstObject] indexPath]];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下一步就是要得到&lt;em&gt;新&lt;/em&gt;出现 item 的 &lt;code&gt;UICollectionViewLayoutAttributes&lt;/code&gt; 数组——那些 item 的 index path 在 &lt;code&gt;itemsIndexPathsInVisibleRectSet&lt;/code&gt; 而不在 &lt;code&gt;visibleIndexPathsSet&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;NSPredicate *predicate = [NSPredicate predicateWithBlock:^BOOL(UICollectionViewLayoutAttributes *item, NSDictionary *bindings) {
    BOOL currentlyVisible = [self.visibleIndexPathsSet member:item.indexPath] != nil;
    return !currentlyVisible;
}];
NSArray *newlyVisibleItems = [itemsInVisibleRectArray filteredArrayUsingPredicate:predicate];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦我们有新的 layout attribute 出现，我就可以遍历他们来创建新的 behavior，并且将他们的 index path 添加到 &lt;code&gt;visibleIndexPathsSet&lt;/code&gt; 中。首先，无论如何，我都需要获取到用户手指触碰的位置。如果它是 &lt;code&gt;CGPointZero&lt;/code&gt; 的话，那就表示这个用户没有在滑动 collection view，这时我就&lt;em&gt;假定&lt;/em&gt;我们不需要在滚动时创建新的 behavior 了：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;CGPoint touchLocation = [self.collectionView.panGestureRecognizer locationInView:self.collectionView];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个潜藏危险的假定。如果用户很快地滑动了 collection view 之后释放了他的手指呢？这个 collection view 就会一直滚动，但是我们的方法就不会在滚动时创建新的 behavior 了。但幸运的是，那也就意味这时 scroll view 滚动太快很难被注意到！好哇！但是，对于那些拥有大型 cell 的 collection view 来说，这仍然是个问题。那么在这种情况下，就需要增加你的可视范围的 bounds 来加载更多物体以解决这个问题。&lt;/p&gt;

&lt;p&gt;现在我们需要枚举我们刚显示的 item，为他们创建 behavior，再将他们的 index path 添加到 &lt;code&gt;visibleIndexPathsSet&lt;/code&gt;。我们还需要在滚动时做些&lt;a href=&quot;http://www.youtube.com/watch?v=gENVB6tjq_M&quot;&gt;数学运算&lt;/a&gt;来创建 behavior：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;[newlyVisibleItems enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes *item, NSUInteger idx, BOOL *stop) {
    CGPoint center = item.center;
    UIAttachmentBehavior *springBehaviour = [[UIAttachmentBehavior alloc] initWithItem:item attachedToAnchor:center];

    springBehaviour.length = 0.0f;
    springBehaviour.damping = 0.8f;
    springBehaviour.frequency = 1.0f;

    if (!CGPointEqualToPoint(CGPointZero, touchLocation)) {
        CGFloat yDistanceFromTouch = fabsf(touchLocation.y - springBehaviour.anchorPoint.y);
        CGFloat xDistanceFromTouch = fabsf(touchLocation.x - springBehaviour.anchorPoint.x);
        CGFloat scrollResistance = (yDistanceFromTouch + xDistanceFromTouch) / 1500.0f;

        if (self.latestDelta &amp;lt; 0) {
            center.y += MAX(self.latestDelta, self.latestDelta*scrollResistance);
        }
        else {
            center.y += MIN(self.latestDelta, self.latestDelta*scrollResistance);
        }
        item.center = center;
    }

    [self.dynamicAnimator addBehavior:springBehaviour];
    [self.visibleIndexPathsSet addObject:item.indexPath];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大部分代码看起来还是挺熟悉的。大概有一半是来自没有实现平铺的 &lt;code&gt;prepareLayout&lt;/code&gt;。另一半是来自 &lt;code&gt;shouldInvalidateLayoutForBoundsChange:&lt;/code&gt; 这个方法。我们用 latestDelta 这个属性来表示 &lt;code&gt;bound&lt;/code&gt; 变化的增量，适当地调整 &lt;code&gt;UICollectionViewLayoutAttributes&lt;/code&gt; 使这些 cell 表现地就像被 attachment behavior “拉”着一样。&lt;/p&gt;

&lt;p&gt;就这样就完成了，真的！我已经在真机上测试过显示上千个 cell 的情况了，它运行地非常完美。&lt;a href=&quot;https://github.com/objcio/issue-5-springy-collection-view&quot;&gt;去试试吧&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;超越瀑布流布局&lt;/h2&gt;

&lt;p&gt;一般来说，当我们使用 &lt;code&gt;UICollectionView&lt;/code&gt; 的时候，继承 &lt;code&gt;UICollectionViewFlowLayout&lt;/code&gt; 会比直接继承 &lt;code&gt;UICollectionViewLayout&lt;/code&gt; 更容易。这是因为 &lt;em&gt;flow&lt;/em&gt; layout 会为我们做很多事。然而，瀑布流布局是严格基于它们的尺寸一个接一个的展现出来。如果你有一个布局不能适应这个标准怎么办？好的，如果你已经尝试用 &lt;code&gt;UICollectionViewFlowLayout&lt;/code&gt; 来适应，而且你很确定它不能很好运行，那么就应该抛弃 &lt;code&gt;UICollectionViewFlowLayout&lt;/code&gt; 这个定制性比较弱的子类，而应该直接在 &lt;code&gt;UICollectionViewLayout&lt;/code&gt; 这个基类上进行定制。&lt;/p&gt;

&lt;p&gt;这个原则在处理 UIKit Dynamic 时也是适用的。&lt;/p&gt;

&lt;p&gt;让我们先创建 &lt;code&gt;UICollectionViewLayout&lt;/code&gt; 的子类。当继承 &lt;code&gt;UICollectionViewLayout&lt;/code&gt; 的时候需要实现 &lt;code&gt;collectionViewContentSize&lt;/code&gt; 方法，这点非常重要。否则这个 collection view 就不知道如果去显示自己，也不会有显示任何东西。因为我们想要 collection view 不能滚动，所以这里要返回 collection view 的 frame 的 size，减去它的 &lt;code&gt;contentInset.top&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;-(CGSize)collectionViewContentSize 
{
    return CGSizeMake(self.collectionView.frame.size.width, 
        self.collectionView.frame.size.height - self.collectionView.contentInset.top);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个（有点教学式）的例子中，我们的 collection view &lt;em&gt;总是会以零个cell开始&lt;/em&gt;，物体通过 &lt;code&gt;performBatchUpdates:&lt;/code&gt; 这个方法添加。这就意味着我们必须使用 &lt;code&gt;-[UICollectionViewLayout prepareForCollectionViewUpdates:]&lt;/code&gt; 这个方法来添加我们的 behavior（即这个 collection view 的数据源总是以零开始）。&lt;/p&gt;

&lt;p&gt;除了给各个 item 添加 attachment behavior 外，我们还将保留另外两个 behavior：重力和碰撞。对于添加在这个 collection view 中的每个 item 来说，我们必须把这些 item 添加到我们的碰撞和 attachment behavior 中。最后一步就是设置这些 item 的初始位置为屏幕外的某些地方，这样就有被 attachment behavior 拉入到屏幕内的效果了:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;-(void)prepareForCollectionViewUpdates:(NSArray *)updateItems
{
    [super prepareForCollectionViewUpdates:updateItems];

    [updateItems enumerateObjectsUsingBlock:^(UICollectionViewUpdateItem *updateItem, NSUInteger idx, BOOL *stop) {
        if (updateItem.updateAction == UICollectionUpdateActionInsert) {
            UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes 
                layoutAttributesForCellWithIndexPath:updateItem.indexPathAfterUpdate];

            attributes.frame = CGRectMake(CGRectGetMaxX(self.collectionView.frame) + kItemSize, 300, kItemSize, kItemSize);

            UIAttachmentBehavior *attachmentBehaviour = [[UIAttachmentBehavior alloc] initWithItem: attributesaachedToAnchor:attachmentPoint];
            attachmentBehaviour.length = 300.0f;
            attachmentBehaviour.damping = 0.4f;
            attachmentBehaviour.frequency = 1.0f;
            [self.dynamicAnimator addBehavior:attachmentBehaviour];

            [self.gravityBehaviour addItem:attributes];
            [self.collisionBehaviour addItem:attributes];
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://img.objccn.io/issue-5/newtonianCollectionView.gif&quot; alt=&quot;Demo&quot;&gt;&lt;/p&gt;

&lt;p&gt;删除就有点复杂了。我们希望这些物体有“掉落”的效果而不是简单的消失。这就不仅仅是从 collection view 中删除个 cell 这么简单了，因为我们希望在它离开了屏幕之前还是保留它。我已经在代码中实现了这样的效果，但是做法有点取巧。&lt;/p&gt;

&lt;p&gt;基本上我们要做的是在 layout 中提供一个方法，在它删除 attachment behavior 两秒之后，将这个 cell 从 collection view 中删除。我们希望在这段时间里，这个 cell 能掉出屏幕，但是这不一定会发生。如果没有发生，也没关系。只要淡出就行了。然而，我们必须保证在这两秒内既没有新的 cell 被添加，也没有旧的 cell 被删除。（我说了有点取巧。）&lt;/p&gt;

&lt;p&gt;欢迎提交 pull request。&lt;/p&gt;

&lt;p&gt;这个方法是有局限性的。我将 cell 数量的上限设为 10，但是即使这样，在像 iPad2 这样比较旧的设备中，动画就会运行地很慢。当然，这个例子只是为了展示如何模拟有趣的动力学的一个方法——它并不是一个可以解决任何问题的万金油。你个人在实践中如何来进行模拟，包括性能等各个方面，都取决于你自己了。&lt;/p&gt;

&lt;hr&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/ios/UICollectionView_UIKit_Dynamics/&quot;&gt;UICollectionView+UIKit Dynamics&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on February 27, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[制作自己的Gem]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/ruby/make_your_own_gem/" />
  <id>http://morisunshine.com/ruby/make_your_own_gem</id>
  <published>2014-02-19T00:00:00+08:00</published>
  <updated>2014-02-19T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&amp;nbsp;&lt;a href=&quot;#introduce&quot;&gt;&lt;strong&gt;什么是Gem？&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#first_gem&quot;&gt;&lt;strong&gt;第一个Gem&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#include_more_files&quot;&gt;&lt;strong&gt;包含更多文件&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#adding_an_executable&quot;&gt;&lt;strong&gt;添加可执行文件&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#writing_tests&quot;&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&amp;nbsp;&lt;a href=&quot;#documenting_your_code&quot;&gt;&lt;strong&gt;文档&lt;/strong&gt;&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;&lt;a id=&#39;introduce&#39; name=&#39;introduce&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;什么是Gem?&lt;/h2&gt;

&lt;p&gt;RubyGems是一个方便而强大的Ruby程序包管理器，Ruby的第三方插件是用gem方式来管理，非常容易发布和共享，一个简单的命令就可以安装上第三方的扩展库。特点：能远程安装包，包之间依赖关系的管理，简单可靠的卸载，查询机制，能查询本地和远程服务器的包信息，能保持一个包的不同版本，基于Web的查看接口，能查看你安装的gem的信息。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;first_gem&#39; name=&#39;first_gem&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;第一个Gem&lt;/h2&gt;

&lt;p&gt;我们要创建一个名叫&lt;code&gt;moondemo&lt;/code&gt;的gem，首先，就要创建一个名字为&lt;code&gt;moondemo_yourname&lt;/code&gt;的目录，这个是为了后面的发布，如果你想发布的话，就要检查一下你的gem名字是否已经被人使用了，如果已经被人使用，那就要换个名字了。&lt;br&gt;
然后这个目录里的基本文件结构应该是这样的。 &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;➜  tree  
.  
├── moondemo.gemspec    
├── lib  
│   └── moondemo.rb  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gem中的代码被放在&lt;code&gt;lib&lt;/code&gt;目录中，这里有个约定就是&lt;code&gt;lib&lt;/code&gt;中必须有个和gem同名的ruby文件，这样当&lt;code&gt;require &amp;#39;moondemo&amp;#39;&lt;/code&gt;运行的时候，这个gem就会被加载，这个文件就是负责配置你的gem的代码和API。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;➜  cat lib/moondemo.rb
class moondemo
  def self.hi
    puts &amp;quot;Hello world!&amp;quot;
  end
end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而&lt;code&gt;.gemspec&lt;/code&gt;文件是定义了这个gem的信息，比如是这个gem的功能，作者等，并且当这个gem发布的时候，会将这些信息显示到这个gem的主页上(就像&lt;a href=&quot;http://rubygems.org/gems/jekyll&quot;&gt;jekyll&lt;/a&gt;)。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;➜  cat moondemo.gemspec
Gem::Specification.new do |s|
  s.name        = &amp;#39;moondemo&amp;#39;
  s.version     = &amp;#39;0.0.0&amp;#39;
  s.date        = &amp;#39;2014-02-19&amp;#39;
  s.summary     = &amp;quot;moondemo!&amp;quot;
  s.description = &amp;quot;A simple hello world gem&amp;quot;
  s.authors     = [&amp;quot;sheldon huang&amp;quot;]
  s.email       = &amp;#39;allenwenzhou@gmail.com&amp;#39;
  s.files       = [&amp;quot;lib/moondemo.rb&amp;quot;]
  s.homepage    =
    &amp;#39;http://rubygems.org/gems/moondemo&amp;#39;
  s.license       = &amp;#39;MIT&amp;#39;
end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有很多选项，一看名字就知道他们是要代表什么内容的，如果你还想知道更多就看一些这个&lt;a href=&quot;http://guides.rubygems.org/specification-reference/&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当我们创建完成了一个.gemspec，就可以编译出一个gem了，是不是有点小激动啊。但如果想要测试它就必须要在本地安装编译好的gem。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;➜ gem build moondemo.gemspec
  Successfully built RubyGem
  Name: moondemo
  Version: 0.0.1
  File: moondemo-0.0.1.gem

➜ gem install ./moondemo-0.0.1.gem
Successfully installed moondemo-0.0.1
Parsing documentation for moondemo-0.0.1
Installing ri documentation for moondemo-0.0.1
1 gem installed

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这些步骤，只能是在本地已经装好了我们自己的gem，但还没有使用它，
我们需要&lt;code&gt;require&lt;/code&gt;这个gem然后根据自己定义的方法来使用它。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;
➜ irb
2.0.0-p353 :001 &amp;gt; require &amp;#39;moondemo&amp;#39;
 =&amp;gt; true
2.0.0-p353 :002 &amp;gt; MoonDemo.hi
Hello world!
 =&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在就可以将你的gem发布到Ruby社区上了，当在发布之前需要将你的帐号安装在电脑上，如果你在RubyGems.org上注册了帐号，那就只需要输入一个命令,再输入自己的密码就可以了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;➜ curl -u 你的帐号名 https://rubygems.org/api/v1/api_key.yaml &amp;gt; ~/.gem/credentials; chmod 0600 ~/.gem/credentials

Enter host password for user &amp;#39;你的帐号名&amp;#39;:

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦你的用户名已经被安装了，就可以直接发布你的gem了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;➜ gem push moondemo-0.0.1.gem
Pushing gem to https://rubygems.org...
Successfully registered gem: moondemo (0.0.1)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很快的，你的gem就可以被任何人使用了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;➜ gem install moondemo
Successfully installed moondemo-0.0.1
Parsing documentation for moondemo-0.0.1
1 gem installed

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用Ruby和RubyGems来分享代码是不是很简单。&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a id=&#39;include_more_files&#39; name=&#39;include_more_files&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;包含更多文件&lt;/h2&gt;

&lt;p&gt;我们以后代码当然不会这么简单，如果代码变得非常多了之后，该怎么办呢，当然是要是要将代码分到不同的文件中了。&lt;br&gt;
比如我们想在刚才的gem中添加根据不同语言来输出不同语言的&amp;quot;Hello world&amp;quot;。&lt;br&gt;
我们就可以添加一个&lt;code&gt;Translator&lt;/code&gt;文件，刚才提到过，gem的根文件是负责加载代码的，所以其他的功能的文件就需要放在&lt;code&gt;lib&lt;/code&gt;中和gem同名的目录中，我们可以这样分:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;➜ tree
.
├── lib
│   ├── moondemo
│   │   └── translator.rb
│   └── moondemo.rb
├── moondemo-0.0.1.gem

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Translator&lt;/code&gt;中的内容是:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;class Translator
  def initialize(language)
    @language = language
  end

  def hi
    case @language
      when &amp;quot;chinese&amp;quot;
        &amp;quot;你好，世界!&amp;quot;
      else
        &amp;quot;Hello world!&amp;quot;
      end
  end
end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以接下来，&lt;code&gt;moondemo.rb&lt;/code&gt;中需要加载&lt;code&gt;Translator&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;class MoonDemo
  def self.hi(language = &amp;quot;english&amp;quot;)
    translator = Translator.new(language)
    translator.hi
  end
end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;注意:每次新建了一个目录或者文件，都不要忘记加到.gemspec文件中，就像这样&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt; s.authors     = [&amp;quot;Sheldon&amp;quot;]
 s.email       = &amp;#39;allenwenzhou@gmial.com&amp;#39;
 s.files       = [&amp;quot;lib/moondemo.rb&amp;quot;,&amp;quot;lib/moondemo/translator.rb&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;如果没有上面的修改的话，这个新建的目录是不会被加载到已安装的gem里的&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;让我们再运行一篇&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;➜ irb -Ilib -rmoondemo
2.0.0-p353 :001 &amp;gt; MoonDemo.hi(&amp;quot;english&amp;quot;)
 =&amp;gt; &amp;quot;Hello world!&amp;quot;
2.0.0-p353 :002 &amp;gt; MoonDemo.hi(&amp;quot;chinese&amp;quot;)
 =&amp;gt; &amp;quot;你好，世界!&amp;quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们使用了一个新的命令行&lt;code&gt;-Ilib&lt;/code&gt;,通常RubyGems会为你包含了&lt;code&gt;lib&lt;/code&gt;路径，所以很多时候，我们不需要去考虑配置它们的加载路径，但是，如果你把代码运行在RubyGems的项目之外，你就要自己去配置这些了。&lt;/p&gt;

&lt;p&gt;如果你添加了一些新的文件到你的gem中，那么你一定要记住在发布之前将这些文件添加到你的&lt;code&gt;.gemspec&lt;/code&gt;的&lt;code&gt;files&lt;/code&gt;数组中。这样很麻烦是么，所以很多人就选择用&lt;a href=&quot;http://docs.seattlerb.org/hoe/&quot;&gt;Hoe&lt;/a&gt;,&lt;a href=&quot;https://github.com/technicalpickles/jeweler&quot;&gt;Jeweler&lt;/a&gt;,&lt;a href=&quot;http://rake.rubyforge.org/classes/Rake/GemPackageTask.html&quot;&gt;Rake&lt;/a&gt;,&lt;a href=&quot;http://railscasts.com/episodes/245-new-gem-with-bundler&quot;&gt;Bundler&lt;/a&gt;或者用&lt;a href=&quot;https://github.com/wycats/newgem-template/blob/master/newgem.gemspec&quot;&gt;动态的gemspec&lt;/a&gt;来实现自动化。&lt;/p&gt;

&lt;p&gt;添加更多的目录也都是按照上面一样的步骤，我们要将我们的文件结构分布合理，这样对于我们以后的维护和未来开发人员来说就不会是一件头疼的事儿了。&lt;/p&gt;

&lt;p&gt;&lt;a id=&#39;adding_an_executable&#39; name=&#39;adding_an_executable&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;添加可执行文件&lt;/h2&gt;

&lt;p&gt;gem除了可以提供Ruby代码库外，还可以在你的可执行文件路径里提供很多可执行可执行文件文件。可能最有名的就是&lt;code&gt;rake&lt;/code&gt;，
添加一个可执行可执行可执行文件文件其实很简单，你只需要将你的可执行文件放在你的gem的&lt;code&gt;bin&lt;/code&gt;目录下，然后在将这个文件添加到&lt;code&gt;.gemspec&lt;/code&gt;文件中&lt;code&gt;executables&lt;/code&gt;的列表里就可以了，让我们试一下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;➜  mkdir bin
➜  touch bin/moondemo
➜  chmod a+x bin/moondemo

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个可执行文件只需要在开头用&lt;a href=&quot;http://www.catb.org/jargon/html/S/shebang.html&quot;&gt;shebang&lt;/a&gt;来表明这是用程序来运行的，下面就是这个可执行文件的内容:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;#!/usr/bin/env ruby

require &amp;#39;moondemo&amp;#39;
puts MoonDemo.hi(ARGV[0])

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个可执行文件的内容很简单，它只是加载了moondemo这个gem，然后在命令行中通过输入一个参数来判断是用哪个国家的语言来说&amp;quot;hello, world&amp;quot;。下面就是运行的例子:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;➜  ruby -Ilib ./bin/moondemo
Hello world!
➜  ruby -Ilib ./bin/moondemo chinese
你好，世界!

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，我们要将这个可执行文件添加到&lt;code&gt;.gemspec&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;s.executables &amp;lt;&amp;lt; &amp;#39;moondemo&amp;#39;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新你的gem，上传到官网上，这样你就可以在命令行中有自己的命令了，是不是很帅啊。这里要提醒一下，上传新的gem时，要记得修改&lt;code&gt;.gemspec&lt;/code&gt;中的版本号。详情看&lt;a href=&quot;http://guides.rubygems.org/patterns/#semantic-versioning&quot;&gt;这儿&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在看一下用我们自己定义的命令行吧:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;
➜  ~  moondemo
Hello world!
➜  ~  moondemo chinese
你好，世界!

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;世界在向我们招手呢。哈哈哈~~~&lt;/p&gt;

&lt;p&gt;&lt;a id=&#39;writing_tests&#39; name=&#39;writing_tests&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;测试&lt;/h1&gt;

&lt;p&gt;测试我们的gem是非常重要的，它不仅保证了这个gem是正常的，也保证了别人能知道你的gem是正常的。当我们评价一个gem的时候，很多Ruby开发者会倾向于通过查看测试用例来做为主要依据。&lt;/p&gt;

&lt;p&gt;Gems是支持将测试文件添加到程序包中的，所以当gem被下载了之后，我们可以直接运行测试用例。这里有个帮助我们如何在不同框架和解释器下写测试用例的社区叫&lt;a href=&quot;http://test.rubygems.org/&quot;&gt;GemTesters&lt;/a&gt;
总而言之:去测试我们的Gem吧！啥都别想了！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Test::Unit&lt;/code&gt;是Ruby的自带测试框架。这里有很多&lt;a href=&quot;https://github.com/seattlerb/minitest/blob/master/README.txt&quot;&gt;教程&lt;/a&gt;，当然还是有很多其他的测试框架，&lt;a href=&quot;http://rspec.info/&quot;&gt;RSpec&lt;/a&gt;就是比较有名的一个，是不是迫不及待，让我们测试吧！&lt;/p&gt;

&lt;p&gt;我们需要在原来的基础上再添加一些文件，一个名为&lt;code&gt;Rakefile&lt;/code&gt;的文件和一个名为&lt;code&gt;test&lt;/code&gt;的目录:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;
.
├── Rakefile
├── bin
│   └── moondemo
├── lib
│   ├── moondemo
│   │   └── translator.rb
│   └── moondemo.rb
├── moondemo-0.0.1.gem
├── moondemo.gemspec
├── npm-debug.log
└── test
    └── test_moondemo.rb

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Rakefile&lt;/code&gt;文件是为了实现自动化的测试:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;
require &amp;#39;rake/testtask&amp;#39;

Rake::TestTask.new do |t|
        t.libs &amp;lt;&amp;lt; &amp;#39;test&amp;#39;
end

desc &amp;quot;Run tests&amp;quot;
task :default =&amp;gt; :test
~

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面就是一个简单的测试用例了:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby language-ruby&quot; data-lang=&quot;ruby&quot;&gt;require &amp;#39;test/unit&amp;#39;
require &amp;#39;moondemo&amp;#39;

class MoonDemoTest &amp;lt; Test::Unit::TestCase
  def test_english_hello
    assert_equal &amp;quot;Hello world!&amp;quot;,
      MoonDemo.hi(&amp;quot;english&amp;quot;)
  end

  def test_any_hello
    assert_equal &amp;quot;Hello world!&amp;quot;,
      MoonDemo.hi(&amp;quot;ruby&amp;quot;)
  end

  def test_spanish_hello
    assert_equal &amp;quot;你好，世界!&amp;quot;,
      MoonDemo.hi(&amp;quot;chinese&amp;quot;)
  end
end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，让我们运行这个测试:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash language-bash&quot; data-lang=&quot;bash&quot;&gt;➜  rake test
Run options:

# Running tests:

Finished tests in 0.006151s, 487.7256 tests/s, 487.7256 assertions/s.
3 tests, 3 assertions, 0 failures, 0 errors, 0 skips

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很好，全部都通过了！&lt;/p&gt;

&lt;p&gt;&lt;a id=&#39;documenting_your_code&#39; name=&#39;documenting_your_code&#39;&gt; &lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;文档&lt;/h1&gt;

&lt;p&gt;文档和测试是一样重要的，大部分gem都是用RDoc来生成文档的，这里有很多&lt;a href=&quot;http://docs.seattlerb.org/rdoc/RDoc/Markup.html&quot;&gt;教程&lt;/a&gt;.
很简单，先切换到gem的根目录下，再命令行中输入&lt;code&gt;rdoc&lt;/code&gt;，你就会发现多出了一个名为&lt;code&gt;doc&lt;/code&gt;的目录，里面就是我们的文档了，当然你可以自己再进行一些调整。
除了RDoc呢，我们还有另外的选择&lt;a href=&quot;http://yardoc.org/&quot;&gt;YARD&lt;/a&gt;，当我们发布了gem的时候呢，&lt;a href=&quot;http://rubydoc.info/&quot;&gt;RubyDoc.info&lt;/a&gt;会根据你的gem自动生成YARDocs，并且它是可以向下兼容RDoc。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/ruby/make_your_own_gem/&quot;&gt;制作自己的Gem&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on February 19, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[第一篇博客]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/%E6%8A%98%E8%85%BE/my_first_blog/" />
  <id>http://morisunshine.com/%E6%8A%98%E8%85%BE/my_first_blog</id>
  <published>2014-02-15T00:00:00+08:00</published>
  <updated>2014-02-15T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;果然生命在于折腾啊，折腾完之后，就会发现之前觉得挺难的事其实也没什么大不了，比如弄这个博客，以前对技术牛人的评判标准就是有个自己域名的博客，崇拜之情如黄河泛滥不可收拾，当自己有勇气去搭建一个的时侯，发现原来这么简单，只要买个域名就可以了，当然那些有些博客是很牛的，但对我来说，这样简单的博客就是我想要的，而内容才是博客最重要的地方。&lt;/p&gt;

&lt;p&gt;至于我会在博客里写什么？在这个问题上，没有很明确的限制，希望它是我成长的记事本，无论是生活的哪个方面。我相信人的一生是一个漫长积累的过程，我希望能在这里见证这个过程。也可以理解为娱乐自己。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/%E6%8A%98%E8%85%BE/my_first_blog/&quot;&gt;第一篇博客&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on February 15, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[iOS设计模式学习---装饰模式]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/ios/ios_decorator/" />
  <id>http://morisunshine.com/ios/ios_decorator</id>
  <published>2013-07-14T00:00:00+08:00</published>
  <updated>2013-07-14T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;h2&gt;定义&lt;/h2&gt;

&lt;p&gt;装饰模式（Decorator），动态地为一个对象添加额外的职责，是继承的替代方案，属于结构型模式。通过装饰模式扩展对象的功能比继承子类方式更灵活，使用继承子类的方式，是在编译时静态决定的，即编译时绑定，而且所有的子类都会继承相同的行为。然而，如果使用组合的方式扩展对象的行为，就可以在运行时动态地进行扩展，将来如果需要也可以动态的撤销，而不会影响原类的行为。&lt;br&gt;
&lt;img src=&quot;/images/2013-7-14.jpg&quot; alt=&quot;图片&quot;&gt;  &lt;/p&gt;

&lt;h2&gt;实例&lt;/h2&gt;

&lt;p&gt;接下来，通过Object-C来实践一下，我设想一个场景，用Decorator模式来实现一下对某个手机的GPS和蓝牙功能扩展
首先，我们需要一个手机的接口或者抽象类，我这里就用抽象类来实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;@interface AbstractCellPhone : NSObject
- (NSString *)callNumber;
- (NSString *)sendMessage;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;#import &amp;quot;AbstractCellPhone.h&amp;quot;

@implementation AbstractCellPhone

- (NSString *)callNumber
{
    return @&amp;quot;phone call somebody&amp;quot;;
}

- (NSString *)sendMessage
{
    return @&amp;quot;phone send a message to somebody&amp;quot;;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AbstractCellPhone也就是结构图中的Component，然后，我再来实现Nokia和Moto的手机类，这类要继承AbstractCellPhone，也就是图中ConcreteComponent类要继承Component，实现代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
#import &amp;quot;AbstractCellPhone.h&amp;quot;   
@interface NokiaPhone : AbstractCellPhone
@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
#import &amp;quot;NokiaPhone.h&amp;quot;

@implementation NokiaPhone

- (NSString *)callNumber
{
    return @&amp;quot;NokiaPhone call somebody&amp;quot;;
}

- (NSString *)sendMessage
{
    return @&amp;quot;NokiaPhone send Message to Somebody&amp;quot;;
}

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我需要一个Decorator接口或者抽象类，实现代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
#import &amp;quot;AbstractCellPhone.h&amp;quot;

@interface Decorator : AbstractCellPhone
{
@protected AbstractCellPhone *abstractCellPhone;
}
-(void)SetComponents:(Components*)component;
@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
#import &amp;quot;Decorator.h&amp;quot;

@implementation Decorator
-(void)SetComponents:(Components*)component{
    components = component;
}

- (NSString *)callNumber
{
    return components.callNumber;
}

- (NSString *)sendMessage
{
    return components.sendMessage;
}
@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如结构图中，这个Decorator即继承了AbstractCellPhone，又包含了一个私有的AbstractCellPhone的对象。这样做的意义是：Decorator类又使用了另外一个Component类。我们可以使用一个或多个Decorator对象来“装饰”一个Component对象，且装饰后的对象仍然是一个Component对象。在下来，我要实现GSP和蓝牙的功能扩展，它们要继承自Decorator，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
#import &amp;quot;Decorator.h&amp;quot;

@interface DecoratorGPS : Decorator

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
#import &amp;quot;DecoratorGPS.h&amp;quot;

@implementation DecoratorGPS

- (NSString *)callNumber
{
    return [NSString stringWithFormat:@&amp;quot;%@ with GPS&amp;quot;, [super callNumber]];
}

- (NSString *)sendMessage
{
    return [NSString stringWithFormat:@&amp;quot;%@ with GPS&amp;quot;, [super sendMessage]];
}

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，用客户端程序验证一下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt;
int main(int argc, const char *argv[])
{
    @autoreleasepool {

        Components *phone = [[ConcreteComponent alloc] init];
        NSLog(@&amp;quot;%@&amp;quot;,phone.callNumber);
        NSLog(@&amp;quot;%@&amp;quot;,phone.sendMessage);
        ConcreteDecoratorA *GPS = [[ConcreteDecoratorA alloc] init];
        [GPS SetComponents:phone];
        NSLog(@&amp;quot;%@&amp;quot;,GPS.callNumber);
        NSLog(@&amp;quot;%@&amp;quot;,GPS.sendMessage);
        ConcreteDecoratorB *bluetooth = [[ConcreteDecoratorB alloc] init];
        [bluetooth SetComponents:phone];
        NSLog(@&amp;quot;%@&amp;quot;,bluetooth.callNumber);
        NSLog(@&amp;quot;%@&amp;quot;,bluetooth.sendMessage);
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;objc language-objc&quot; data-lang=&quot;objc&quot;&gt; NokiaPhone call somebody
 NokiaPhone send Message to Somebody
 NokiaPhone call somebody with GPS
 NokiaPhone send Message to Somebody with GPS
 NokiaPhone call somebody with BlueTooth
 NokiaPhone send Message to Somebody with BlueTooth

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/ios/ios_decorator/&quot;&gt;iOS设计模式学习---装饰模式&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on July 14, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[站在原地, 心存远方]]></title>
 <link rel="alternate" type="text/html" href="http://morisunshine.com/%E7%94%9F%E6%B4%BB/travel-to-qinghai/" />
  <id>http://morisunshine.com/%E7%94%9F%E6%B4%BB/travel-to-qinghai</id>
  <published>2013-01-10T00:00:00+08:00</published>
  <updated>2013-01-10T00:00:00+08:00</updated>
  <author>
    <name>Sheldon</name>
    <uri>http://morisunshine.com</uri>
    <email>sheldon.zen@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&lt;img src=&quot;/images/p7796217.jpg&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;

&lt;p style=&quot;text-indent: 2em;&quot;&gt;
旅行不是我一定要做的事，却是我一直想做的事。与旅行的结识，源于一部电影《第36个故事》，电影里的咖啡馆，浮想式的画面，以物易物，沙发客，环球旅行，都给那个漫长而又无聊的夏天带来了一阵清新的风。于是慢慢地开始去找寻许多关于旅行的故事，知道得愈多，对旅行的向往就愈强烈，然而看过了那么多关于旅行的书与电影，却发现自己依然站在原地。就像那些旅行的人常说的“只要踏出第一步，你就已经在路上了”，于是我一直在等待那第一步的到来。
&lt;/p&gt;

&lt;p style=&quot;text-indent: 2em;&quot;&gt;
    2012年7月19号，我匆匆忙忙地结束了实习的最后工作，回到寝室整理背包，脸上是难以抑制的兴奋，因为再过十几个小时，我就可以开始我的远行。
&lt;/p&gt;

&lt;p style=&quot;text-indent: 2em;&quot;&gt;
    每段旅行都是从交通工具开始，我坐上去兰州的火车，很幸运地买到了靠窗的位置，望着窗外，脑海中翻过很多旅行故事，想象着即将发生的一切。过不多久，火车开始运行，一直觉得绿皮火车是旅行的美好开始，车厢里的人充满人情味的对白，会让你忘了车途的颠簸。可是慢慢地开始困倦，望着窗外，渐渐倦意起来，眯了一会儿又醒来，急忙看着手机，才过了一个小时，于是从背包中抽出舒国治的《流浪集》来读，车厢内，摇摇晃晃，灯光，忽明忽暗，难以定神阅读，就这样迷迷糊糊，又昏昏欲睡，可是每睡一会并醒，醒的时候又看着窗外，风景依旧，知道自己只不过睡了一会儿，想象中那个有故事的人没来，对面坐着的大叔若无其事地磕着瓜子，没有发现我的期盼，我只能戴着耳机听着音乐，旅行还未开始，就已经感觉厌倦，只期望快点结束这漫长的颠簸。
&lt;/p&gt;

&lt;p style=&quot;text-indent: 2em;&quot;&gt;
    接下来的十天，与同学们一起逛兰州的夜市，吃着各种没有吃过的美食，与一群同龄人包车环青海湖，途中有说有笑。远行之美，在于那在远方，距离让两个地方之间有许多不同，天空，白云，蓝天，草地，湖水，一切在南方可以看到的东西，在西部这个空旷的世界里，却见到更多，每一样风景都可以让我们心旷神怡，对于这些风景，言语总是匮乏，最好的表达就是坐在那里，静静远望，让感动留在心里。
 
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/p7796228.jpg&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;

&lt;p style=&quot;text-indent: 2em;&quot;&gt;
印象中，独自旅行是最浪漫的方式，就像一个侠客，可以在天地之间任我飘逸。在兰州与同学们分开之后，我并开始了自己盼望已久的独自旅行，身边虽然没有可以了熟悉的朋友，却可以在路上遇到许多朋友，孤独也有孤独的自由。在通过同学的推荐下,我知道甘南这个地方,后来又在青旅里做过一些攻略，但是看来看去，最后还是只记住几个地名就上路了，太详细的攻略固定了旅行的不确定性，虽然保证了安全，却失去了很多乐趣。在来甘南之前，我在兰州的青旅里认识了在云南开酒吧的纪姐,还有一个在四川上大学的妹子,后来又在去夏河的大巴上认识了一个退伍军人，我们都叫他鞋子，还有两个女孩，我们就一起结伴。在夏河的最深印象就是出租车，无论到哪里都是一块钱，就像坐公交车一样方便。我们三天一直住在宝马宾馆，住宿费很便宜，只要15块钱一个晚上，白天我们一起去看了拉卜楞寺，桑科草原，八角古城，到了晚上就逛夏河，淘一些饰品带回去。我们到八角城的时候，就碰到一位夏河文化馆的馆长，原来他老家就在八角城，他那天是回家探亲，他很热情地为我们介绍这座有三千多年历史的八角古城，由于风化，原来的古城墙早已面目全非，只有站在高处，才能看到八角城的轮廓。馆长又把我们带到了一个小庙，那个小庙只有教室大小，然而里面却是整洁干净，在墙的周围种着娇艳的花朵，而地板上就像所有藏族区的寺庙一样被那些虔诚的藏民们跪得光滑，这时纪姐叫我们给这寺庙捐些钱，我就从兜里掏出五块钱想给守庙人，可是守庙人看到之后，拼命摇头，用藏语和馆长说了几句话，馆长对我们说“他说你们是远方来的客人，旅费本来就不多，你们还是自己用吧。”我当时听了之后，不知道该用什么语言去表达，相信这就是信仰下的善良，他们虽然物质匮乏内心却无比充实，而在那些物质丰富的大城市里，大部分人却活的并不快乐。后来我们又在街上闲逛，几个老人看见我们都很大方地向我们招手，我们对他们说“扎西得嘞”，他们也微笑地回应我们，在八角城的街头，总是能看到一个老人，手上拿着转经筒，端坐在地上，看着远处，我们静静走过，不忍心打扰。当我们准备离开的时候，一群孩子跑到村头向我们挥手，那一个个纯真的脸里上都是那个年龄该有的快乐。在回去的路上，我一直在想，是不是物质的匮乏反而让灵魂有地方栖息。
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/p7796213.jpg&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;

&lt;p style=&quot;text-indent: 2em;&quot;&gt;
在夏河的第四天，我们的路线开始不同，我要回兰州坐火车回家了，他们还要继续旅行，于是和他们挥手再见。和他们分手之后，我还有一天的时间，打算去最近的合作市去看看，那天不是很急，就先去拉卜楞寺又转了一圈转经长廊，在转经筒的时候，心里不知道该默念什么，当时有了搭车去合作的想法，于是心里就开始默念成功搭到车，可是后来又想还是保佑自己快乐吧，后来又想是不是该保佑爸妈快乐，身体健康呢，又想还有朋友呢，于是贪心越来越大，就想佛祖不会保佑这么贪心的人的，还是保佑自己快乐吧，我快乐，关心我的人也会快乐，别人快乐所以我也会快乐，有因必有果。
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/p7796219.jpg&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;

&lt;p style=&quot;text-indent: 2em;&quot;&gt;
搭车是我很意外的想法，本来这次旅行并没有搭车的准备，但是在青旅里遇到很多人都有过搭车的经历，听他们说起来自己的搭车经历觉得很简单，又很好玩，就想尝试一下，但是后来我跟同学说了这个想法之后，她说搭车不是那么容易的，会被拒绝很多次的。当时心里在犹豫，可是后来一想，拒绝就拒绝吧，又不会把我怎么样，旅行就是要尝试一下才有意思。就这样在旅行的最后一站，我举起了大拇指。我一边走一边问路人去合作的方向，一看到有车子经过就举起大拇指，可是大部分都是出租车停了下来，有些司机并没有理我，有些司机还是很和善地向我摇了摇手，我就一直向前方走，终于在一个路口，停下了一辆小面包车，坐在副驾驶座的大叔摇下窗户问我“你要去哪里？”我说：“我要去合作。”然后那个大叔就和驾驶座上的司机说了一下，就对我说“上来吧”。我很兴奋地坐上了后座，终于搭到第一辆车啦，可是没开多少里路，那个大叔转过头来对我说，一会儿给司机15块钱，我听了之后就懵了，后来就想给了钱就不叫搭车了，于是就叫司机在前面把我放下。又问了了路边的一个大叔这是不是去合作的方向，大叔点点头，我就又举起大拇指，刚举起大拇指，就又有一辆面包车停下来，打开车门叫我上来，由于刚才的经历，我对司机说的第一句话却是“要钱么？”司机大叔摇了摇头，我就上车了，心中羞愧自己的冒失，司机大叔好像在用藏语和家人聊天，我一句都听不懂，我想说谢谢，却不好意思打扰，当他一放下电话的时候，他就开口问我，“你是哪里人？”我说“我是浙江的”，于是就这样没有准备却很自然的聊了起来，慢慢地我的紧张感也慢慢放松下来，跟他说了自己最近的经历啊，司机大叔又跟我说了自己最近担忧的事，比如对这一代藏族孩子对信仰越来越不重视，还有到处修建的公路破坏了环境，他说开车有三十多年了，回忆起以前开车的日子，以前开车的时候虽然路况不好，窗外的风景却很美，即使开车的时候很颠簸，却依然很快乐。他后来又给我说了很多藏传佛教的知识，推荐了一些甘南比较美的地方，还教了我几句藏语，最后把我送到了合作的一个景点，九层佛阁，还告诉我在哪里可以坐到回兰州的大巴，我用他教我的藏语和他说“再见”。他和开心地和我挥手再见，开玩笑地说“回兰州可不能搭车咯”，我微笑地点点头。
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/p7796225.jpg&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;

&lt;p style=&quot;text-indent: 2em;&quot;&gt;
旅行的意义是什么，在这次旅行之前，我好像很清楚，因为很多书中都可以找到，逃离原来的安全圈，发现自我，做自己想做的事情等等。可是，旅行之后，我却说不清楚，也许只是一次行走，从一个地方走到另一个地方，看看风景，与路上的人交朋友，互相交换故事，仅此而已。此刻我终于明白了《迟到的间隔年》中的一段话“旅行是寻找不到答案的，它只会让你多了选择，甚至更加迷茫，但完全值得”，当你在旅行中过于强调意义，注定得不到什么。所以冷暖自知，总有言语无法表达的心情，想要知道，就去旅行吧。
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/p7796220.jpg&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://morisunshine.com/%E7%94%9F%E6%B4%BB/travel-to-qinghai/&quot;&gt;站在原地, 心存远方&lt;/a&gt; was originally published by Sheldon at &lt;a href=&quot;http://morisunshine.com&quot;&gt;Morisunshine's Blog&lt;/a&gt; on January 10, 2013.&lt;/p&gt;</content>
</entry>

</feed>
